{"file_contents":{"client/src/pages/Home.tsx":{"content":"import { useForm } from \"react-hook-form\";\nimport { zodResolver } from \"@hookform/resolvers/zod\";\nimport { insertLeadSchema, type InsertLead } from \"@shared/schema\";\nimport { useCreateLead } from \"@/hooks/use-leads\";\nimport { motion } from \"framer-motion\";\nimport { Loader2 } from \"lucide-react\";\n\nexport default function Home() {\n  const { mutate, isPending } = useCreateLead();\n  \n  const form = useForm<InsertLead>({\n    resolver: zodResolver(insertLeadSchema),\n    defaultValues: {\n      email: \"\",\n    },\n  });\n\n  const onSubmit = (data: InsertLead) => {\n    mutate(data, {\n      onSuccess: () => form.reset(),\n    });\n  };\n\n  return (\n    <div className=\"min-h-screen w-full flex flex-col justify-center items-center p-6 sm:p-12\">\n      <motion.div \n        initial={{ opacity: 0, y: 10 }}\n        animate={{ opacity: 1, y: 0 }}\n        transition={{ duration: 0.8, ease: \"easeOut\" }}\n        className=\"max-w-xl w-full space-y-12\"\n      >\n        {/* Header Section */}\n        <header className=\"space-y-6\">\n          <h1 className=\"text-6xl sm:text-8xl font-medium tracking-tighter\">\n            holdr\n          </h1>\n          <p className=\"text-lg sm:text-xl text-muted-foreground leading-relaxed max-w-md\">\n            The minimalist placeholder for your next big idea. \n            Secure your spot before it's gone.\n          </p>\n        </header>\n\n        {/* Input Section */}\n        <div className=\"pt-8 border-t border-border\">\n          <form onSubmit={form.handleSubmit(onSubmit)} className=\"space-y-4\">\n            <div className=\"flex flex-col sm:flex-row gap-4\">\n              <div className=\"flex-1\">\n                <input\n                  {...form.register(\"email\")}\n                  placeholder=\"enter your email...\"\n                  className=\"w-full bg-transparent border-b border-muted-foreground/30 py-3 px-0 text-lg focus:outline-none focus:border-black transition-colors placeholder:text-muted-foreground/50\"\n                  autoComplete=\"email\"\n                  disabled={isPending}\n                />\n                {form.formState.errors.email && (\n                  <p className=\"mt-2 text-sm text-red-500\">\n                    {form.formState.errors.email.message}\n                  </p>\n                )}\n              </div>\n              \n              <button\n                type=\"submit\"\n                disabled={isPending}\n                className=\"shrink-0 bg-black text-white px-8 py-3 text-lg hover:bg-neutral-800 disabled:opacity-50 disabled:cursor-not-allowed transition-colors\"\n              >\n                {isPending ? (\n                  <Loader2 className=\"h-6 w-6 animate-spin\" />\n                ) : (\n                  \"Notify me\"\n                )}\n              </button>\n            </div>\n            <p className=\"text-xs text-muted-foreground\">\n              * No spam. Just updates.\n            </p>\n          </form>\n        </div>\n\n        {/* Footer */}\n        <footer className=\"pt-24 flex justify-between text-xs text-muted-foreground uppercase tracking-widest\">\n          <span>© 2024 holdr inc.</span>\n          <span>SFO — NYC — LDN</span>\n        </footer>\n      </motion.div>\n    </div>\n  );\n}\n","path":null,"size_bytes":3189,"size_tokens":null},"client/src/components/ui/accordion.tsx":{"content":"import * as React from \"react\"\nimport * as AccordionPrimitive from \"@radix-ui/react-accordion\"\nimport { ChevronDown } from \"lucide-react\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst Accordion = AccordionPrimitive.Root\n\nconst AccordionItem = React.forwardRef<\n  React.ElementRef<typeof AccordionPrimitive.Item>,\n  React.ComponentPropsWithoutRef<typeof AccordionPrimitive.Item>\n>(({ className, ...props }, ref) => (\n  <AccordionPrimitive.Item\n    ref={ref}\n    className={cn(\"border-b\", className)}\n    {...props}\n  />\n))\nAccordionItem.displayName = \"AccordionItem\"\n\nconst AccordionTrigger = React.forwardRef<\n  React.ElementRef<typeof AccordionPrimitive.Trigger>,\n  React.ComponentPropsWithoutRef<typeof AccordionPrimitive.Trigger>\n>(({ className, children, ...props }, ref) => (\n  <AccordionPrimitive.Header className=\"flex\">\n    <AccordionPrimitive.Trigger\n      ref={ref}\n      className={cn(\n        \"flex flex-1 items-center justify-between py-4 font-medium transition-all hover:underline [&[data-state=open]>svg]:rotate-180\",\n        className\n      )}\n      {...props}\n    >\n      {children}\n      <ChevronDown className=\"h-4 w-4 shrink-0 transition-transform duration-200\" />\n    </AccordionPrimitive.Trigger>\n  </AccordionPrimitive.Header>\n))\nAccordionTrigger.displayName = AccordionPrimitive.Trigger.displayName\n\nconst AccordionContent = React.forwardRef<\n  React.ElementRef<typeof AccordionPrimitive.Content>,\n  React.ComponentPropsWithoutRef<typeof AccordionPrimitive.Content>\n>(({ className, children, ...props }, ref) => (\n  <AccordionPrimitive.Content\n    ref={ref}\n    className=\"overflow-hidden text-sm transition-all data-[state=closed]:animate-accordion-up data-[state=open]:animate-accordion-down\"\n    {...props}\n  >\n    <div className={cn(\"pb-4 pt-0\", className)}>{children}</div>\n  </AccordionPrimitive.Content>\n))\n\nAccordionContent.displayName = AccordionPrimitive.Content.displayName\n\nexport { Accordion, AccordionItem, AccordionTrigger, AccordionContent }\n","path":null,"size_bytes":1977,"size_tokens":null},"client/src/pages/bridge.tsx":{"content":"import { useState, useEffect, useRef } from \"react\";\nimport { useLocation } from \"wouter\";\nimport { Card, CardContent, CardDescription, CardHeader, CardTitle } from \"@/components/ui/card\";\nimport { Alert, AlertDescription } from \"@/components/ui/alert\";\nimport { Button } from \"@/components/ui/button\";\nimport { Input } from \"@/components/ui/input\";\nimport { Badge } from \"@/components/ui/badge\";\nimport { Smartphone, Monitor, Wifi, WifiOff, Loader2, Check, Copy, QrCode } from \"lucide-react\";\nimport { useWallet } from \"@/lib/wallet-context\";\nimport { QRCodeSVG } from \"qrcode.react\";\n\nexport default function Bridge() {\n  const [, setLocation] = useLocation();\n  const { walletMode } = useWallet();\n  const [sessionId, setSessionId] = useState<string>(\"\");\n  const [inputSessionId, setInputSessionId] = useState(\"\");\n  const [role, setRole] = useState<\"desktop\" | \"mobile\" | null>(null);\n  const [connected, setConnected] = useState(false);\n  const [peerConnected, setPeerConnected] = useState(false);\n  const [connecting, setConnecting] = useState(false);\n  const [copied, setCopied] = useState(false);\n  const wsRef = useRef<WebSocket | null>(null);\n\n  const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);\n\n  useEffect(() => {\n    return () => {\n      if (wsRef.current) {\n        wsRef.current.close();\n      }\n    };\n  }, []);\n\n  const [error, setError] = useState<string | null>(null);\n\n  const createSession = async () => {\n    setConnecting(true);\n    setError(null);\n    try {\n      const response = await fetch(\"/api/bridge/create\", { method: \"POST\" });\n      if (!response.ok) {\n        throw new Error(\"Failed to create bridge session\");\n      }\n      const data = await response.json();\n      setSessionId(data.sessionId);\n      setRole(\"desktop\");\n      connectWebSocket(data.sessionId, \"desktop\");\n    } catch (err: any) {\n      console.error(\"Failed to create session:\", err);\n      setError(err.message || \"Failed to create session. Please try again.\");\n      setConnecting(false);\n    }\n  };\n\n  const joinSession = () => {\n    if (!inputSessionId.trim()) return;\n    setConnecting(true);\n    setError(null);\n    setSessionId(inputSessionId.toUpperCase());\n    setRole(\"mobile\");\n    connectWebSocket(inputSessionId.toUpperCase(), \"mobile\");\n  };\n\n  const connectWebSocket = (sid: string, r: \"desktop\" | \"mobile\") => {\n    const protocol = window.location.protocol === \"https:\" ? \"wss:\" : \"ws:\";\n    const ws = new WebSocket(`${protocol}//${window.location.host}/ws/bridge?sessionId=${sid}&role=${r}`);\n    \n    ws.onopen = () => {\n      setConnected(true);\n      setConnecting(false);\n    };\n\n    ws.onmessage = (event) => {\n      try {\n        const message = JSON.parse(event.data);\n        if (message.type === \"desktop_connected\" || message.type === \"mobile_connected\") {\n          setPeerConnected(true);\n        } else if (message.type === \"desktop_disconnected\" || message.type === \"mobile_disconnected\") {\n          setPeerConnected(false);\n        } else if (message.type === \"connected\") {\n          setConnected(true);\n        }\n        \n        // Handle Pico commands from mobile\n        if (r === \"desktop\" && message.from === \"mobile\" && message.type === \"pico_command\") {\n          handlePicoCommand(message, ws);\n        }\n        \n        // Handle Pico responses on mobile\n        if (r === \"mobile\" && message.from === \"desktop\" && message.type === \"pico_response\") {\n          window.dispatchEvent(new CustomEvent(\"bridge_pico_response\", { detail: message }));\n        }\n      } catch (e) {\n        console.error(\"WebSocket message error:\", e);\n      }\n    };\n\n    ws.onclose = () => {\n      setConnected(false);\n      setPeerConnected(false);\n    };\n\n    ws.onerror = () => {\n      setConnecting(false);\n      setError(\"Failed to connect. Please check your network and try again.\");\n    };\n\n    wsRef.current = ws;\n  };\n\n  const handlePicoCommand = async (message: any, ws: WebSocket) => {\n    // Forward command to Pico via the local hardware wallet connection\n    // This requires the desktop to have the Pico connected\n    try {\n      const { piWallet } = await import(\"@/lib/pi-wallet\");\n      let response: any;\n      \n      switch (message.command) {\n        case \"ping\":\n          response = await piWallet.ping();\n          break;\n        case \"getStatus\":\n          response = await piWallet.getStatus();\n          break;\n        case \"unlock\":\n          response = await piWallet.unlock(message.pin);\n          break;\n        case \"sendCommand\":\n          response = await piWallet.sendCommand(message.cmd, message.params);\n          break;\n        default:\n          response = { error: \"Unknown command\" };\n      }\n      \n      ws.send(JSON.stringify({\n        type: \"pico_response\",\n        requestId: message.requestId,\n        response\n      }));\n    } catch (error: any) {\n      ws.send(JSON.stringify({\n        type: \"pico_response\",\n        requestId: message.requestId,\n        error: error.message\n      }));\n    }\n  };\n\n  const copySessionId = () => {\n    navigator.clipboard.writeText(sessionId);\n    setCopied(true);\n    setTimeout(() => setCopied(false), 2000);\n  };\n\n  const bridgeUrl = `${window.location.origin}/bridge?join=${sessionId}`;\n\n  // Check URL for join parameter\n  useEffect(() => {\n    const params = new URLSearchParams(window.location.search);\n    const joinId = params.get(\"join\");\n    if (joinId) {\n      setInputSessionId(joinId);\n    }\n  }, []);\n\n  return (\n    <div className=\"flex-1 overflow-auto p-6\">\n      <div className=\"max-w-2xl mx-auto space-y-6\">\n        <div className=\"text-center space-y-2\">\n          <h1 className=\"text-2xl font-bold\">Mobile Bridge</h1>\n          <p className=\"text-muted-foreground\">\n            Connect your mobile device to access your Pico hardware wallet\n          </p>\n        </div>\n\n        {error && (\n          <Alert variant=\"destructive\">\n            <AlertDescription>{error}</AlertDescription>\n          </Alert>\n        )}\n\n        {!connected ? (\n          <div className=\"grid gap-4 md:grid-cols-2\">\n            <Card>\n              <CardHeader>\n                <CardTitle className=\"flex items-center gap-2\">\n                  <Monitor className=\"h-5 w-5\" />\n                  Desktop (Host)\n                </CardTitle>\n                <CardDescription>\n                  Connect your Pico to this computer and create a session\n                </CardDescription>\n              </CardHeader>\n              <CardContent>\n                <Button \n                  onClick={createSession} \n                  disabled={connecting}\n                  className=\"w-full\"\n                  data-testid=\"button-create-session\"\n                >\n                  {connecting ? (\n                    <Loader2 className=\"h-4 w-4 animate-spin mr-2\" />\n                  ) : null}\n                  Create Bridge Session\n                </Button>\n              </CardContent>\n            </Card>\n\n            <Card>\n              <CardHeader>\n                <CardTitle className=\"flex items-center gap-2\">\n                  <Smartphone className=\"h-5 w-5\" />\n                  Mobile (Client)\n                </CardTitle>\n                <CardDescription>\n                  Enter the session code from your desktop\n                </CardDescription>\n              </CardHeader>\n              <CardContent className=\"space-y-3\">\n                <Input\n                  placeholder=\"Session Code (e.g., ABC123)\"\n                  value={inputSessionId}\n                  onChange={(e) => setInputSessionId(e.target.value.toUpperCase())}\n                  maxLength={6}\n                  data-testid=\"input-session-code\"\n                />\n                <Button \n                  onClick={joinSession} \n                  disabled={connecting || !inputSessionId.trim()}\n                  className=\"w-full\"\n                  data-testid=\"button-join-session\"\n                >\n                  {connecting ? (\n                    <Loader2 className=\"h-4 w-4 animate-spin mr-2\" />\n                  ) : null}\n                  Join Session\n                </Button>\n              </CardContent>\n            </Card>\n          </div>\n        ) : (\n          <Card>\n            <CardHeader>\n              <CardTitle className=\"flex items-center justify-between gap-2\">\n                <span className=\"flex items-center gap-2\">\n                  {role === \"desktop\" ? <Monitor className=\"h-5 w-5\" /> : <Smartphone className=\"h-5 w-5\" />}\n                  {role === \"desktop\" ? \"Desktop Bridge Active\" : \"Mobile Connected\"}\n                </span>\n                <Badge variant={peerConnected ? \"default\" : \"secondary\"}>\n                  {peerConnected ? (\n                    <><Wifi className=\"h-3 w-3 mr-1\" /> Paired</>\n                  ) : (\n                    <><WifiOff className=\"h-3 w-3 mr-1\" /> Waiting</>\n                  )}\n                </Badge>\n              </CardTitle>\n            </CardHeader>\n            <CardContent className=\"space-y-4\">\n              {role === \"desktop\" && (\n                <>\n                  <div className=\"text-center space-y-4\">\n                    <div className=\"flex items-center justify-center gap-2\">\n                      <span className=\"text-muted-foreground\">Session Code:</span>\n                      <code className=\"text-2xl font-mono font-bold tracking-widest\" data-testid=\"text-session-code\">\n                        {sessionId}\n                      </code>\n                      <Button size=\"icon\" variant=\"ghost\" onClick={copySessionId} data-testid=\"button-copy-code\">\n                        {copied ? <Check className=\"h-4 w-4\" /> : <Copy className=\"h-4 w-4\" />}\n                      </Button>\n                    </div>\n                    \n                    <div className=\"flex justify-center\">\n                      <div className=\"bg-white p-4 rounded-lg\">\n                        <QRCodeSVG value={bridgeUrl} size={180} />\n                      </div>\n                    </div>\n                    \n                    <p className=\"text-sm text-muted-foreground\">\n                      Scan this QR code with your mobile device or enter the code manually\n                    </p>\n                  </div>\n\n                  {peerConnected ? (\n                    <div className=\"flex items-center justify-center gap-2 text-green-600 dark:text-green-400\">\n                      <Check className=\"h-5 w-5\" />\n                      <span>Mobile device connected! You can now use the wallet on your phone.</span>\n                    </div>\n                  ) : (\n                    <div className=\"flex items-center justify-center gap-2 text-muted-foreground\">\n                      <Loader2 className=\"h-4 w-4 animate-spin\" />\n                      <span>Waiting for mobile device to connect...</span>\n                    </div>\n                  )}\n                </>\n              )}\n\n              {role === \"mobile\" && (\n                <div className=\"text-center space-y-4\">\n                  {peerConnected ? (\n                    <>\n                      <div className=\"flex items-center justify-center gap-2 text-green-600 dark:text-green-400\">\n                        <Check className=\"h-5 w-5\" />\n                        <span>Connected to desktop!</span>\n                      </div>\n                      <Button onClick={() => setLocation(\"/\")} data-testid=\"button-go-dashboard\">\n                        Go to Dashboard\n                      </Button>\n                    </>\n                  ) : (\n                    <div className=\"flex items-center justify-center gap-2 text-muted-foreground\">\n                      <Loader2 className=\"h-4 w-4 animate-spin\" />\n                      <span>Waiting for desktop connection...</span>\n                    </div>\n                  )}\n                </div>\n              )}\n            </CardContent>\n          </Card>\n        )}\n\n        <Card>\n          <CardHeader>\n            <CardTitle>How It Works</CardTitle>\n          </CardHeader>\n          <CardContent className=\"space-y-3 text-sm text-muted-foreground\">\n            <p>\n              <strong>1.</strong> On your desktop/laptop, connect your Raspberry Pi Pico via USB\n            </p>\n            <p>\n              <strong>2.</strong> Create a bridge session on the desktop\n            </p>\n            <p>\n              <strong>3.</strong> Scan the QR code or enter the session code on your mobile device\n            </p>\n            <p>\n              <strong>4.</strong> Your mobile app will communicate with the Pico through the desktop\n            </p>\n          </CardContent>\n        </Card>\n      </div>\n    </div>\n  );\n}\n","path":null,"size_bytes":12717,"size_tokens":null},"client/src/components/ui/chart.tsx":{"content":"\"use client\"\n\nimport * as React from \"react\"\nimport * as RechartsPrimitive from \"recharts\"\n\nimport { cn } from \"@/lib/utils\"\n\n// Format: { THEME_NAME: CSS_SELECTOR }\nconst THEMES = { light: \"\", dark: \".dark\" } as const\n\nexport type ChartConfig = {\n  [k in string]: {\n    label?: React.ReactNode\n    icon?: React.ComponentType\n  } & (\n    | { color?: string; theme?: never }\n    | { color?: never; theme: Record<keyof typeof THEMES, string> }\n  )\n}\n\ntype ChartContextProps = {\n  config: ChartConfig\n}\n\nconst ChartContext = React.createContext<ChartContextProps | null>(null)\n\nfunction useChart() {\n  const context = React.useContext(ChartContext)\n\n  if (!context) {\n    throw new Error(\"useChart must be used within a <ChartContainer />\")\n  }\n\n  return context\n}\n\nconst ChartContainer = React.forwardRef<\n  HTMLDivElement,\n  React.ComponentProps<\"div\"> & {\n    config: ChartConfig\n    children: React.ComponentProps<\n      typeof RechartsPrimitive.ResponsiveContainer\n    >[\"children\"]\n  }\n>(({ id, className, children, config, ...props }, ref) => {\n  const uniqueId = React.useId()\n  const chartId = `chart-${id || uniqueId.replace(/:/g, \"\")}`\n\n  return (\n    <ChartContext.Provider value={{ config }}>\n      <div\n        data-chart={chartId}\n        ref={ref}\n        className={cn(\n          \"flex aspect-video justify-center text-xs [&_.recharts-cartesian-axis-tick_text]:fill-muted-foreground [&_.recharts-cartesian-grid_line[stroke='#ccc']]:stroke-border/50 [&_.recharts-curve.recharts-tooltip-cursor]:stroke-border [&_.recharts-dot[stroke='#fff']]:stroke-transparent [&_.recharts-layer]:outline-none [&_.recharts-polar-grid_[stroke='#ccc']]:stroke-border [&_.recharts-radial-bar-background-sector]:fill-muted [&_.recharts-rectangle.recharts-tooltip-cursor]:fill-muted [&_.recharts-reference-line_[stroke='#ccc']]:stroke-border [&_.recharts-sector[stroke='#fff']]:stroke-transparent [&_.recharts-sector]:outline-none [&_.recharts-surface]:outline-none\",\n          className\n        )}\n        {...props}\n      >\n        <ChartStyle id={chartId} config={config} />\n        <RechartsPrimitive.ResponsiveContainer>\n          {children}\n        </RechartsPrimitive.ResponsiveContainer>\n      </div>\n    </ChartContext.Provider>\n  )\n})\nChartContainer.displayName = \"Chart\"\n\nconst ChartStyle = ({ id, config }: { id: string; config: ChartConfig }) => {\n  const colorConfig = Object.entries(config).filter(\n    ([, config]) => config.theme || config.color\n  )\n\n  if (!colorConfig.length) {\n    return null\n  }\n\n  return (\n    <style\n      dangerouslySetInnerHTML={{\n        __html: Object.entries(THEMES)\n          .map(\n            ([theme, prefix]) => `\n${prefix} [data-chart=${id}] {\n${colorConfig\n  .map(([key, itemConfig]) => {\n    const color =\n      itemConfig.theme?.[theme as keyof typeof itemConfig.theme] ||\n      itemConfig.color\n    return color ? `  --color-${key}: ${color};` : null\n  })\n  .join(\"\\n\")}\n}\n`\n          )\n          .join(\"\\n\"),\n      }}\n    />\n  )\n}\n\nconst ChartTooltip = RechartsPrimitive.Tooltip\n\nconst ChartTooltipContent = React.forwardRef<\n  HTMLDivElement,\n  React.ComponentProps<typeof RechartsPrimitive.Tooltip> &\n    React.ComponentProps<\"div\"> & {\n      hideLabel?: boolean\n      hideIndicator?: boolean\n      indicator?: \"line\" | \"dot\" | \"dashed\"\n      nameKey?: string\n      labelKey?: string\n    }\n>(\n  (\n    {\n      active,\n      payload,\n      className,\n      indicator = \"dot\",\n      hideLabel = false,\n      hideIndicator = false,\n      label,\n      labelFormatter,\n      labelClassName,\n      formatter,\n      color,\n      nameKey,\n      labelKey,\n    },\n    ref\n  ) => {\n    const { config } = useChart()\n\n    const tooltipLabel = React.useMemo(() => {\n      if (hideLabel || !payload?.length) {\n        return null\n      }\n\n      const [item] = payload\n      const key = `${labelKey || item?.dataKey || item?.name || \"value\"}`\n      const itemConfig = getPayloadConfigFromPayload(config, item, key)\n      const value =\n        !labelKey && typeof label === \"string\"\n          ? config[label as keyof typeof config]?.label || label\n          : itemConfig?.label\n\n      if (labelFormatter) {\n        return (\n          <div className={cn(\"font-medium\", labelClassName)}>\n            {labelFormatter(value, payload)}\n          </div>\n        )\n      }\n\n      if (!value) {\n        return null\n      }\n\n      return <div className={cn(\"font-medium\", labelClassName)}>{value}</div>\n    }, [\n      label,\n      labelFormatter,\n      payload,\n      hideLabel,\n      labelClassName,\n      config,\n      labelKey,\n    ])\n\n    if (!active || !payload?.length) {\n      return null\n    }\n\n    const nestLabel = payload.length === 1 && indicator !== \"dot\"\n\n    return (\n      <div\n        ref={ref}\n        className={cn(\n          \"grid min-w-[8rem] items-start gap-1.5 rounded-lg border border-border/50 bg-background px-2.5 py-1.5 text-xs shadow-xl\",\n          className\n        )}\n      >\n        {!nestLabel ? tooltipLabel : null}\n        <div className=\"grid gap-1.5\">\n          {payload.map((item, index) => {\n            const key = `${nameKey || item.name || item.dataKey || \"value\"}`\n            const itemConfig = getPayloadConfigFromPayload(config, item, key)\n            const indicatorColor = color || item.payload.fill || item.color\n\n            return (\n              <div\n                key={item.dataKey}\n                className={cn(\n                  \"flex w-full flex-wrap items-stretch gap-2 [&>svg]:h-2.5 [&>svg]:w-2.5 [&>svg]:text-muted-foreground\",\n                  indicator === \"dot\" && \"items-center\"\n                )}\n              >\n                {formatter && item?.value !== undefined && item.name ? (\n                  formatter(item.value, item.name, item, index, item.payload)\n                ) : (\n                  <>\n                    {itemConfig?.icon ? (\n                      <itemConfig.icon />\n                    ) : (\n                      !hideIndicator && (\n                        <div\n                          className={cn(\n                            \"shrink-0 rounded-[2px] border-[--color-border] bg-[--color-bg]\",\n                            {\n                              \"h-2.5 w-2.5\": indicator === \"dot\",\n                              \"w-1\": indicator === \"line\",\n                              \"w-0 border-[1.5px] border-dashed bg-transparent\":\n                                indicator === \"dashed\",\n                              \"my-0.5\": nestLabel && indicator === \"dashed\",\n                            }\n                          )}\n                          style={\n                            {\n                              \"--color-bg\": indicatorColor,\n                              \"--color-border\": indicatorColor,\n                            } as React.CSSProperties\n                          }\n                        />\n                      )\n                    )}\n                    <div\n                      className={cn(\n                        \"flex flex-1 justify-between leading-none\",\n                        nestLabel ? \"items-end\" : \"items-center\"\n                      )}\n                    >\n                      <div className=\"grid gap-1.5\">\n                        {nestLabel ? tooltipLabel : null}\n                        <span className=\"text-muted-foreground\">\n                          {itemConfig?.label || item.name}\n                        </span>\n                      </div>\n                      {item.value && (\n                        <span className=\"font-mono font-medium tabular-nums text-foreground\">\n                          {item.value.toLocaleString()}\n                        </span>\n                      )}\n                    </div>\n                  </>\n                )}\n              </div>\n            )\n          })}\n        </div>\n      </div>\n    )\n  }\n)\nChartTooltipContent.displayName = \"ChartTooltip\"\n\nconst ChartLegend = RechartsPrimitive.Legend\n\nconst ChartLegendContent = React.forwardRef<\n  HTMLDivElement,\n  React.ComponentProps<\"div\"> &\n    Pick<RechartsPrimitive.LegendProps, \"payload\" | \"verticalAlign\"> & {\n      hideIcon?: boolean\n      nameKey?: string\n    }\n>(\n  (\n    { className, hideIcon = false, payload, verticalAlign = \"bottom\", nameKey },\n    ref\n  ) => {\n    const { config } = useChart()\n\n    if (!payload?.length) {\n      return null\n    }\n\n    return (\n      <div\n        ref={ref}\n        className={cn(\n          \"flex items-center justify-center gap-4\",\n          verticalAlign === \"top\" ? \"pb-3\" : \"pt-3\",\n          className\n        )}\n      >\n        {payload.map((item) => {\n          const key = `${nameKey || item.dataKey || \"value\"}`\n          const itemConfig = getPayloadConfigFromPayload(config, item, key)\n\n          return (\n            <div\n              key={item.value}\n              className={cn(\n                \"flex items-center gap-1.5 [&>svg]:h-3 [&>svg]:w-3 [&>svg]:text-muted-foreground\"\n              )}\n            >\n              {itemConfig?.icon && !hideIcon ? (\n                <itemConfig.icon />\n              ) : (\n                <div\n                  className=\"h-2 w-2 shrink-0 rounded-[2px]\"\n                  style={{\n                    backgroundColor: item.color,\n                  }}\n                />\n              )}\n              {itemConfig?.label}\n            </div>\n          )\n        })}\n      </div>\n    )\n  }\n)\nChartLegendContent.displayName = \"ChartLegend\"\n\n// Helper to extract item config from a payload.\nfunction getPayloadConfigFromPayload(\n  config: ChartConfig,\n  payload: unknown,\n  key: string\n) {\n  if (typeof payload !== \"object\" || payload === null) {\n    return undefined\n  }\n\n  const payloadPayload =\n    \"payload\" in payload &&\n    typeof payload.payload === \"object\" &&\n    payload.payload !== null\n      ? payload.payload\n      : undefined\n\n  let configLabelKey: string = key\n\n  if (\n    key in payload &&\n    typeof payload[key as keyof typeof payload] === \"string\"\n  ) {\n    configLabelKey = payload[key as keyof typeof payload] as string\n  } else if (\n    payloadPayload &&\n    key in payloadPayload &&\n    typeof payloadPayload[key as keyof typeof payloadPayload] === \"string\"\n  ) {\n    configLabelKey = payloadPayload[\n      key as keyof typeof payloadPayload\n    ] as string\n  }\n\n  return configLabelKey in config\n    ? config[configLabelKey]\n    : config[key as keyof typeof config]\n}\n\nexport {\n  ChartContainer,\n  ChartTooltip,\n  ChartTooltipContent,\n  ChartLegend,\n  ChartLegendContent,\n  ChartStyle,\n}\n","path":null,"size_bytes":10481,"size_tokens":null},"client/src/pages/dapps.tsx":{"content":"import { useState, useRef } from \"react\";\nimport { ExternalLink, Globe, Wallet, ChevronRight, RefreshCw, X } from \"lucide-react\";\nimport { BackButton } from \"@/components/back-button\";\nimport { Card, CardContent } from \"@/components/ui/card\";\nimport { Button } from \"@/components/ui/button\";\nimport { Input } from \"@/components/ui/input\";\nimport {\n  Dialog,\n  DialogContent,\n  DialogDescription,\n  DialogFooter,\n  DialogHeader,\n  DialogTitle,\n} from \"@/components/ui/dialog\";\nimport {\n  DropdownMenu,\n  DropdownMenuContent,\n  DropdownMenuItem,\n  DropdownMenuTrigger,\n} from \"@/components/ui/dropdown-menu\";\nimport { useToast } from \"@/hooks/use-toast\";\nimport { useWallet } from \"@/lib/wallet-context\";\nimport { HardwareStatusCard } from \"@/components/hardware-status\";\nimport { ChainIcon } from \"@/components/chain-icon\";\nimport { DEFAULT_CHAINS } from \"@shared/schema\";\n\nconst EVM_CHAINS = DEFAULT_CHAINS.filter(c => c.chainId > 0);\n\ninterface DAppInfo {\n  name: string;\n  url: string;\n  description: string;\n  category: string;\n}\n\nconst POPULAR_DAPPS: DAppInfo[] = [\n  { name: \"PancakeSwap\", url: \"https://pancakeswap.finance/\", description: \"Trade, earn crypto\", category: \"DEX\" },\n  { name: \"Uniswap\", url: \"https://app.uniswap.org/\", description: \"Swap tokens\", category: \"DEX\" },\n  { name: \"Aave\", url: \"https://app.aave.com/\", description: \"Lending protocol\", category: \"Lending\" },\n  { name: \"1inch\", url: \"https://app.1inch.io/\", description: \"DEX aggregator\", category: \"DEX\" },\n];\n\nexport default function DApps() {\n  const { isConnected, isUnlocked, wallets, chains } = useWallet();\n  const { toast } = useToast();\n  \n  const [url, setUrl] = useState(\"\");\n  const [currentUrl, setCurrentUrl] = useState(\"\");\n  const [isLoading, setIsLoading] = useState(false);\n  const [iframeError, setIframeError] = useState(false);\n  const [selectedChainId, setSelectedChainId] = useState<number>(56); // BNB Chain default\n  const [showWalletSelector, setShowWalletSelector] = useState(false);\n  const [connectedWallet, setConnectedWallet] = useState<string | null>(null);\n  const iframeRef = useRef<HTMLIFrameElement>(null);\n\n  const selectedChain = EVM_CHAINS.find(c => c.chainId === selectedChainId) || EVM_CHAINS[0];\n\n  // Get wallets for current chain\n  const chainWallets = wallets.filter(w => {\n    const chain = chains.find(c => c.id === w.chainId);\n    return chain && chain.chainId === selectedChainId;\n  });\n\n  // All EVM wallets\n  const evmWallets = wallets.filter(w => {\n    const chain = chains.find(c => c.id === w.chainId);\n    return chain && chain.chainId > 0;\n  });\n\n  const handleNavigate = () => {\n    if (!url.trim()) return;\n    let formattedUrl = url.trim();\n    if (!formattedUrl.startsWith(\"http://\") && !formattedUrl.startsWith(\"https://\")) {\n      formattedUrl = \"https://\" + formattedUrl;\n    }\n    setCurrentUrl(formattedUrl);\n    setUrl(formattedUrl);\n    setIframeError(false);\n    setIsLoading(true);\n  };\n\n  const handleOpenDapp = (dappUrl: string) => {\n    setUrl(dappUrl);\n    setCurrentUrl(dappUrl);\n    setIframeError(false);\n    setIsLoading(true);\n  };\n\n  const handleIframeLoad = () => {\n    setIsLoading(false);\n  };\n\n  const handleIframeError = () => {\n    setIsLoading(false);\n    setIframeError(true);\n  };\n\n  const handleChainSwitch = (chainId: number) => {\n    setSelectedChainId(chainId);\n    setConnectedWallet(null);\n    toast({\n      title: \"Chain Switched\",\n      description: `Switched to ${EVM_CHAINS.find(c => c.chainId === chainId)?.name}`,\n      duration: 2000,\n    });\n  };\n\n  const handleConnectWallet = () => {\n    setShowWalletSelector(true);\n  };\n\n  const handleWalletSelect = (walletAddress: string, chainName: string) => {\n    setConnectedWallet(walletAddress);\n    navigator.clipboard.writeText(walletAddress);\n    \n    toast({\n      title: \"Wallet Connected\",\n      description: `${chainName} wallet connected. Address copied.`,\n      duration: 2000,\n    });\n    \n    setShowWalletSelector(false);\n  };\n\n  if (!isConnected || !isUnlocked) {\n    return (\n      <div className=\"p-6\">\n        <h1 className=\"mb-6 text-3xl font-bold\">DApps</h1>\n        <HardwareStatusCard />\n      </div>\n    );\n  }\n\n  return (\n    <div className=\"flex flex-col h-full\">\n      {/* Header with URL bar */}\n      <div className=\"border-b bg-background/95 backdrop-blur supports-[backdrop-filter]:bg-background/60\">\n        <div className=\"flex items-center gap-1.5 p-2\">\n          <BackButton />\n\n          <div className=\"flex-1 flex items-center gap-1.5 bg-muted/50 rounded-lg px-2 py-1\">\n            <Input\n              value={url}\n              onChange={(e) => setUrl(e.target.value)}\n              onKeyDown={(e) => e.key === \"Enter\" && handleNavigate()}\n              placeholder=\"Enter URL...\"\n              className=\"flex-1 border-0 bg-transparent h-8 text-sm focus-visible:ring-0 px-1\"\n              data-testid=\"input-browser-url\"\n            />\n            <Button size=\"sm\" onClick={handleNavigate} className=\"h-7 px-3\" data-testid=\"button-go\">\n              Go\n            </Button>\n          </div>\n\n          <DropdownMenu>\n            <DropdownMenuTrigger asChild>\n              <Button variant=\"outline\" size=\"icon\" data-testid=\"button-chain-selector\">\n                <ChainIcon symbol={selectedChain.symbol} iconColor={selectedChain.iconColor} size=\"sm\" />\n              </Button>\n            </DropdownMenuTrigger>\n            <DropdownMenuContent align=\"end\" className=\"w-48\">\n              {EVM_CHAINS.map((chain) => (\n                <DropdownMenuItem\n                  key={chain.chainId}\n                  onClick={() => handleChainSwitch(chain.chainId)}\n                  className=\"gap-2\"\n                  data-testid={`menu-chain-${chain.symbol.toLowerCase()}`}\n                >\n                  <ChainIcon symbol={chain.symbol} iconColor={chain.iconColor} size=\"sm\" />\n                  {chain.name}\n                  {chain.chainId === selectedChainId && (\n                    <span className=\"ml-auto text-primary\">•</span>\n                  )}\n                </DropdownMenuItem>\n              ))}\n            </DropdownMenuContent>\n          </DropdownMenu>\n\n          <Button\n            variant={connectedWallet ? \"default\" : \"outline\"}\n            size=\"icon\"\n            onClick={handleConnectWallet}\n            data-testid=\"button-connect-wallet\"\n          >\n            <Wallet className=\"h-4 w-4\" />\n          </Button>\n        </div>\n\n        {/* Connected wallet indicator below URL */}\n        <div \n          className=\"mx-2 mb-2 px-3 py-1.5 rounded-md bg-muted/50 text-xs flex items-center gap-2 cursor-pointer hover-elevate\"\n          onClick={handleConnectWallet}\n          data-testid=\"wallet-indicator\"\n        >\n          <ChainIcon symbol={selectedChain.symbol} iconColor={selectedChain.iconColor} size=\"sm\" />\n          {connectedWallet ? (\n            <>\n              <span className=\"w-2 h-2 rounded-full bg-green-500\" />\n              <span className=\"font-mono\">{connectedWallet.slice(0, 10)}...{connectedWallet.slice(-6)}</span>\n            </>\n          ) : (\n            <span className=\"text-muted-foreground\">Tap to select wallet</span>\n          )}\n        </div>\n      </div>\n\n      {/* Browser content */}\n      <div className=\"flex-1 relative bg-muted/30\">\n        {!currentUrl ? (\n          <div className=\"absolute inset-0 flex items-center justify-center\">\n            <div className=\"text-center max-w-md p-6\">\n              <Globe className=\"mx-auto h-16 w-16 text-muted-foreground/30 mb-4\" />\n              <h2 className=\"text-xl font-semibold mb-2\">DApp Browser</h2>\n              <p className=\"text-muted-foreground mb-6\">\n                Enter a URL or select a popular DApp below\n              </p>\n\n              <div className=\"grid grid-cols-2 gap-2\">\n                {POPULAR_DAPPS.map((dapp) => (\n                  <Button\n                    key={dapp.name}\n                    variant=\"outline\"\n                    size=\"sm\"\n                    onClick={() => handleOpenDapp(dapp.url)}\n                    className=\"justify-start\"\n                    data-testid={`quick-${dapp.name.toLowerCase()}`}\n                  >\n                    {dapp.name}\n                  </Button>\n                ))}\n              </div>\n            </div>\n          </div>\n        ) : iframeError ? (\n          <div className=\"absolute inset-0 flex items-center justify-center\">\n            <div className=\"text-center max-w-md p-6\">\n              <X className=\"mx-auto h-16 w-16 text-destructive/50 mb-4\" />\n              <h2 className=\"text-xl font-semibold mb-2\">Cannot Load DApp</h2>\n              <p className=\"text-muted-foreground mb-4\">\n                This DApp cannot be embedded. Try opening in external browser.\n              </p>\n              <div className=\"flex gap-2 justify-center\">\n                <Button variant=\"outline\" onClick={() => window.open(currentUrl, \"_blank\")}>\n                  <ExternalLink className=\"mr-2 h-4 w-4\" />\n                  Open External\n                </Button>\n                <Button variant=\"outline\" onClick={() => { setCurrentUrl(\"\"); setUrl(\"\"); }}>\n                  Back\n                </Button>\n              </div>\n            </div>\n          </div>\n        ) : (\n          <>\n            {isLoading && (\n              <div className=\"absolute inset-0 flex items-center justify-center bg-background/80 z-10\">\n                <RefreshCw className=\"h-8 w-8 animate-spin text-muted-foreground\" />\n              </div>\n            )}\n            <iframe\n              ref={iframeRef}\n              src={currentUrl}\n              className=\"w-full h-full border-0\"\n              onLoad={handleIframeLoad}\n              onError={handleIframeError}\n              sandbox=\"allow-scripts allow-same-origin allow-forms allow-popups allow-popups-to-escape-sandbox\"\n              data-testid=\"iframe-dapp\"\n            />\n          </>\n        )}\n      </div>\n\n      {/* Wallet Selection Dialog */}\n      <Dialog open={showWalletSelector} onOpenChange={setShowWalletSelector}>\n        <DialogContent className=\"max-w-sm\">\n          <DialogHeader>\n            <DialogTitle className=\"flex items-center gap-2\">\n              <Wallet className=\"h-5 w-5\" />\n              Select Wallet\n            </DialogTitle>\n            <DialogDescription>\n              Choose a wallet to connect\n            </DialogDescription>\n          </DialogHeader>\n          \n          <div className=\"space-y-2 max-h-64 overflow-auto\">\n            {chainWallets.length > 0 ? (\n              chainWallets.map((wallet, index) => {\n                const chain = chains.find(c => c.id === wallet.chainId);\n                if (!chain) return null;\n                \n                const walletName = wallet.label || `${chain.name} Wallet${chainWallets.length > 1 ? ` ${index + 1}` : ''}`;\n                \n                return (\n                  <Button\n                    key={wallet.id}\n                    variant={wallet.address === connectedWallet ? \"default\" : \"outline\"}\n                    className=\"w-full justify-start gap-3 h-auto py-3\"\n                    onClick={() => handleWalletSelect(wallet.address, walletName)}\n                    data-testid={`select-wallet-${chain.symbol.toLowerCase()}`}\n                  >\n                    <ChainIcon symbol={chain.symbol} iconColor={chain.iconColor} size=\"sm\" />\n                    <div className=\"flex-1 text-left\">\n                      <div className=\"font-medium\">{walletName}</div>\n                      <div className=\"text-xs text-muted-foreground font-mono\">\n                        {wallet.address.slice(0, 8)}...{wallet.address.slice(-6)}\n                      </div>\n                    </div>\n                    {wallet.address === connectedWallet && (\n                      <span className=\"text-xs\">Connected</span>\n                    )}\n                  </Button>\n                );\n              })\n            ) : (\n              <p className=\"text-center text-muted-foreground py-4\">\n                No wallets for {selectedChain.name}\n              </p>\n            )}\n          </div>\n\n          <DialogFooter>\n            <Button variant=\"ghost\" onClick={() => setShowWalletSelector(false)} className=\"w-full\">\n              Cancel\n            </Button>\n          </DialogFooter>\n        </DialogContent>\n      </Dialog>\n    </div>\n  );\n}\n","path":null,"size_bytes":12372,"size_tokens":null},"client/src/components/seed-verification-modal.tsx":{"content":"import { useState, useCallback } from \"react\";\nimport { Shield, AlertTriangle, Loader2, Edit2 } from \"lucide-react\";\nimport {\n  Dialog,\n  DialogContent,\n  DialogDescription,\n  DialogHeader,\n  DialogTitle,\n  DialogFooter,\n} from \"@/components/ui/dialog\";\nimport { Button } from \"@/components/ui/button\";\nimport { Input } from \"@/components/ui/input\";\nimport { Label } from \"@/components/ui/label\";\nimport { Textarea } from \"@/components/ui/textarea\";\nimport { useWallet } from \"@/lib/wallet-context\";\nimport { useToast } from \"@/hooks/use-toast\";\n\ninterface SeedVerificationModalProps {\n  open: boolean;\n  onOpenChange: (open: boolean) => void;\n}\n\nexport function SeedVerificationModal({ open, onOpenChange }: SeedVerificationModalProps) {\n  const { \n    pendingAddChain, \n    verifySeedForAddChain, \n    confirmAddChain, \n    abortAddChain,\n    getSeedWordCount,\n  } = useWallet();\n  const { toast } = useToast();\n  \n  const [seedPhrase, setSeedPhrase] = useState(\"\");\n  const [customLabel, setCustomLabel] = useState(\"\");\n  const [isVerifying, setIsVerifying] = useState(false);\n  const [attempts, setAttempts] = useState(0);\n  const [error, setError] = useState(\"\");\n\n  const wordCount = getSeedWordCount();\n  const expectedWords = wordCount || 12;\n\n  const handleClose = useCallback(() => {\n    setSeedPhrase(\"\");\n    setCustomLabel(\"\");\n    setError(\"\");\n    setAttempts(0);\n    abortAddChain();\n    onOpenChange(false);\n  }, [abortAddChain, onOpenChange]);\n\n  const handleVerify = async () => {\n    if (!seedPhrase.trim()) {\n      setError(\"Please enter your recovery phrase\");\n      return;\n    }\n\n    const inputWords = seedPhrase.trim().split(/\\s+/);\n    if (inputWords.length !== expectedWords) {\n      setError(`Please enter all ${expectedWords} words of your recovery phrase`);\n      return;\n    }\n\n    setIsVerifying(true);\n    setError(\"\");\n\n    try {\n      const isValid = await verifySeedForAddChain(seedPhrase);\n      \n      if (isValid) {\n        const success = await confirmAddChain(customLabel.trim() || undefined);\n        if (success) {\n          toast({\n            title: \"Network Added\",\n            description: `${pendingAddChain?.chainName || \"Network\"} wallet has been created.`,\n          });\n          setSeedPhrase(\"\");\n          setCustomLabel(\"\");\n          setAttempts(0);\n          onOpenChange(false);\n        } else {\n          setError(\"Failed to create wallet. Please try again.\");\n        }\n      } else {\n        const newAttempts = attempts + 1;\n        setAttempts(newAttempts);\n        \n        if (newAttempts >= 3) {\n          setError(\"Too many failed attempts. Please close and try again later.\");\n        } else {\n          setError(`Incorrect recovery phrase. ${3 - newAttempts} attempts remaining.`);\n        }\n      }\n    } catch (err) {\n      setError(\"Verification failed. Please try again.\");\n    } finally {\n      setIsVerifying(false);\n    }\n  };\n\n  if (!pendingAddChain) {\n    return null;\n  }\n\n  return (\n    <Dialog open={open} onOpenChange={(isOpen) => {\n      if (!isOpen) {\n        handleClose();\n      }\n    }}>\n      <DialogContent className=\"sm:max-w-md\">\n        <DialogHeader>\n          <DialogTitle className=\"flex items-center gap-2\">\n            <Shield className=\"h-5 w-5 text-primary\" />\n            Security Verification\n          </DialogTitle>\n          <DialogDescription>\n            To add {pendingAddChain.chainName} to your wallet, please verify ownership by entering your recovery phrase.\n          </DialogDescription>\n        </DialogHeader>\n        \n        <div className=\"space-y-4 py-4\">\n          <div className=\"flex items-start gap-2 rounded-md border border-amber-200 bg-amber-50 p-3 dark:border-amber-900 dark:bg-amber-950/30\">\n            <AlertTriangle className=\"mt-0.5 h-4 w-4 shrink-0 text-amber-600 dark:text-amber-400\" />\n            <p className=\"text-sm text-amber-800 dark:text-amber-200\">\n              This security check ensures only you can add new networks to your wallet. Your recovery phrase is never stored or transmitted.\n            </p>\n          </div>\n\n          <div className=\"space-y-2\">\n            <Label htmlFor=\"seed-phrase\">\n              Recovery Phrase ({expectedWords} words)\n            </Label>\n            <Textarea\n              id=\"seed-phrase\"\n              placeholder={`Enter your ${expectedWords}-word recovery phrase...`}\n              value={seedPhrase}\n              onChange={(e) => {\n                setSeedPhrase(e.target.value);\n                setError(\"\");\n              }}\n              className=\"min-h-[100px] font-mono text-sm\"\n              disabled={isVerifying || attempts >= 3}\n              data-testid=\"input-seed-verification\"\n            />\n          </div>\n\n          <div className=\"space-y-2\">\n            <Label htmlFor=\"wallet-label\" className=\"flex items-center gap-1\">\n              <Edit2 className=\"h-3 w-3\" />\n              Wallet Name (Optional)\n            </Label>\n            <Input\n              id=\"wallet-label\"\n              placeholder={pendingAddChain.chainName}\n              value={customLabel}\n              onChange={(e) => setCustomLabel(e.target.value)}\n              disabled={isVerifying || attempts >= 3}\n              data-testid=\"input-wallet-label\"\n            />\n            <p className=\"text-xs text-muted-foreground\">\n              Give this wallet a custom name to easily identify it\n            </p>\n          </div>\n\n          {error && (\n            <div className=\"flex items-center gap-2 text-sm text-destructive\">\n              <AlertTriangle className=\"h-4 w-4\" />\n              {error}\n            </div>\n          )}\n        </div>\n\n        <DialogFooter className=\"gap-2 sm:gap-0\">\n          <Button variant=\"outline\" onClick={handleClose} disabled={isVerifying}>\n            Cancel\n          </Button>\n          <Button \n            onClick={handleVerify} \n            disabled={isVerifying || attempts >= 3 || !seedPhrase.trim()}\n            data-testid=\"button-verify-seed\"\n          >\n            {isVerifying ? (\n              <>\n                <Loader2 className=\"mr-2 h-4 w-4 animate-spin\" />\n                Verifying...\n              </>\n            ) : (\n              \"Verify & Add Network\"\n            )}\n          </Button>\n        </DialogFooter>\n      </DialogContent>\n    </Dialog>\n  );\n}\n","path":null,"size_bytes":6311,"size_tokens":null},"client/src/components/ui/progress.tsx":{"content":"\"use client\"\n\nimport * as React from \"react\"\nimport * as ProgressPrimitive from \"@radix-ui/react-progress\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst Progress = React.forwardRef<\n  React.ElementRef<typeof ProgressPrimitive.Root>,\n  React.ComponentPropsWithoutRef<typeof ProgressPrimitive.Root>\n>(({ className, value, ...props }, ref) => (\n  <ProgressPrimitive.Root\n    ref={ref}\n    className={cn(\n      \"relative h-4 w-full overflow-hidden rounded-full bg-secondary\",\n      className\n    )}\n    {...props}\n  >\n    <ProgressPrimitive.Indicator\n      className=\"h-full w-full flex-1 bg-primary transition-all\"\n      style={{ transform: `translateX(-${100 - (value || 0)}%)` }}\n    />\n  </ProgressPrimitive.Root>\n))\nProgress.displayName = ProgressPrimitive.Root.displayName\n\nexport { Progress }\n","path":null,"size_bytes":791,"size_tokens":null},"client/src/pages/dashboard.tsx":{"content":"import { useState, useEffect, useMemo } from \"react\";\nimport { \n  ArrowUpRight, \n  ArrowDownLeft, \n  Copy, \n  ExternalLink,\n  RefreshCw,\n  Settings,\n  Wallet,\n  Search,\n  Plus,\n  ChevronLeft,\n  ChevronRight,\n  Check,\n} from \"lucide-react\";\nimport { Card, CardContent } from \"@/components/ui/card\";\nimport { Button } from \"@/components/ui/button\";\nimport { Skeleton } from \"@/components/ui/skeleton\";\nimport { Input } from \"@/components/ui/input\";\nimport { Badge } from \"@/components/ui/badge\";\nimport {\n  Dialog,\n  DialogContent,\n  DialogDescription,\n  DialogFooter,\n  DialogHeader,\n  DialogTitle,\n  DialogTrigger,\n} from \"@/components/ui/dialog\";\nimport { Label } from \"@/components/ui/label\";\nimport {\n  Select,\n  SelectContent,\n  SelectItem,\n  SelectTrigger,\n  SelectValue,\n} from \"@/components/ui/select\";\nimport { RadioGroup, RadioGroupItem } from \"@/components/ui/radio-group\";\nimport { Checkbox } from \"@/components/ui/checkbox\";\nimport { useWallet } from \"@/lib/wallet-context\";\nimport { useToast } from \"@/hooks/use-toast\";\nimport { ChainIcon } from \"@/components/chain-icon\";\nimport { HardwareStatusCard, WalletModeSelector } from \"@/components/hardware-status\";\nimport { fetchPrices, formatUSD, calculateUSDValue, formatCryptoBalance, type PriceData } from \"@/lib/price-service\";\nimport type { Chain, Wallet as WalletType } from \"@shared/schema\";\nimport type { TopAsset } from \"@/lib/price-service\";\nimport { Link, useLocation, useSearch } from \"wouter\";\nimport { isTokenAsset } from \"@/lib/blockchain\";\nimport { clientStorage, type CustomToken } from \"@/lib/client-storage\";\nimport { COINGECKO_ID_TO_CHAIN_SYMBOL, TOKEN_PARENT_CHAIN_SYMBOL, TOKEN_PARENT_CHAIN } from \"@/lib/chain-mappings\";\nimport { FALLBACK_TOP_ASSETS } from \"@shared/schema\";\n\nconst formatBalance = formatCryptoBalance;\n\nfunction truncateAddress(address: string): string {\n  if (!address) return \"\";\n  return `${address.slice(0, 6)}...${address.slice(-4)}`;\n}\n\nconst JSDELIVR_CDN = 'https://cdn.jsdelivr.net/npm/cryptocurrency-icons@0.16.1/128/color';\nconst COINGECKO_CDN = 'https://assets.coingecko.com/coins/images';\n\nconst CRYPTO_ICONS: Record<string, string> = {\n  'bitcoin': `${JSDELIVR_CDN}/btc.png`,\n  'ethereum': `${JSDELIVR_CDN}/eth.png`,\n  'tether': `${JSDELIVR_CDN}/usdt.png`,\n  'binancecoin': `${JSDELIVR_CDN}/bnb.png`,\n  'solana': `${COINGECKO_CDN}/4128/small/solana.png`,\n  'usd-coin': `${JSDELIVR_CDN}/usdc.png`,\n  'ripple': `${JSDELIVR_CDN}/xrp.png`,\n  'staked-ether': `${COINGECKO_CDN}/13442/small/steth_logo.png`,\n  'dogecoin': `${JSDELIVR_CDN}/doge.png`,\n  'cardano': `${JSDELIVR_CDN}/ada.png`,\n  'tron': `${JSDELIVR_CDN}/trx.png`,\n  'avalanche-2': `${COINGECKO_CDN}/12559/small/Avalanche_Circle_RedWhite_Trans.png`,\n  'shiba-inu': `${COINGECKO_CDN}/11939/small/shiba.png`,\n  'chainlink': `${COINGECKO_CDN}/877/small/chainlink-new-logo.png`,\n  'wrapped-bitcoin': `${COINGECKO_CDN}/7598/small/wrapped_bitcoin_wbtc.png`,\n  'polkadot': `${COINGECKO_CDN}/12171/small/polkadot.png`,\n  'bitcoin-cash': `${JSDELIVR_CDN}/bch.png`,\n  'matic-network': `${JSDELIVR_CDN}/matic.png`,\n  'litecoin': `${JSDELIVR_CDN}/ltc.png`,\n  'uniswap': `${COINGECKO_CDN}/12504/small/uniswap.png`,\n  'cosmos': `${JSDELIVR_CDN}/atom.png`,\n  'osmosis': `${COINGECKO_CDN}/16724/small/osmo.png`,\n};\n\n// Direct symbol-to-logo mapping for custom tokens (using Trust Wallet CDN which is more reliable)\nconst CUSTOM_TOKEN_LOGOS: Record<string, string> = {\n  'CAKE': 'https://assets-cdn.trustwallet.com/blockchains/smartchain/assets/0x0E09FaBB73Bd3Ade0a17ECC321fD13a19e81cE82/logo.png',\n  'TWT': 'https://assets-cdn.trustwallet.com/blockchains/smartchain/assets/0x4B0F1812e5Df2A09796481Ff14017e6005508003/logo.png',\n  'BABY': 'https://assets-cdn.trustwallet.com/blockchains/smartchain/assets/0xc748673057861a797275CD8A068AbB95A902e8de/logo.png',\n  'XVS': 'https://assets-cdn.trustwallet.com/blockchains/smartchain/assets/0xcF6BB5389c92Bdda8a3747Ddb454cB7a64626C63/logo.png',\n  'USDT': `${JSDELIVR_CDN}/usdt.png`,\n  'USDC': `${JSDELIVR_CDN}/usdc.png`,\n  'BTC': `${JSDELIVR_CDN}/btc.png`,\n  'ETH': `${JSDELIVR_CDN}/eth.png`,\n  'BNB': `${JSDELIVR_CDN}/bnb.png`,\n  'SOL': 'https://assets-cdn.trustwallet.com/blockchains/solana/info/logo.png',\n  'DOGE': `${JSDELIVR_CDN}/doge.png`,\n};\n\n// Map chain-specific token IDs to base token IDs for icon lookup\n// e.g., 'tether-bsc' -> 'tether', 'usd-coin-ethereum' -> 'usd-coin'\nconst TOKEN_BASE_ID: Record<string, string> = {\n  'tether-bsc': 'tether',\n  'tether-tron': 'tether',\n  'tether-ethereum': 'tether',\n  'usd-coin-bsc': 'usd-coin',\n  'usd-coin-ethereum': 'usd-coin',\n  'usd-coin-solana': 'usd-coin',\n  'staked-ether-ethereum': 'staked-ether',\n};\n\nfunction getAssetIcon(assetId: string, assetImage?: string): string | undefined {\n  // Check direct image first (must be non-empty)\n  if (assetImage && assetImage.trim()) {\n    return assetImage;\n  }\n  \n  // Check CRYPTO_ICONS by asset ID\n  if (CRYPTO_ICONS[assetId]) {\n    return CRYPTO_ICONS[assetId];\n  }\n  \n  // Check TOKEN_BASE_ID mapping\n  const baseId = TOKEN_BASE_ID[assetId];\n  if (baseId && CRYPTO_ICONS[baseId]) {\n    return CRYPTO_ICONS[baseId];\n  }\n  \n  // Check FALLBACK_TOP_ASSETS by asset ID\n  const matchingAsset = FALLBACK_TOP_ASSETS.find(a => a.id === assetId);\n  if (matchingAsset?.image && matchingAsset.image.trim()) {\n    return matchingAsset.image;\n  }\n  \n  return undefined;\n}\n\nfunction getCustomTokenIcon(token: CustomToken): string | undefined {\n  console.log(`[ICON_DEBUG] Looking for icon for token:`, token.symbol, `stored image:`, token.image);\n  \n  // First check stored image (must be non-empty)\n  if (token.image && typeof token.image === 'string' && token.image.trim()) {\n    console.log(`[ICON_DEBUG] ✓ Found stored image for ${token.symbol}:`, token.image);\n    return token.image;\n  }\n  \n  // Then check direct mapping\n  const symbolUpper = token.symbol.toUpperCase().trim();\n  console.log(`[ICON_DEBUG] Checking CUSTOM_TOKEN_LOGOS for symbol: \"${symbolUpper}\"`);\n  if (CUSTOM_TOKEN_LOGOS[symbolUpper]) {\n    console.log(`[ICON_DEBUG] ✓ Found in CUSTOM_TOKEN_LOGOS for ${symbolUpper}:`, CUSTOM_TOKEN_LOGOS[symbolUpper]);\n    return CUSTOM_TOKEN_LOGOS[symbolUpper];\n  }\n  \n  // Finally check FALLBACK_TOP_ASSETS\n  const matchingAsset = FALLBACK_TOP_ASSETS.find(\n    a => a.symbol.toUpperCase().trim() === symbolUpper\n  );\n  if (matchingAsset?.image && matchingAsset.image.trim()) {\n    console.log(`[ICON_DEBUG] ✓ Found in FALLBACK_TOP_ASSETS for ${symbolUpper}:`, matchingAsset.image);\n    return matchingAsset.image;\n  }\n  \n  console.log(`[ICON_DEBUG] ✗ NO ICON found for symbol: \"${symbolUpper}\"`);\n  return undefined;\n}\n\n// View state for hierarchical navigation: chains -> wallets -> tokens\ntype ViewLevel = 'chains' | 'wallets' | 'tokens';\n\ninterface CombinedAssetCardProps {\n  asset: TopAsset;\n  wallet?: WalletType;\n  chain?: Chain;\n  prices: PriceData;\n  tokenBalance?: string;\n}\n\nfunction CombinedAssetCard({ asset, wallet, chain, prices, tokenBalance }: CombinedAssetCardProps) {\n  const { toast } = useToast();\n  const [, navigate] = useLocation();\n  const hasWallet = wallet && chain;\n  \n  const parentChain = TOKEN_PARENT_CHAIN[asset.id];\n  const isToken = !!parentChain;\n  const displaySymbol = isToken ? asset.symbol.toUpperCase() : chain?.symbol || asset.symbol.toUpperCase();\n  \n  const effectiveBalance = isToken && tokenBalance ? tokenBalance : (hasWallet ? wallet.balance : \"0\");\n  const balance = parseFloat(effectiveBalance);\n  const usdValue = balance * (asset.currentPrice || 0);\n\n  const copyAddress = (e: React.MouseEvent) => {\n    e.preventDefault();\n    e.stopPropagation();\n    if (wallet) {\n      navigator.clipboard.writeText(wallet.address);\n      toast({\n        title: \"Address Copied\",\n        description: \"Wallet address copied to clipboard.\",\n      });\n    }\n  };\n\n  const openExplorer = (e: React.MouseEvent) => {\n    e.preventDefault();\n    e.stopPropagation();\n    if (chain && wallet) {\n      window.open(`${chain.blockExplorer}/address/${wallet.address}`, \"_blank\");\n    }\n  };\n\n  const cardContent = (\n    <Card className=\"hover-elevate cursor-pointer transition-all h-full\" data-testid={`card-asset-${asset.id}`}>\n      <CardContent className=\"p-3 sm:p-4 flex flex-col h-full\">\n        <div className=\"flex items-center justify-between gap-3\">\n          <div className=\"flex items-center gap-3 min-w-0 flex-1\">\n            {getAssetIcon(asset.id, asset.image) ? (\n              <img\n                src={getAssetIcon(asset.id, asset.image)}\n                alt={asset.name}\n                className=\"h-10 w-10 rounded-full bg-muted shrink-0\"\n                onError={(e) => { (e.target as HTMLImageElement).style.display = 'none'; }}\n              />\n            ) : chain ? (\n              <ChainIcon symbol={chain.symbol} iconColor={chain.iconColor} size=\"md\" />\n            ) : (\n              <div className=\"h-10 w-10 rounded-full bg-muted shrink-0\" />\n            )}\n            <div className=\"min-w-0 flex-1\">\n              <div className=\"flex items-center gap-2\">\n                <h3 className=\"font-semibold truncate\">{asset.name}</h3>\n                <span\n                  className={`text-xs font-medium shrink-0 ${\n                    asset.priceChangePercentage24h >= 0\n                      ? \"text-green-600 dark:text-green-400\"\n                      : \"text-red-600 dark:text-red-400\"\n                  }`}\n                >\n                  {asset.priceChangePercentage24h >= 0 ? \"+\" : \"\"}{asset.priceChangePercentage24h.toFixed(1)}%\n                </span>\n              </div>\n              <p className=\"text-sm text-muted-foreground\">\n                {asset.symbol.toUpperCase()}\n                {parentChain && <span className=\"ml-1 opacity-70\">on {parentChain}</span>}\n              </p>\n            </div>\n          </div>\n          <div className=\"text-right shrink-0\">\n            {hasWallet ? (\n              <>\n                <p className=\"font-semibold\" data-testid={`text-value-${asset.id}`}>{formatUSD(usdValue)}</p>\n                <p className=\"text-sm text-muted-foreground\">{formatBalance(effectiveBalance)} {displaySymbol}</p>\n              </>\n            ) : (\n              <p className=\"text-sm text-muted-foreground\">{formatUSD(asset.currentPrice)}</p>\n            )}\n          </div>\n        </div>\n\n        {hasWallet && (\n          <div className=\"mt-3 pt-3 border-t flex items-center justify-between\">\n            <code className=\"text-xs font-mono text-muted-foreground\">\n              {truncateAddress(wallet.address)}\n            </code>\n            <div className=\"flex gap-1\">\n              <Button \n                size=\"icon\" \n                variant=\"ghost\" \n                className=\"h-7 w-7\"\n                onClick={copyAddress}\n                data-testid={`button-copy-${asset.id}`}\n              >\n                <Copy className=\"h-3 w-3\" />\n              </Button>\n              {chain.blockExplorer && (\n                <Button\n                  size=\"icon\"\n                  variant=\"ghost\"\n                  className=\"h-7 w-7\"\n                  onClick={openExplorer}\n                  data-testid={`button-explorer-${asset.id}`}\n                >\n                  <ExternalLink className=\"h-3 w-3\" />\n                </Button>\n              )}\n            </div>\n          </div>\n        )}\n      </CardContent>\n    </Card>\n  );\n\n  if (hasWallet) {\n    // Navigate to token detail if it's a token, otherwise native asset detail\n    const tokenPath = isToken ? `/wallet/${chain.id}/token/${asset.id}` : `/wallet/${chain.id}/token/native`;\n    return (\n      <Link href={tokenPath}>\n        {cardContent}\n      </Link>\n    );\n  }\n\n  return cardContent;\n}\n\nfunction DashboardSkeleton() {\n  return (\n    <div className=\"space-y-6\">\n      <Card>\n        <CardContent className=\"p-6\">\n          <Skeleton className=\"h-8 w-32 mb-2\" />\n          <Skeleton className=\"h-12 w-48\" />\n        </CardContent>\n      </Card>\n      <div className=\"grid gap-4 sm:grid-cols-2 lg:grid-cols-3\">\n        {[1, 2, 3, 4, 5, 6].map((i) => (\n          <Card key={i}>\n            <CardContent className=\"p-4\">\n              <div className=\"flex items-center gap-3\">\n                <Skeleton className=\"h-8 w-8 rounded-full\" />\n                <div>\n                  <Skeleton className=\"h-4 w-20 mb-1\" />\n                  <Skeleton className=\"h-3 w-12\" />\n                </div>\n              </div>\n              <Skeleton className=\"h-4 w-24 mt-4\" />\n              <Skeleton className=\"h-6 w-32 mt-2\" />\n            </CardContent>\n          </Card>\n        ))}\n      </div>\n    </div>\n  );\n}\n\nexport default function Dashboard() {\n  const { isConnected, isUnlocked, chains, wallets, refreshBalances, refreshWalletBalance, topAssets, enabledAssetIds, isLoadingAssets, refreshTopAssets, createAdditionalWallet, createWalletWithNewSeed, walletMode, isLoading, selectedAccountIndex, setSelectedAccountIndex, availableAccounts, visibleWallets, customTokens, balanceCacheStatus, hasSoftWalletSetup, hasHardWalletSetup, tokenBalances, customTokenBalances } = useWallet();\n  const { toast } = useToast();\n  const [, navigate] = useLocation();\n  \n  // Read URL params for restoring navigation state using wouter's useSearch\n  const search = useSearch();\n  const searchParams = new URLSearchParams(search);\n  const chainParam = searchParams.get('chain');\n  const walletParam = searchParams.get('wallet');\n  \n  const [prices, setPrices] = useState<PriceData>({});\n  const [isRefreshing, setIsRefreshing] = useState(false);\n  const [assetSearch, setAssetSearch] = useState(\"\");\n  const [showCreateWalletDialog, setShowCreateWalletDialog] = useState(false);\n  const [newWalletLabel, setNewWalletLabel] = useState(\"\");\n  const [walletCreationType, setWalletCreationType] = useState<\"derive\" | \"new-seed\">(\"derive\");\n  const [seedPinInput, setSeedPinInput] = useState(\"\");\n  const [showSeedRevealDialog, setShowSeedRevealDialog] = useState(false);\n  const [newSeedPhrase, setNewSeedPhrase] = useState(\"\");\n  const [seedConfirmed, setSeedConfirmed] = useState(false);\n  const [showAssets, setShowAssets] = useState(true);\n  \n  // Hierarchical navigation state\n  const [viewLevel, setViewLevel] = useState<ViewLevel>('chains');\n  const [selectedChain, setSelectedChain] = useState<Chain | null>(null);\n  const [selectedWallet, setSelectedWallet] = useState<WalletType | null>(null);\n  \n  // Restore navigation state from URL params\n  useEffect(() => {\n    if (chains.length === 0 || visibleWallets.length === 0) return;\n    \n    if (chainParam) {\n      const chain = chains.find(c => c.id === chainParam);\n      if (chain) {\n        setSelectedChain(chain);\n        if (walletParam) {\n          const wallet = visibleWallets.find(w => w.id === walletParam);\n          if (wallet) {\n            setSelectedWallet(wallet);\n            setViewLevel('tokens');\n          } else {\n            setViewLevel('wallets');\n          }\n        } else {\n          setViewLevel('wallets');\n        }\n      }\n    }\n  }, [chainParam, walletParam, chains, visibleWallets]);\n  \n  // Chain selection view state\n  const [showAllAddedChains, setShowAllAddedChains] = useState(false);\n  const [addingChainId, setAddingChainId] = useState<string | null>(null);\n  const [showAddCustomChainDialog, setShowAddCustomChainDialog] = useState(false);\n  \n  // Multi-select chain state\n  const [selectedChainIds, setSelectedChainIds] = useState<Set<string>>(new Set());\n  const [isConfirmingChains, setIsConfirmingChains] = useState(false);\n  const [customChainForm, setCustomChainForm] = useState({\n    name: '',\n    rpcUrl: '',\n    chainId: '',\n    symbol: '',\n    explorerUrl: ''\n  });\n\n  useEffect(() => {\n    fetchPrices().then(setPrices);\n    const priceInterval = setInterval(() => {\n      fetchPrices().then(setPrices);\n    }, 5000);\n    return () => clearInterval(priceInterval);\n  }, []);\n\n  useEffect(() => {\n    if (wallets.length === 0) return;\n    const balanceInterval = setInterval(() => {\n      // Only refresh selected wallet when viewing tokens, otherwise refresh all\n      if (selectedWallet && viewLevel === 'tokens') {\n        refreshWalletBalance(selectedWallet.id);\n      } else {\n        refreshBalances();\n      }\n    }, 5000);\n    return () => clearInterval(balanceInterval);\n  }, [wallets.length, refreshBalances, refreshWalletBalance, selectedWallet, viewLevel]);\n  \n  const displayChains = chains;\n  const displayWallets = visibleWallets;\n\n  const enabledAssets = topAssets.filter(asset => enabledAssetIds.has(asset.id));\n\n  const getWalletForAsset = (asset: TopAsset): { wallet?: WalletType; chain?: Chain } => {\n    // Check if this is a token - if so, look up by parent chain symbol\n    const parentChainSymbol = TOKEN_PARENT_CHAIN_SYMBOL[asset.id];\n    if (parentChainSymbol) {\n      // For tokens, find the parent chain by symbol (more reliable than name)\n      const chain = displayChains.find(c => c.symbol === parentChainSymbol);\n      if (!chain) return {};\n      const wallet = displayWallets.find(w => w.chainId === chain.id);\n      return { wallet, chain };\n    }\n    \n    // For native assets, use the symbol mapping\n    const chainSymbol = COINGECKO_ID_TO_CHAIN_SYMBOL[asset.id];\n    if (!chainSymbol) return {};\n    \n    const chain = displayChains.find(c => c.symbol === chainSymbol);\n    if (!chain) return {};\n    \n    const wallet = displayWallets.find(w => w.chainId === chain.id);\n    return { wallet, chain };\n  };\n\n  // Check if an asset has a wallet (either directly or via parent chain for tokens)\n  const hasWalletForAsset = (asset: TopAsset): boolean => {\n    const parentChainSymbol = TOKEN_PARENT_CHAIN_SYMBOL[asset.id];\n    if (parentChainSymbol) {\n      // For tokens, check if parent chain has a wallet (by symbol)\n      const parentChain = displayChains.find(c => c.symbol === parentChainSymbol);\n      if (!parentChain) return false;\n      return displayWallets.some(w => w.chainId === parentChain.id);\n    } else {\n      // For native assets, check if the chain has a wallet\n      const { wallet } = getWalletForAsset(asset);\n      return !!wallet;\n    }\n  };\n\n  // Filter and sort enabled assets\n  // Only filter by wallet existence when wallet is unlocked and has wallets\n  const filteredAssets = enabledAssets.filter(asset => {\n    // Only filter by wallet if we have wallets (i.e., unlocked state)\n    if (isUnlocked && displayWallets.length > 0) {\n      if (!hasWalletForAsset(asset)) return false;\n    }\n    \n    // Then apply search filter\n    if (!assetSearch.trim()) return true;\n    const searchLower = assetSearch.toLowerCase();\n    return (\n      asset.name.toLowerCase().includes(searchLower) ||\n      asset.symbol.toLowerCase().includes(searchLower)\n    );\n  });\n\n  // Sort enabled assets by USD value (highest first)\n  const sortedEnabledAssets = [...filteredAssets].sort((a, b) => {\n    const aData = getWalletForAsset(a);\n    const bData = getWalletForAsset(b);\n    \n    const aIsToken = isTokenAsset(a.id);\n    const bIsToken = isTokenAsset(b.id);\n    \n    const aValue = aIsToken && tokenBalances[a.id]\n      ? parseFloat(tokenBalances[a.id]) * (a.currentPrice || 0)\n      : (aData.wallet && aData.chain \n        ? calculateUSDValue(aData.wallet.balance, aData.chain.symbol, prices) \n        : 0);\n    const bValue = bIsToken && tokenBalances[b.id]\n      ? parseFloat(tokenBalances[b.id]) * (b.currentPrice || 0)\n      : (bData.wallet && bData.chain \n        ? calculateUSDValue(bData.wallet.balance, bData.chain.symbol, prices) \n        : 0);\n    \n    if (bValue !== aValue) {\n      return bValue - aValue;\n    }\n    return (a.marketCapRank || 999) - (b.marketCapRank || 999);\n  });\n\n  // Combine custom tokens with top assets, sorted by USD value\n  type CombinedAsset = TopAsset | CustomToken;\n  const allAssets: CombinedAsset[] = [...sortedEnabledAssets];\n  \n  // Add custom tokens that belong to current wallet if viewing tokens\n  if (selectedWallet && viewLevel === 'tokens') {\n    const walletCustomTokens = customTokens.filter(t => t.walletId === selectedWallet.id && t.chainId === selectedChain?.symbol);\n    allAssets.push(...walletCustomTokens);\n  } else {\n    // Otherwise show all custom tokens (global view)\n    allAssets.push(...customTokens);\n  }\n  \n  // Sort all assets by USD value\n  const sortedAllAssets = [...allAssets].sort((a, b) => {\n    const aIsCustom = 'walletId' in a;\n    const bIsCustom = 'walletId' in b;\n    \n    let aValue = 0;\n    let bValue = 0;\n    \n    if (aIsCustom) {\n      const customToken = a as CustomToken;\n      aValue = parseFloat(customTokenBalances[customToken.id] || \"0\") * (topAssets.find(ta => ta.symbol.toUpperCase() === customToken.symbol.toUpperCase())?.currentPrice || 0);\n    } else {\n      const topAsset = a as TopAsset;\n      const aData = getWalletForAsset(topAsset);\n      const aIsToken = isTokenAsset(topAsset.id);\n      aValue = aIsToken && tokenBalances[topAsset.id]\n        ? parseFloat(tokenBalances[topAsset.id]) * (topAsset.currentPrice || 0)\n        : (aData.wallet && aData.chain \n          ? calculateUSDValue(aData.wallet.balance, aData.chain.symbol, prices) \n          : 0);\n    }\n    \n    if (bIsCustom) {\n      const customToken = b as CustomToken;\n      bValue = parseFloat(customTokenBalances[customToken.id] || \"0\") * (topAssets.find(ta => ta.symbol.toUpperCase() === customToken.symbol.toUpperCase())?.currentPrice || 0);\n    } else {\n      const topAsset = b as TopAsset;\n      const bData = getWalletForAsset(topAsset);\n      const bIsToken = isTokenAsset(topAsset.id);\n      bValue = bIsToken && tokenBalances[topAsset.id]\n        ? parseFloat(tokenBalances[topAsset.id]) * (topAsset.currentPrice || 0)\n        : (bData.wallet && bData.chain \n          ? calculateUSDValue(bData.wallet.balance, bData.chain.symbol, prices) \n          : 0);\n    }\n    \n    return bValue - aValue;\n  });\n\n  // Calculate total value from native coin wallets\n  const nativeUSDValue = displayWallets.reduce((sum, w) => {\n    const chain = displayChains.find(c => c.id === w.chainId);\n    if (!chain) return sum;\n    return sum + calculateUSDValue(w.balance, chain.symbol, prices);\n  }, 0);\n\n  // Calculate total value from token balances\n  const tokenUSDValue = Object.entries(tokenBalances).reduce((sum, [assetId, balance]) => {\n    const asset = topAssets.find(a => a.id === assetId);\n    if (!asset) return sum;\n    return sum + (parseFloat(balance) * (asset.currentPrice || 0));\n  }, 0);\n\n  const totalUSDValue = nativeUSDValue + tokenUSDValue;\n\n  const hasWallets = displayWallets.length > 0;\n\n  // Get chains that have wallets - for the chain selection view (use all wallets, not filtered by account)\n  const chainsWithWallets = useMemo(() => {\n    const chainIds = new Set(wallets.map(w => w.chainId));\n    return displayChains.filter(c => chainIds.has(c.id));\n  }, [displayChains, wallets]);\n\n  // Get chains that don't have wallets yet - for \"Add New Chain\" section\n  const chainsWithoutWallets = useMemo(() => {\n    const chainIds = new Set(wallets.map(w => w.chainId));\n    return displayChains.filter(c => !chainIds.has(c.id));\n  }, [displayChains, wallets]);\n\n  // Calculate balance per chain (across all wallets for the chain)\n  const getChainBalance = (chain: Chain) => {\n    const walletsForChain = wallets.filter(w => w.chainId === chain.id);\n    return walletsForChain.reduce((sum, w) => sum + parseFloat(w.balance), 0);\n  };\n\n  const getChainUSDValue = (chain: Chain) => {\n    const walletsForChain = wallets.filter(w => w.chainId === chain.id);\n    return walletsForChain.reduce((sum, w) => {\n      return sum + calculateUSDValue(w.balance, chain.symbol, prices);\n    }, 0);\n  };\n\n  // Get ALL wallets for selected chain (not filtered by account index)\n  const walletsForSelectedChain = useMemo(() => {\n    if (!selectedChain) return [];\n    return wallets.filter(w => w.chainId === selectedChain.id);\n  }, [selectedChain, wallets]);\n\n  // Get tokens for selected wallet (native + ERC20 tokens on that chain)\n  const tokensForSelectedWallet = useMemo(() => {\n    if (!selectedWallet || !selectedChain) return [];\n    \n    // Get native asset for this chain\n    const nativeAsset = topAssets.find(a => {\n      const chainSymbol = COINGECKO_ID_TO_CHAIN_SYMBOL[a.id];\n      return chainSymbol === selectedChain.symbol && !TOKEN_PARENT_CHAIN[a.id];\n    });\n    \n    // Get ERC20 tokens for this chain\n    const tokenAssets = topAssets.filter(a => {\n      const chainSymbol = COINGECKO_ID_TO_CHAIN_SYMBOL[a.id];\n      return chainSymbol === selectedChain.symbol && TOKEN_PARENT_CHAIN[a.id] && enabledAssetIds.has(a.id);\n    });\n    \n    const assets: TopAsset[] = [];\n    if (nativeAsset) assets.push(nativeAsset);\n    assets.push(...tokenAssets);\n    \n    return assets;\n  }, [selectedWallet, selectedChain, topAssets, enabledAssetIds]);\n\n  // Calculate selected wallet's total USD value (native + tokens)\n  const selectedWalletUSDValue = useMemo(() => {\n    if (!selectedWallet || !selectedChain) return 0;\n    \n    // Native balance USD value\n    const nativeValue = calculateUSDValue(selectedWallet.balance, selectedChain.symbol, prices);\n    \n    // Token balances USD value for this chain\n    const chainTokenValue = Object.entries(tokenBalances).reduce((sum, [assetId, balance]) => {\n      const asset = topAssets.find(a => a.id === assetId);\n      if (!asset) return sum;\n      // Only count tokens on this chain\n      const chainSymbol = COINGECKO_ID_TO_CHAIN_SYMBOL[assetId];\n      if (chainSymbol !== selectedChain.symbol) return sum;\n      return sum + (parseFloat(balance) * (asset.currentPrice || 0));\n    }, 0);\n    \n    return nativeValue + chainTokenValue;\n  }, [selectedWallet, selectedChain, prices, tokenBalances, topAssets]);\n\n  // Calculate selected chain's total USD value (native + tokens across all wallets on this chain)\n  const selectedChainUSDValue = useMemo(() => {\n    if (!selectedChain) return 0;\n    \n    // Native balance USD value for all wallets on this chain\n    const nativeValue = getChainUSDValue(selectedChain);\n    \n    // Token balances USD value for this chain\n    const chainTokenValue = Object.entries(tokenBalances).reduce((sum, [assetId, balance]) => {\n      const asset = topAssets.find(a => a.id === assetId);\n      if (!asset) return sum;\n      // Only count tokens on this chain\n      const chainSymbol = COINGECKO_ID_TO_CHAIN_SYMBOL[assetId];\n      if (chainSymbol !== selectedChain.symbol) return sum;\n      return sum + (parseFloat(balance) * (asset.currentPrice || 0));\n    }, 0);\n    \n    return nativeValue + chainTokenValue;\n  }, [selectedChain, prices, tokenBalances, topAssets, wallets]);\n  \n  const handleRefresh = async () => {\n    setIsRefreshing(true);\n    try {\n      await Promise.all([\n        refreshBalances(),\n        refreshTopAssets(),\n        fetchPrices().then(setPrices)\n      ]);\n      toast({ title: \"Refreshed\", description: \"Balances and prices updated\" });\n    } finally {\n      setIsRefreshing(false);\n    }\n  };\n\n  const handleCreateWallet = async () => {\n    try {\n      if (walletCreationType === \"derive\") {\n        await createAdditionalWallet(newWalletLabel || undefined, selectedChain?.id);\n        setShowCreateWalletDialog(false);\n        setNewWalletLabel(\"\");\n        setWalletCreationType(\"derive\");\n        toast({ title: \"Wallet Created\", description: `New ${selectedChain?.name || ''} wallet has been created successfully` });\n      } else {\n        if (!seedPinInput || seedPinInput.length < 4) {\n          toast({ title: \"Error\", description: \"Please enter a PIN with at least 4 characters\", variant: \"destructive\" });\n          return;\n        }\n        const result = await createWalletWithNewSeed(newWalletLabel || undefined, seedPinInput);\n        setNewSeedPhrase(result.seedPhrase);\n        setShowCreateWalletDialog(false);\n        setShowSeedRevealDialog(true);\n        setNewWalletLabel(\"\");\n        setSeedPinInput(\"\");\n        setWalletCreationType(\"derive\");\n      }\n    } catch (err: any) {\n      const errorMsg = err?.message || \"Failed to create new wallet\";\n      toast({ title: \"Error\", description: errorMsg, variant: \"destructive\" });\n    }\n  };\n\n  // Navigation handlers\n  const handleSelectChain = (chain: Chain) => {\n    setSelectedChain(chain);\n    setSelectedWallet(null);\n    setViewLevel('wallets');\n  };\n\n  const handleSelectWallet = (wallet: WalletType) => {\n    setSelectedWallet(wallet);\n    setViewLevel('tokens');\n  };\n\n  const handleBack = () => {\n    if (viewLevel === 'tokens') {\n      setSelectedWallet(null);\n      setViewLevel('wallets');\n    } else if (viewLevel === 'wallets') {\n      setSelectedChain(null);\n      setSelectedWallet(null);\n      setViewLevel('chains');\n    }\n  };\n\n  // Handle adding a new chain (create wallet for that chain)\n  const handleAddChain = async (chain: Chain) => {\n    // Haptic feedback on tap\n    if (navigator.vibrate) {\n      navigator.vibrate(10);\n    }\n    \n    try {\n      setAddingChainId(chain.id);\n      await createAdditionalWallet(undefined, chain.id);\n      \n      // Success haptic feedback\n      if (navigator.vibrate) {\n        navigator.vibrate([50, 30, 50]);\n      }\n      \n      toast({ \n        title: \"Chain Added\", \n        description: `${chain.name} has been added to your wallet.` \n      });\n      // Automatically select the new chain\n      setSelectedChain(chain);\n      setViewLevel('wallets');\n    } catch (err: any) {\n      // Error haptic feedback\n      if (navigator.vibrate) {\n        navigator.vibrate([100, 50, 100]);\n      }\n      \n      toast({ \n        title: \"Error\", \n        description: err?.message || \"Failed to add chain\", \n        variant: \"destructive\" \n      });\n    } finally {\n      setAddingChainId(null);\n    }\n  };\n\n  // Toggle chain selection for multi-select\n  const handleToggleChainSelection = (chainId: string) => {\n    if (isConfirmingChains) return;\n    \n    setSelectedChainIds(prev => {\n      const newSet = new Set(prev);\n      if (newSet.has(chainId)) {\n        newSet.delete(chainId);\n      } else {\n        newSet.add(chainId);\n      }\n      return newSet;\n    });\n  };\n\n  // Confirm and add all selected chains\n  const handleConfirmSelectedChains = async () => {\n    if (selectedChainIds.size === 0) return;\n    \n    // Check if wallet is unlocked before attempting to add chains\n    if (!isUnlocked) {\n      toast({\n        title: \"Wallet Locked\",\n        description: \"Please unlock your wallet first to add new networks.\",\n        variant: \"destructive\"\n      });\n      return;\n    }\n    \n    setIsConfirmingChains(true);\n    \n    try {\n      const chainIdsArray = Array.from(selectedChainIds);\n      \n      // Add chains sequentially to avoid race conditions with wallet state\n      const successfulChainIds: string[] = [];\n      const failedChainIds: string[] = [];\n      \n      for (const chainId of chainIdsArray) {\n        try {\n          await createAdditionalWallet(undefined, chainId);\n          successfulChainIds.push(chainId);\n        } catch {\n          failedChainIds.push(chainId);\n        }\n      }\n      \n      // Clear only successfully added chains from selection\n      if (successfulChainIds.length > 0) {\n        setSelectedChainIds(prev => {\n          const newSet = new Set(prev);\n          successfulChainIds.forEach(id => newSet.delete(id));\n          return newSet;\n        });\n        \n        // Success haptic feedback\n        if (navigator.vibrate) {\n          navigator.vibrate([50, 30, 50]);\n        }\n        \n        toast({ \n          title: \"Chains Added\", \n          description: `${successfulChainIds.length} chain${successfulChainIds.length > 1 ? 's have' : ' has'} been added to your wallet.` \n        });\n      }\n      \n      // Show error for failed chains\n      if (failedChainIds.length > 0) {\n        const failedNames = failedChainIds\n          .map(id => displayChains.find(c => c.id === id)?.name)\n          .filter(Boolean)\n          .join(', ');\n        \n        // Error haptic feedback\n        if (navigator.vibrate) {\n          navigator.vibrate([100, 50, 100]);\n        }\n        \n        toast({ \n          title: \"Some Chains Failed\", \n          description: `Failed to add: ${failedNames}. They remain selected for retry.`, \n          variant: \"destructive\" \n        });\n      }\n    } catch (err: any) {\n      // Error haptic feedback\n      if (navigator.vibrate) {\n        navigator.vibrate([100, 50, 100]);\n      }\n      \n      toast({ \n        title: \"Error\", \n        description: err?.message || \"Failed to add chains\", \n        variant: \"destructive\" \n      });\n    } finally {\n      setIsConfirmingChains(false);\n    }\n  };\n\n  // Handle adding a custom chain\n  const handleAddCustomChain = async () => {\n    try {\n      // For now, just show a message - actual custom chain implementation would require backend support\n      toast({ \n        title: \"Coming Soon\", \n        description: \"Custom chain support will be available in a future update.\" \n      });\n      setShowAddCustomChainDialog(false);\n      setCustomChainForm({ name: '', rpcUrl: '', chainId: '', symbol: '', explorerUrl: '' });\n    } catch (err: any) {\n      toast({ \n        title: \"Error\", \n        description: err?.message || \"Failed to add custom chain\", \n        variant: \"destructive\" \n      });\n    }\n  };\n  \n  // Check if wallet is set up based on mode\n  const isWalletSetUp = walletMode === \"soft_wallet\" ? hasSoftWalletSetup : hasHardWalletSetup;\n  \n  // Only show setup screen if wallet is NOT set up\n  // If wallet is set up but has no chains, we still show the chain selection UI\n  if (!hasWallets && !isWalletSetUp) {\n    return (\n      <div className=\"p-4 md:p-6\">\n        <h1 className=\"mb-4 md:mb-6 text-2xl md:text-3xl font-bold\">Dashboard</h1>\n        <HardwareStatusCard />\n      </div>\n    );\n  }\n\n  // Soft Wallet - Hierarchical Flow: Chains -> Wallets -> Tokens\n  if (walletMode === \"soft_wallet\") {\n    return (\n      <div className=\"h-screen bg-background flex flex-col\">\n        {/* Header - Only show full header when chain is selected */}\n        {viewLevel !== 'chains' && (\n          <div className=\"shrink-0 bg-background\">\n            {/* Title Row */}\n            <div className=\"flex items-center justify-between px-4 py-3 border-b\">\n              <div className=\"flex items-center gap-2\">\n                <button\n                  onClick={handleBack}\n                  className=\"text-muted-foreground hover:text-foreground\"\n                  data-testid=\"button-back\"\n                >\n                  <ChevronLeft className=\"h-5 w-5\" />\n                </button>\n                <span className=\"font-semibold\">\n                  {viewLevel === 'wallets' && `${selectedChain?.name}`}\n                  {viewLevel === 'tokens' && `${selectedChain?.name} Wallet`}\n                </span>\n              </div>\n              <Button\n                size=\"icon\"\n                variant=\"ghost\"\n                onClick={handleRefresh}\n                disabled={isRefreshing || balanceCacheStatus.isRefreshing}\n                data-testid=\"button-refresh-portfolio\"\n              >\n                <RefreshCw className={`h-4 w-4 ${isRefreshing || balanceCacheStatus.isRefreshing ? \"animate-spin\" : \"\"}`} />\n              </Button>\n            </div>\n\n            {/* Breadcrumb Navigation */}\n            {viewLevel !== 'tokens' && (\n            <div className=\"flex items-center justify-between gap-2 px-4 py-2 bg-muted/40 text-sm border-y\">\n              <div className=\"flex items-center gap-2 min-w-0\">\n                <button \n                  onClick={() => { setViewLevel('chains'); setSelectedChain(null); setSelectedWallet(null); }}\n                  className=\"text-muted-foreground hover:text-foreground\"\n                  data-testid=\"breadcrumb-chains\"\n                >\n                  Chains\n                </button>\n                {selectedChain && (\n                  <>\n                    <ChevronRight className=\"h-4 w-4 text-muted-foreground shrink-0\" />\n                    {viewLevel === 'tokens' ? (\n                      <Select\n                        value={selectedChain.id}\n                        onValueChange={(chainId) => {\n                          const chain = chainsWithWallets.find(c => c.id === chainId);\n                          if (chain) {\n                            setSelectedChain(chain);\n                            setSelectedWallet(null);\n                            setViewLevel('wallets');\n                          }\n                        }}\n                      >\n                        <SelectTrigger className=\"h-auto text-sm border-0 bg-transparent px-0 py-0 gap-1 w-auto\" data-testid=\"select-chain-dropdown\">\n                          <div className=\"flex items-center gap-2\">\n                            <ChainIcon symbol={selectedChain.symbol} iconColor={selectedChain.iconColor} size=\"sm\" />\n                            <span>{selectedChain.name}</span>\n                          </div>\n                        </SelectTrigger>\n                        <SelectContent>\n                          {chainsWithWallets.map((chain) => (\n                            <SelectItem key={chain.id} value={chain.id} data-testid={`select-chain-option-${chain.symbol}`}>\n                              <div className=\"flex items-center gap-2\">\n                                <ChainIcon symbol={chain.symbol} iconColor={chain.iconColor} size=\"sm\" />\n                                <span>{chain.name}</span>\n                              </div>\n                            </SelectItem>\n                          ))}\n                        </SelectContent>\n                      </Select>\n                    ) : (\n                      <button \n                        onClick={() => { setViewLevel('wallets'); setSelectedWallet(null); }}\n                        className={`flex items-center gap-2 ${viewLevel === 'wallets' ? 'font-medium text-foreground' : 'text-muted-foreground hover:text-foreground'}`}\n                        data-testid=\"breadcrumb-wallets\"\n                      >\n                        <ChainIcon symbol={selectedChain.symbol} iconColor={selectedChain.iconColor} size=\"sm\" />\n                        {selectedChain.name}\n                      </button>\n                    )}\n                  </>\n                )}\n                {selectedWallet && (\n                  <>\n                    <ChevronRight className=\"h-4 w-4 text-muted-foreground shrink-0\" />\n                    <span className=\"font-medium text-foreground\" data-testid=\"breadcrumb-tokens\">\n                      Tokens\n                    </span>\n                  </>\n                )}\n              </div>\n              {viewLevel === 'wallets' && selectedChain && (\n                <Dialog open={showCreateWalletDialog} onOpenChange={setShowCreateWalletDialog}>\n                  <DialogTrigger asChild>\n                    <Button size=\"sm\" className=\"gap-2 flex-shrink-0\" data-testid=\"button-create-chain-wallet\">\n                      <Plus className=\"h-4 w-4\" />\n                      <span>Add Wallet</span>\n                    </Button>\n                  </DialogTrigger>\n                  <DialogContent className=\"sm:max-w-md max-h-[90vh] overflow-y-auto\">\n                    <DialogHeader className=\"pb-2\">\n                      <DialogTitle className=\"text-base\">Create {selectedChain.name} Wallet</DialogTitle>\n                      <DialogDescription className=\"text-xs\">\n                        Create a new wallet for {selectedChain.name}.\n                      </DialogDescription>\n                    </DialogHeader>\n                    <div className=\"py-2 space-y-3\">\n                      <div>\n                        <Label htmlFor=\"wallet-label\" className=\"text-sm\">Wallet Label (optional)</Label>\n                        <Input\n                          id=\"wallet-label\"\n                          placeholder=\"e.g., Savings, Trading, DeFi\"\n                          value={newWalletLabel}\n                          onChange={(e) => setNewWalletLabel(e.target.value)}\n                          className=\"mt-1.5 h-9\"\n                          data-testid=\"input-wallet-label\"\n                        />\n                      </div>\n                      <div className=\"space-y-2\">\n                        <Label className=\"text-sm\">Wallet Type</Label>\n                        <RadioGroup \n                          value={walletCreationType} \n                          onValueChange={(val) => setWalletCreationType(val as \"derive\" | \"new-seed\")}\n                          className=\"space-y-2\"\n                        >\n                          <div className=\"flex items-start gap-2.5 p-2.5 rounded-md border\">\n                            <RadioGroupItem value=\"derive\" id=\"derive\" className=\"mt-0.5\" data-testid=\"radio-derive\" />\n                            <div className=\"flex-1 min-w-0\">\n                              <Label htmlFor=\"derive\" className=\"text-sm font-medium cursor-pointer\">Derive from existing seed</Label>\n                              <p className=\"text-xs text-muted-foreground mt-0.5\">\n                                Uses your main seed phrase with a new account index.\n                              </p>\n                            </div>\n                          </div>\n                          <div className=\"flex items-start gap-2.5 p-2.5 rounded-md border\">\n                            <RadioGroupItem value=\"new-seed\" id=\"new-seed\" className=\"mt-0.5\" data-testid=\"radio-new-seed\" />\n                            <div className=\"flex-1 min-w-0\">\n                              <Label htmlFor=\"new-seed\" className=\"text-sm font-medium cursor-pointer\">Generate new seed phrase</Label>\n                              <p className=\"text-xs text-muted-foreground mt-0.5\">\n                                Creates a completely independent wallet with its own seed phrase.\n                              </p>\n                            </div>\n                          </div>\n                        </RadioGroup>\n                        {walletCreationType === \"new-seed\" && (\n                          <div className=\"space-y-3 pt-2 border-t mt-3\">\n                            <div>\n                              <Label htmlFor=\"seed-wallet-name\" className=\"text-sm\">Wallet Name</Label>\n                              <Input\n                                id=\"seed-wallet-name\"\n                                placeholder=\"e.g., My Savings Wallet\"\n                                value={newWalletLabel}\n                                onChange={(e) => setNewWalletLabel(e.target.value)}\n                                className=\"mt-1.5 h-9\"\n                                data-testid=\"input-seed-wallet-name\"\n                              />\n                            </div>\n                            <div>\n                              <Label htmlFor=\"seed-pin\" className=\"text-sm\">PIN for new seed (min 4 characters)</Label>\n                              <Input\n                                id=\"seed-pin\"\n                                type=\"password\"\n                                placeholder=\"Enter PIN to encrypt new seed\"\n                                value={seedPinInput}\n                                onChange={(e) => setSeedPinInput(e.target.value)}\n                                className=\"mt-1.5 h-9\"\n                                data-testid=\"input-seed-pin\"\n                              />\n                            </div>\n                          </div>\n                        )}\n                      </div>\n                    </div>\n                    <DialogFooter className=\"flex-col sm:flex-row gap-2 pt-2\">\n                      <Button \n                        variant=\"outline\" \n                        size=\"sm\"\n                        className=\"w-full sm:w-auto order-2 sm:order-1\"\n                        onClick={() => {\n                          setShowCreateWalletDialog(false);\n                          setWalletCreationType(\"derive\");\n                          setSeedPinInput(\"\");\n                        }}\n                      >\n                        Cancel\n                      </Button>\n                      <Button \n                        size=\"sm\"\n                        className=\"w-full sm:w-auto order-1 sm:order-2\"\n                        onClick={handleCreateWallet} \n                        disabled={isLoading} \n                        data-testid=\"button-confirm-create-wallet\"\n                      >\n                        {isLoading ? \"Creating...\" : \"Create Wallet\"}\n                      </Button>\n                    </DialogFooter>\n                  </DialogContent>\n                </Dialog>\n              )}\n            </div>\n            )}\n          </div>\n        )}\n\n        {/* Main Content - Side by Side Layout */}\n        <div className=\"flex flex-1 min-h-0 overflow-hidden\">\n          {/* Left Column: Chain List (hidden on mobile and when wallet selected) */}\n          {viewLevel !== 'tokens' && (\n            <div className=\"hidden md:flex w-20 flex-col min-h-0\">\n              <div className=\"flex-1 overflow-y-auto py-2 scrollbar-hide\" style={{ overscrollBehavior: 'contain', scrollbarWidth: 'none', msOverflowStyle: 'none' }}>\n                {chainsWithWallets.map((chain) => (\n                  <div\n                    key={chain.id}\n                    className={`p-3 cursor-pointer flex justify-center hover-elevate ${selectedChain?.id === chain.id ? 'bg-muted border-r-2 border-primary' : ''}`}\n                    onClick={() => {\n                      setSelectedChain(chain);\n                      setSelectedWallet(null);\n                      setViewLevel('wallets');\n                    }}\n                    data-testid={`chain-icon-${chain.symbol}`}\n                  >\n                    <ChainIcon symbol={chain.symbol} iconColor={chain.iconColor} size=\"lg\" />\n                  </div>\n                ))}\n              </div>\n            </div>\n          )}\n\n          {/* Right Column: Wallet List for Selected Chain */}\n          <div className=\"flex-1 min-h-0 overflow-y-auto p-2 sm:p-4 pb-44 md:pb-4\" style={{ overscrollBehavior: 'contain', WebkitOverflowScrolling: 'touch' }}>\n            {!selectedChain ? (\n              <div className=\"flex flex-col h-full relative\">\n                <div className=\"flex-1 space-y-6 pb-4\">\n                  {/* Loading shimmer when fetching chains */}\n                  {isLoading && chains.length === 0 && (\n                    <div>\n                      <div className=\"h-6 w-32 bg-muted rounded animate-pulse mb-3\" />\n                      <div className=\"grid grid-cols-2 sm:grid-cols-3 lg:grid-cols-4 gap-3\">\n                        {[1, 2, 3, 4, 5, 6].map((i) => (\n                          <Card key={i} data-testid={`skeleton-chain-${i}`}>\n                            <CardContent className=\"p-3 flex flex-col items-center gap-2\">\n                              <Skeleton className=\"h-10 w-10 rounded-full\" />\n                              <Skeleton className=\"h-3 w-16\" />\n                              <Skeleton className=\"h-3 w-12\" />\n                            </CardContent>\n                          </Card>\n                        ))}\n                      </div>\n                    </div>\n                  )}\n\n                  {/* Section 1: Previously Added Chains */}\n                  {!isLoading && chainsWithWallets.length > 0 && (\n                    <div>\n                      <div className=\"sticky top-0 z-10 bg-background/95 backdrop-blur-sm py-3 -mx-4 px-4 border-b mb-4\">\n                        <h3 className=\"font-bold text-base tracking-tight\" data-testid=\"text-your-chains\">Your Chains</h3>\n                        <p className=\"text-xs text-muted-foreground mt-0.5\">{chainsWithWallets.length} network{chainsWithWallets.length !== 1 ? 's' : ''} active</p>\n                      </div>\n                      <div className=\"grid grid-cols-3 sm:grid-cols-4 gap-2\">\n                        {chainsWithWallets.slice(0, showAllAddedChains ? undefined : 8).map((chain, index) => (\n                          <Card\n                            key={chain.id}\n                            className=\"hover-elevate cursor-pointer relative transition-all duration-200 active:scale-[0.98]\"\n                            onClick={() => {\n                              if (navigator.vibrate) navigator.vibrate(10);\n                              setSelectedChain(chain);\n                              setSelectedWallet(null);\n                              setViewLevel('wallets');\n                            }}\n                            data-testid={`card-chain-${chain.symbol}`}\n                          >\n                            <CardContent className=\"p-3 flex flex-col items-center gap-2\">\n                              <div className=\"relative\">\n                                <div className=\"h-10 w-10 rounded-full bg-muted/50 flex items-center justify-center\">\n                                  <ChainIcon symbol={chain.symbol} iconColor={chain.iconColor} size=\"md\" />\n                                </div>\n                                <div className=\"absolute -bottom-0.5 -right-0.5 h-4 w-4 rounded-full bg-green-500 dark:bg-green-500 flex items-center justify-center ring-2 ring-background\">\n                                  <Check className=\"h-2.5 w-2.5 text-white\" />\n                                </div>\n                              </div>\n                              <div className=\"text-center w-full\">\n                                <span className=\"text-xs font-semibold block truncate\">{chain.name}</span>\n                              </div>\n                            </CardContent>\n                          </Card>\n                        ))}\n                      </div>\n                      {chainsWithWallets.length > 6 && (\n                        <Button\n                          variant=\"ghost\"\n                          className=\"w-full mt-3\"\n                          onClick={() => setShowAllAddedChains(!showAllAddedChains)}\n                          data-testid=\"button-view-all-chains\"\n                        >\n                          {showAllAddedChains ? 'Show Less' : `View All ${chainsWithWallets.length} Chains`}\n                          <ChevronRight className={`h-4 w-4 ml-1 transition-transform ${showAllAddedChains ? 'rotate-90' : ''}`} />\n                        </Button>\n                      )}\n                    </div>\n                  )}\n\n                  {/* Empty state when no chains added yet */}\n                  {!isLoading && chainsWithWallets.length === 0 && chainsWithoutWallets.length > 0 && (\n                    <div className=\"text-center py-10 px-6 bg-gradient-to-b from-primary/5 to-transparent rounded-xl border border-dashed border-primary/20\" data-testid=\"empty-state-no-chains\">\n                      <div className=\"h-16 w-16 mx-auto mb-4 rounded-full bg-primary/10 flex items-center justify-center\">\n                        <Wallet className=\"h-8 w-8 text-primary\" />\n                      </div>\n                      <p className=\"font-semibold text-lg text-foreground mb-1\">Get Started</p>\n                      <p className=\"text-sm text-muted-foreground max-w-xs mx-auto\">Select the blockchain networks you want to add to your wallet</p>\n                    </div>\n                  )}\n\n                  {/* Section 2: Add New Chains - Multi-select */}\n                  {!isLoading && chainsWithoutWallets.length > 0 && (\n                    <div className=\"mt-2\">\n                      <div className=\"sticky top-0 z-10 bg-background/95 backdrop-blur-sm py-3 -mx-4 px-4 border-b mb-4\">\n                        <div className=\"flex items-center justify-between gap-2\">\n                          <div>\n                            <h3 className=\"font-bold text-base tracking-tight\" data-testid=\"text-add-new-chain\">Add Networks</h3>\n                            <p className=\"text-xs text-muted-foreground mt-0.5\">{chainsWithoutWallets.length} available</p>\n                          </div>\n                          {selectedChainIds.size > 0 && (\n                            <Badge \n                              variant=\"secondary\" \n                              className=\"cursor-pointer\"\n                              onClick={() => !isConfirmingChains && setSelectedChainIds(new Set())}\n                              data-testid=\"button-clear-selection\"\n                            >\n                              {selectedChainIds.size} selected\n                            </Badge>\n                          )}\n                        </div>\n                      </div>\n                      <div className=\"grid grid-cols-3 sm:grid-cols-4 gap-2\">\n                        {chainsWithoutWallets.map((chain) => {\n                          const isSelected = selectedChainIds.has(chain.id);\n                          return (\n                            <Card\n                              key={chain.id}\n                              className={`cursor-pointer transition-all duration-200 active:scale-[0.98] ${\n                                isSelected \n                                  ? 'ring-2 ring-primary shadow-md shadow-primary/10' \n                                  : 'hover-elevate'\n                              } ${isConfirmingChains ? 'opacity-50 pointer-events-none' : ''}`}\n                              onClick={() => {\n                                if (navigator.vibrate) navigator.vibrate(10);\n                                handleToggleChainSelection(chain.id);\n                              }}\n                              data-testid={`card-add-chain-${chain.symbol}`}\n                            >\n                              <CardContent className=\"p-3 flex flex-col items-center gap-2\">\n                                <div className=\"relative\">\n                                  <div className={`h-10 w-10 rounded-full flex items-center justify-center transition-colors ${isSelected ? 'bg-primary/10' : 'bg-muted/50'}`}>\n                                    <ChainIcon \n                                      symbol={chain.symbol} \n                                      iconColor={chain.iconColor} \n                                      size=\"md\" \n                                    />\n                                  </div>\n                                  {isSelected && (\n                                    <div className=\"absolute -bottom-0.5 -right-0.5 h-4 w-4 rounded-full bg-primary flex items-center justify-center ring-2 ring-background\">\n                                      <Check className=\"h-2.5 w-2.5 text-primary-foreground\" />\n                                    </div>\n                                  )}\n                                </div>\n                                <div className=\"text-center w-full\">\n                                  <span className=\"text-xs font-semibold block truncate\">{chain.name}</span>\n                                  <span className={`text-[10px] mt-0.5 block ${isSelected ? 'text-primary font-medium' : 'text-muted-foreground'}`}>\n                                    {isSelected ? 'Selected' : 'Tap to add'}\n                                  </span>\n                                </div>\n                              </CardContent>\n                            </Card>\n                          );\n                        })}\n                      </div>\n                    </div>\n                  )}\n\n                  {/* Empty state if no chains at all (shouldn't happen normally) */}\n                  {!isLoading && chainsWithWallets.length === 0 && chainsWithoutWallets.length === 0 && (\n                    <div className=\"text-center py-12\" data-testid=\"empty-state-no-available\">\n                      <Wallet className=\"mx-auto h-12 w-12 text-muted-foreground/50 mb-4\" />\n                      <p className=\"text-muted-foreground\">No chains available</p>\n                    </div>\n                  )}\n                </div>\n\n                {/* Add Custom Chain Button - At the bottom of chain list */}\n                <div className=\"mt-6 mb-4\">\n                  <div className=\"p-4 space-y-2\">\n                    {/* Confirm Selection Button - shows when chains are selected */}\n                    {selectedChainIds.size > 0 && (\n                      <Button \n                        className=\"w-full h-12 text-base font-semibold rounded-xl shadow-lg shadow-primary/20\" \n                        onClick={handleConfirmSelectedChains}\n                        disabled={isConfirmingChains}\n                        data-testid=\"button-confirm-chains\"\n                      >\n                        {isConfirmingChains ? (\n                          <>\n                            <div className=\"h-5 w-5 mr-2 border-2 border-primary-foreground border-t-transparent rounded-full animate-spin\" />\n                            Adding {selectedChainIds.size} Network{selectedChainIds.size > 1 ? 's' : ''}...\n                          </>\n                        ) : (\n                          <>\n                            <Check className=\"h-5 w-5 mr-2\" />\n                            Add {selectedChainIds.size} Network{selectedChainIds.size > 1 ? 's' : ''}\n                          </>\n                        )}\n                      </Button>\n                    )}\n                    \n                    {/* Add Custom Chain Button */}\n                    <Dialog open={showAddCustomChainDialog} onOpenChange={setShowAddCustomChainDialog}>\n                      <DialogTrigger asChild>\n                        <Button \n                          className={`w-full ${selectedChainIds.size > 0 ? 'h-10' : 'h-12 text-base font-semibold rounded-xl'}`}\n                          variant={selectedChainIds.size > 0 ? \"ghost\" : \"outline\"}\n                          data-testid=\"button-add-custom-chain\"\n                        >\n                          <Plus className=\"h-4 w-4 mr-2\" />\n                          Add Custom Network\n                        </Button>\n                      </DialogTrigger>\n                    <DialogContent>\n                      <DialogHeader>\n                        <DialogTitle>Add Custom Chain</DialogTitle>\n                        <DialogDescription>\n                          Enter the details for your custom blockchain network.\n                        </DialogDescription>\n                      </DialogHeader>\n                      <div className=\"space-y-4 py-4\">\n                        <div>\n                          <Label htmlFor=\"custom-chain-name\">Chain Name</Label>\n                          <Input\n                            id=\"custom-chain-name\"\n                            placeholder=\"e.g., My Network\"\n                            value={customChainForm.name}\n                            onChange={(e) => setCustomChainForm({ ...customChainForm, name: e.target.value })}\n                            className=\"mt-1\"\n                            data-testid=\"input-custom-chain-name\"\n                          />\n                        </div>\n                        <div>\n                          <Label htmlFor=\"custom-chain-rpc\">RPC URL</Label>\n                          <Input\n                            id=\"custom-chain-rpc\"\n                            placeholder=\"https://rpc.example.com\"\n                            value={customChainForm.rpcUrl}\n                            onChange={(e) => setCustomChainForm({ ...customChainForm, rpcUrl: e.target.value })}\n                            className=\"mt-1\"\n                            data-testid=\"input-custom-chain-rpc\"\n                          />\n                        </div>\n                        <div>\n                          <Label htmlFor=\"custom-chain-id\">Chain ID</Label>\n                          <Input\n                            id=\"custom-chain-id\"\n                            placeholder=\"e.g., 1\"\n                            type=\"number\"\n                            value={customChainForm.chainId}\n                            onChange={(e) => setCustomChainForm({ ...customChainForm, chainId: e.target.value })}\n                            className=\"mt-1\"\n                            data-testid=\"input-custom-chain-id\"\n                          />\n                        </div>\n                        <div>\n                          <Label htmlFor=\"custom-chain-symbol\">Currency Symbol</Label>\n                          <Input\n                            id=\"custom-chain-symbol\"\n                            placeholder=\"e.g., ETH\"\n                            value={customChainForm.symbol}\n                            onChange={(e) => setCustomChainForm({ ...customChainForm, symbol: e.target.value })}\n                            className=\"mt-1\"\n                            data-testid=\"input-custom-chain-symbol\"\n                          />\n                        </div>\n                        <div>\n                          <Label htmlFor=\"custom-chain-explorer\">Block Explorer URL (optional)</Label>\n                          <Input\n                            id=\"custom-chain-explorer\"\n                            placeholder=\"https://explorer.example.com\"\n                            value={customChainForm.explorerUrl}\n                            onChange={(e) => setCustomChainForm({ ...customChainForm, explorerUrl: e.target.value })}\n                            className=\"mt-1\"\n                            data-testid=\"input-custom-chain-explorer\"\n                          />\n                        </div>\n                      </div>\n                      <DialogFooter>\n                        <Button variant=\"outline\" onClick={() => {\n                          setShowAddCustomChainDialog(false);\n                          setCustomChainForm({ name: '', rpcUrl: '', chainId: '', symbol: '', explorerUrl: '' });\n                        }}>\n                          Cancel\n                        </Button>\n                        <Button \n                          onClick={handleAddCustomChain} \n                          disabled={!customChainForm.name || !customChainForm.rpcUrl || !customChainForm.chainId || !customChainForm.symbol}\n                          data-testid=\"button-save-custom-chain\"\n                        >\n                          Add Chain\n                        </Button>\n                      </DialogFooter>\n                    </DialogContent>\n                    </Dialog>\n                  </div>\n                </div>\n              </div>\n            ) : viewLevel === 'wallets' ? (\n              <div className=\"space-y-4\">\n                {walletsForSelectedChain.length === 0 ? (\n                  <Card>\n                    <CardContent className=\"py-12 text-center\">\n                      <Wallet className=\"mx-auto h-12 w-12 text-muted-foreground/50 mb-4\" />\n                      <p className=\"text-muted-foreground\">No wallets for {selectedChain.name}</p>\n                    </CardContent>\n                  </Card>\n                ) : (\n                  walletsForSelectedChain.map((wallet, index) => {\n                    const usdValue = calculateUSDValue(wallet.balance, selectedChain.symbol, prices);\n\n                    return (\n                      <Card \n                        key={wallet.id}\n                        className=\"hover-elevate cursor-pointer border bg-background\"\n                        onClick={() => handleSelectWallet(wallet)}\n                        data-testid={`card-wallet-${wallet.id}`}\n                      >\n                        <CardContent className=\"p-4\">\n                          <div className=\"flex items-center justify-between gap-3\">\n                            <div className=\"flex items-center gap-3 flex-1 min-w-0\">\n                              <ChainIcon symbol={selectedChain.symbol} iconColor={selectedChain.iconColor} size=\"lg\" />\n                              <div className=\"flex-1 min-w-0\">\n                                <h4 className=\"font-medium text-sm\">\n                                  {wallet.label || (index === 0 ? \"Main Wallet\" : `Wallet ${index + 1}`)}\n                                </h4>\n                                <p className=\"text-xs text-muted-foreground font-mono\">\n                                  {truncateAddress(wallet.address)}\n                                </p>\n                              </div>\n                            </div>\n                            <div className=\"flex-shrink-0 text-right\">\n                              <p className=\"font-semibold text-sm\">{formatUSD(usdValue)}</p>\n                              <p className=\"text-xs text-muted-foreground\">\n                                {formatBalance(wallet.balance)} {selectedChain.symbol}\n                              </p>\n                            </div>\n                            <ChevronRight className=\"h-4 w-4 text-muted-foreground flex-shrink-0\" />\n                          </div>\n                        </CardContent>\n                      </Card>\n                    );\n                  })\n                )}\n              </div>\n            ) : viewLevel === 'tokens' && selectedWallet ? (\n            <div className=\"space-y-3\">\n              {/* Balance Display Section */}\n              <Card className=\"bg-gradient-to-br from-primary/10 to-primary/5 border-primary/20\">\n                <CardContent className=\"p-6\">\n                  <div className=\"text-center space-y-4\">\n                    <div>\n                      <p className=\"text-sm text-muted-foreground mb-1\">Main Wallet Balance</p>\n                      <p className=\"text-3xl font-bold\">\n                        {formatUSD(selectedWalletUSDValue)}\n                      </p>\n                      <p className=\"text-sm text-muted-foreground mt-1\">\n                        {formatBalance(selectedWallet.balance)} {selectedChain.symbol}\n                      </p>\n                    </div>\n                    <div className=\"flex gap-3 justify-center\">\n                      <Button \n                        className=\"gap-2 flex-1 sm:flex-none\"\n                        onClick={() => navigate(`/transfer?chain=${selectedChain.id}`)}\n                        data-testid=\"button-send\"\n                      >\n                        <ArrowUpRight className=\"h-4 w-4\" />\n                        Send\n                      </Button>\n                      <Button \n                        variant=\"outline\"\n                        className=\"gap-2 flex-1 sm:flex-none\"\n                        onClick={() => navigate(`/transfer?chain=${selectedChain.id}&type=receive`)}\n                        data-testid=\"button-receive\"\n                      >\n                        <ArrowDownLeft className=\"h-4 w-4\" />\n                        Receive\n                      </Button>\n                    </div>\n                  </div>\n                </CardContent>\n              </Card>\n\n              {/* Assets/NFT Toggle */}\n              <div className=\"flex gap-2\">\n                <Button\n                  variant={showAssets ? \"default\" : \"outline\"}\n                  className=\"flex-1\"\n                  onClick={() => setShowAssets(true)}\n                  data-testid=\"button-toggle-assets\"\n                >\n                  Assets\n                </Button>\n                <Button\n                  variant={!showAssets ? \"default\" : \"outline\"}\n                  className=\"flex-1\"\n                  onClick={() => setShowAssets(false)}\n                  data-testid=\"button-toggle-nft\"\n                >\n                  NFT\n                </Button>\n              </div>\n\n              {/* Native Token Card */}\n              {showAssets && (\n              <Card \n                className=\"cursor-pointer hover:bg-muted/30 transition-colors\"\n                onClick={() => navigate(`/wallet/${selectedChain.id}/token/native`)}\n                data-testid={`card-token-native`}\n              >\n                <CardContent className=\"p-4\">\n                  <div className=\"flex items-center gap-4\">\n                    <ChainIcon symbol={selectedChain.symbol} iconColor={selectedChain.iconColor} size=\"lg\" />\n                    <div className=\"flex-1 min-w-0\">\n                      <h3 className=\"font-semibold\">{selectedChain.name}</h3>\n                      <p className=\"text-sm text-muted-foreground\">{selectedChain.symbol}</p>\n                    </div>\n                    <div className=\"text-right\">\n                      <p className=\"font-semibold\">{formatUSD(calculateUSDValue(selectedWallet.balance, selectedChain.symbol, prices))}</p>\n                      <p className=\"text-sm text-muted-foreground\">\n                        {formatBalance(selectedWallet.balance)} {selectedChain.symbol}\n                      </p>\n                    </div>\n                  </div>\n                </CardContent>\n              </Card>\n              )}\n\n              {/* ERC20 Tokens */}\n              {showAssets && tokensForSelectedWallet\n                .filter(a => TOKEN_PARENT_CHAIN[a.id])\n                .map((token) => {\n                  const balance = tokenBalances[token.id] || \"0\";\n                  const balanceNum = parseFloat(balance);\n                  const usdValue = balanceNum * (token.currentPrice || 0);\n\n                  return (\n                    <Card \n                      key={token.id} \n                      className=\"cursor-pointer hover:bg-muted/30 transition-colors\"\n                      onClick={() => navigate(`/wallet/${selectedChain.id}/token/${token.id}`)}\n                      data-testid={`card-token-${token.id}`}\n                    >\n                      <CardContent className=\"p-4\">\n                        <div className=\"flex items-center gap-4\">\n                          {getAssetIcon(token.id, token.image) ? (\n                            <img\n                              src={getAssetIcon(token.id, token.image)}\n                              alt={token.name}\n                              className=\"h-10 w-10 rounded-full bg-muted\"\n                              onError={(e) => { (e.target as HTMLImageElement).style.display = 'none'; }}\n                            />\n                          ) : (\n                            <div className=\"h-10 w-10 rounded-full bg-muted flex items-center justify-center text-sm font-semibold\">\n                              {token.symbol.slice(0, 2).toUpperCase()}\n                            </div>\n                          )}\n                          <div className=\"flex-1 min-w-0\">\n                            <h3 className=\"font-semibold\">{token.name}</h3>\n                            <p className=\"text-sm text-muted-foreground\">{token.symbol.toUpperCase()}</p>\n                          </div>\n                          <div className=\"text-right\">\n                            <p className=\"font-semibold\">{formatUSD(usdValue)}</p>\n                            <p className=\"text-sm text-muted-foreground\">\n                              {formatBalance(balance)} {token.symbol.toUpperCase()}\n                            </p>\n                          </div>\n                        </div>\n                      </CardContent>\n                    </Card>\n                  );\n                })}\n\n              {/* Custom Tokens for this wallet - only show for soft wallet */}\n              {showAssets && walletMode === \"soft_wallet\" && customTokens\n                .filter(t => t.chainId === selectedChain.symbol && (!t.walletId || t.walletId === selectedWallet.id))\n                .map((token) => {\n                  const balance = customTokenBalances[token.id] || \"0\";\n                  \n                  return (\n                    <Card \n                      key={token.id} \n                      className=\"cursor-pointer hover:bg-muted/30 transition-colors\"\n                      onClick={() => navigate(`/wallet/${selectedChain.id}/token/${token.id}`)}\n                      data-testid={`card-custom-token-${token.id}`}\n                    >\n                      <CardContent className=\"p-4\">\n                        <div className=\"flex items-center gap-4\">\n                          {getCustomTokenIcon(token) ? (\n                            <img\n                              src={getCustomTokenIcon(token)!}\n                              alt={token.name}\n                              className=\"h-10 w-10 rounded-full bg-muted shrink-0\"\n                              onError={(e) => { (e.target as HTMLImageElement).style.display = 'none'; }}\n                            />\n                          ) : null}\n                          <div className={`h-10 w-10 rounded-full bg-muted flex items-center justify-center text-sm font-semibold shrink-0 ${getCustomTokenIcon(token) ? 'hidden' : ''}`}>\n                            {token.symbol.slice(0, 2).toUpperCase()}\n                          </div>\n                          <div className=\"flex-1 min-w-0\">\n                            <div className=\"flex items-center gap-2 flex-wrap\">\n                              <h3 className=\"font-semibold\">{token.name}</h3>\n                              <Badge variant=\"outline\" className=\"text-xs\">Custom</Badge>\n                            </div>\n                            <p className=\"text-sm text-muted-foreground\">{token.symbol}</p>\n                          </div>\n                          <div className=\"text-right\">\n                            <p className=\"font-semibold\">\n                              {formatBalance(balance)} {token.symbol}\n                            </p>\n                          </div>\n                        </div>\n                      </CardContent>\n                    </Card>\n                  );\n                })}\n\n              {/* Add Custom Token Button - only show for soft wallet */}\n              {walletMode === \"soft_wallet\" && (\n              <div className=\"pt-2\">\n                <Link href={`/manage-crypto?chain=${selectedChain.symbol}&wallet=${selectedWallet.id}`}>\n                  <Button variant=\"outline\" className=\"w-full justify-start gap-3 h-14\" data-testid=\"button-add-custom-token\">\n                    <div className=\"h-8 w-8 rounded-full bg-muted flex items-center justify-center\">\n                      <Plus className=\"h-4 w-4\" />\n                    </div>\n                    <div className=\"text-left flex-1\">\n                      <p className=\"font-semibold text-sm\">Add Custom Token</p>\n                      <p className=\"text-xs text-muted-foreground\">\n                        {selectedChain.symbol === 'ETH' ? 'Import ERC-20 tokens' :\n                         selectedChain.symbol === 'BNB' ? 'Import BEP-20 tokens' :\n                         selectedChain.symbol === 'MATIC' ? 'Import Polygon tokens' :\n                         selectedChain.symbol === 'ARB' ? 'Import Arbitrum tokens' :\n                         selectedChain.symbol === 'TRX' ? 'Import TRC-20 tokens' :\n                         `Import ${selectedChain.name} tokens`}\n                      </p>\n                    </div>\n                  </Button>\n                </Link>\n              </div>\n              )}\n            </div>\n            ) : null}\n          </div>\n        </div>\n\n        {/* Seed Reveal Dialog */}\n        <Dialog open={showSeedRevealDialog} onOpenChange={(open) => {\n          if (!open && !seedConfirmed) return;\n          setShowSeedRevealDialog(open);\n          if (!open) {\n            setNewSeedPhrase(\"\");\n            setSeedConfirmed(false);\n          }\n        }}>\n          <DialogContent>\n            <DialogHeader>\n              <DialogTitle>Your New Seed Phrase</DialogTitle>\n              <DialogDescription>\n                Write down these 12 words and store them securely.\n              </DialogDescription>\n            </DialogHeader>\n            <div className=\"p-4 bg-muted rounded-md font-mono text-sm break-words\" data-testid=\"text-seed-phrase\">\n              {newSeedPhrase}\n            </div>\n            <div className=\"flex items-center gap-2 mt-4\">\n              <Checkbox \n                id=\"seed-confirmed\" \n                checked={seedConfirmed} \n                onCheckedChange={(checked) => setSeedConfirmed(!!checked)} \n                data-testid=\"checkbox-seed-confirmed\"\n              />\n              <Label htmlFor=\"seed-confirmed\" className=\"cursor-pointer\">I have written down my seed phrase</Label>\n            </div>\n            <DialogFooter>\n              <Button disabled={!seedConfirmed} onClick={() => {\n                setShowSeedRevealDialog(false);\n                setNewSeedPhrase(\"\");\n                setSeedConfirmed(false);\n                toast({ title: \"Wallet Created\", description: \"New wallet with independent seed created\" });\n              }} data-testid=\"button-seed-done\">\n                Done\n              </Button>\n            </DialogFooter>\n          </DialogContent>\n        </Dialog>\n      </div>\n    );\n  }\n\n  // Original card-based layout for Hard Wallet mode\n  return (\n    <div className=\"p-4 md:p-6\">\n      <div className=\"mb-4 md:mb-6 flex flex-wrap items-center justify-between gap-3\">\n        <h1 className=\"text-2xl md:text-3xl font-bold\">Dashboard</h1>\n        <div className=\"flex items-center gap-2\">\n          <WalletModeSelector />\n        </div>\n      </div>\n\n      <Card className=\"mb-4 md:mb-6\">\n        <CardContent className=\"p-4 md:p-6\">\n          <div className=\"flex items-center justify-between mb-1\">\n            <div className=\"flex items-center gap-2\">\n              <p className=\"text-xs md:text-sm text-muted-foreground\">\n                Hard Wallet Portfolio\n              </p>\n            </div>\n            <div className=\"flex items-center gap-2\">\n              {balanceCacheStatus.isStale && balanceCacheStatus.lastUpdated && (\n                <span className=\"text-xs text-muted-foreground\">\n                  Updated {clientStorage.getCacheAge(balanceCacheStatus.lastUpdated)}\n                </span>\n              )}\n              <Button\n                size=\"icon\"\n                variant=\"ghost\"\n                onClick={handleRefresh}\n                disabled={isRefreshing || balanceCacheStatus.isRefreshing}\n                data-testid=\"button-refresh-portfolio\"\n              >\n                <RefreshCw className={`h-4 w-4 ${isRefreshing || balanceCacheStatus.isRefreshing ? \"animate-spin\" : \"\"}`} />\n              </Button>\n            </div>\n          </div>\n          <div className=\"flex flex-wrap items-baseline gap-4\">\n            <h2 className=\"text-2xl md:text-4xl font-bold\" data-testid=\"text-portfolio-value\">\n              {formatUSD(totalUSDValue)}\n            </h2>\n            {balanceCacheStatus.isRefreshing && (\n              <span className=\"text-xs text-muted-foreground animate-pulse\">\n                Refreshing...\n              </span>\n            )}\n          </div>\n        </CardContent>\n      </Card>\n\n      <div className=\"mb-6\">\n        <div className=\"mb-4 flex flex-wrap items-center justify-between gap-4\">\n          <div className=\"flex items-center gap-2\">\n            <h2 className=\"text-xl font-semibold\">Your Assets</h2>\n            <Dialog open={showCreateWalletDialog} onOpenChange={setShowCreateWalletDialog}>\n              <DialogTrigger asChild>\n                <Button size=\"icon\" variant=\"ghost\" data-testid=\"button-create-wallet\">\n                  <Plus className=\"h-4 w-4\" />\n                </Button>\n              </DialogTrigger>\n              <DialogContent>\n                <DialogHeader>\n                  <DialogTitle>Create New Wallet</DialogTitle>\n                  <DialogDescription>\n                    Create an additional wallet for your portfolio.\n                  </DialogDescription>\n                </DialogHeader>\n                <div className=\"py-4 space-y-4\">\n                  <div>\n                    <Label htmlFor=\"wallet-label\">Wallet Label (optional)</Label>\n                    <Input\n                      id=\"wallet-label\"\n                      placeholder=\"e.g., Savings, Trading, DeFi\"\n                      value={newWalletLabel}\n                      onChange={(e) => setNewWalletLabel(e.target.value)}\n                      className=\"mt-2\"\n                      data-testid=\"input-wallet-label\"\n                    />\n                  </div>\n                  \n                </div>\n                <DialogFooter>\n                  <Button variant=\"outline\" onClick={() => {\n                    setShowCreateWalletDialog(false);\n                    setWalletCreationType(\"derive\");\n                    setSeedPinInput(\"\");\n                  }}>\n                    Cancel\n                  </Button>\n                  <Button onClick={handleCreateWallet} disabled={isLoading} data-testid=\"button-confirm-create-wallet\">\n                    {isLoading ? \"Creating...\" : \"Create Wallet\"}\n                  </Button>\n                </DialogFooter>\n              </DialogContent>\n            </Dialog>\n            \n            <Dialog open={showSeedRevealDialog} onOpenChange={(open) => {\n              if (!open && !seedConfirmed) return;\n              setShowSeedRevealDialog(open);\n              if (!open) {\n                setNewSeedPhrase(\"\");\n                setSeedConfirmed(false);\n              }\n            }}>\n              <DialogContent>\n                <DialogHeader>\n                  <DialogTitle>Your New Seed Phrase</DialogTitle>\n                  <DialogDescription>\n                    Write down these 12 words and store them securely. You will need them to recover this wallet.\n                  </DialogDescription>\n                </DialogHeader>\n                <div className=\"p-4 bg-muted rounded-md font-mono text-sm break-words\" data-testid=\"text-seed-phrase\">\n                  {newSeedPhrase}\n                </div>\n                <div className=\"flex items-center gap-2 mt-4\">\n                  <Checkbox \n                    id=\"seed-confirmed\" \n                    checked={seedConfirmed} \n                    onCheckedChange={(checked) => setSeedConfirmed(!!checked)} \n                    data-testid=\"checkbox-seed-confirmed\"\n                  />\n                  <Label htmlFor=\"seed-confirmed\" className=\"cursor-pointer\">I have written down my seed phrase</Label>\n                </div>\n                <DialogFooter>\n                  <Button disabled={!seedConfirmed} onClick={() => {\n                    setShowSeedRevealDialog(false);\n                    setNewSeedPhrase(\"\");\n                    setSeedConfirmed(false);\n                    toast({ title: \"Wallet Created\", description: \"New wallet with independent seed created\" });\n                  }} data-testid=\"button-seed-done\">\n                    Done\n                  </Button>\n                </DialogFooter>\n              </DialogContent>\n            </Dialog>\n          </div>\n          <div className=\"flex items-center gap-2\">\n            <div className=\"relative\">\n              <Search className=\"absolute left-2.5 top-1/2 -translate-y-1/2 h-4 w-4 text-muted-foreground\" />\n              <Input\n                placeholder=\"Search assets...\"\n                value={assetSearch}\n                onChange={(e) => setAssetSearch(e.target.value)}\n                className=\"pl-8 h-8 w-40 sm:w-48\"\n                data-testid=\"input-search-assets\"\n              />\n            </div>\n            <Button variant=\"ghost\" size=\"sm\" asChild>\n              <Link href=\"/manage-crypto\">\n                <Settings className=\"mr-1 h-4 w-4\" />\n                Manage\n              </Link>\n            </Button>\n            <Button variant=\"ghost\" size=\"sm\" asChild>\n              <Link href=\"/chains\">\n                View All\n                <ArrowUpRight className=\"ml-1 h-4 w-4\" />\n              </Link>\n            </Button>\n          </div>\n        </div>\n\n        {isLoadingAssets ? (\n          <div className=\"grid gap-4 sm:grid-cols-2 lg:grid-cols-3\">\n            {[1, 2, 3, 4, 5, 6].map((i) => (\n              <Card key={i}>\n                <CardContent className=\"p-4\">\n                  <div className=\"flex items-center gap-3\">\n                    <Skeleton className=\"h-8 w-8 rounded-full\" />\n                    <div>\n                      <Skeleton className=\"h-4 w-20 mb-1\" />\n                      <Skeleton className=\"h-3 w-12\" />\n                    </div>\n                  </div>\n                  <Skeleton className=\"h-4 w-24 mt-4\" />\n                  <Skeleton className=\"h-6 w-32 mt-2\" />\n                  <Skeleton className=\"h-10 w-full mt-4\" />\n                </CardContent>\n              </Card>\n            ))}\n          </div>\n        ) : sortedAllAssets.length === 0 ? (\n          <Card>\n            <CardContent className=\"py-12 text-center\">\n              <Settings className=\"mx-auto h-12 w-12 text-muted-foreground/50 mb-4\" />\n              <p className=\"text-muted-foreground\">No assets enabled</p>\n              <p className=\"text-sm text-muted-foreground mt-1 mb-4\">\n                Enable assets to track in Manage Crypto\n              </p>\n              <Button variant=\"outline\" size=\"sm\" asChild>\n                <Link href=\"/manage-crypto\">Manage Crypto</Link>\n              </Button>\n            </CardContent>\n          </Card>\n        ) : (\n          <div className=\"grid gap-4 sm:grid-cols-2 lg:grid-cols-3\">\n            {sortedAllAssets.map((asset) => {\n              const isCustom = 'walletId' in asset;\n              \n              if (isCustom) {\n                const customToken = asset as CustomToken;\n                const balance = customTokenBalances[customToken.id] || \"0\";\n                const price = topAssets.find(ta => ta.symbol.toUpperCase() === customToken.symbol.toUpperCase())?.currentPrice || 0;\n                const usdValue = parseFloat(balance) * price;\n                \n                return (\n                  <Card key={customToken.id} className=\"hover-elevate cursor-pointer transition-all h-full\" data-testid={`card-custom-token-${customToken.id}`}>\n                    <CardContent className=\"p-3 sm:p-4 flex flex-col h-full\">\n                      <div className=\"flex items-center justify-between gap-3\">\n                        <div className=\"flex items-center gap-3 min-w-0 flex-1\">\n                          {(() => {\n                            const icon = getCustomTokenIcon(customToken);\n                            if (icon && icon.trim()) {\n                              return (\n                                <img\n                                  src={icon}\n                                  alt={customToken.name}\n                                  className=\"h-10 w-10 rounded-full bg-muted shrink-0\"\n                                  onError={(e) => { (e.target as HTMLImageElement).style.display = 'none'; }}\n                                />\n                              );\n                            }\n                            return (\n                              <div className=\"h-10 w-10 rounded-full bg-muted shrink-0 flex items-center justify-center text-xs font-semibold\">\n                                {customToken.symbol.slice(0, 2).toUpperCase()}\n                              </div>\n                            );\n                          })()}\n                          <div className=\"min-w-0 flex-1\">\n                            <h3 className=\"font-semibold truncate text-sm\">{customToken.name}</h3>\n                            <p className=\"text-xs text-muted-foreground\">\n                              {customToken.symbol.toUpperCase()}\n                            </p>\n                          </div>\n                        </div>\n                        <div className=\"text-right shrink-0\">\n                          <p className=\"font-semibold text-sm\" data-testid={`text-value-${customToken.id}`}>{formatUSD(usdValue)}</p>\n                          <p className=\"text-xs text-muted-foreground\">{formatBalance(balance)} {customToken.symbol.toUpperCase()}</p>\n                        </div>\n                      </div>\n                    </CardContent>\n                  </Card>\n                );\n              } else {\n                const topAsset = asset as TopAsset;\n                const { wallet, chain } = getWalletForAsset(topAsset);\n                return (\n                  <CombinedAssetCard\n                    key={topAsset.id}\n                    asset={topAsset}\n                    wallet={wallet}\n                    chain={chain}\n                    prices={prices}\n                    tokenBalance={tokenBalances[topAsset.id]}\n                  />\n                );\n              }\n            })}\n          </div>\n        )}\n      </div>\n    </div>\n  );\n}\n","path":null,"size_bytes":88629,"size_tokens":null},"client/src/lib/chain-mappings.ts":{"content":"// Maps CoinGecko asset IDs to their chain symbols\n// Used for both native assets and tokens to determine which chain they belong to\nexport const COINGECKO_ID_TO_CHAIN_SYMBOL: Record<string, string> = {\n  'ethereum': 'ETH',\n  'matic-network': 'MATIC',\n  'binancecoin': 'BNB',\n  'avalanche-2': 'AVAX',\n  'arbitrum': 'ARB',\n  'bitcoin': 'BTC',\n  'solana': 'SOL',\n  'ripple': 'XRP',\n  'dogecoin': 'DOGE',\n  'cardano': 'ADA',\n  'tron': 'TRX',\n  'polkadot': 'DOT',\n  'litecoin': 'LTC',\n  'bitcoin-cash': 'BCH',\n  'cosmos': 'ATOM',\n  'osmosis': 'OSMO',\n  'tether': 'ETH',\n  'usd-coin': 'ETH',\n  'staked-ether': 'ETH',\n  'chainlink': 'ETH',\n  'wrapped-bitcoin': 'ETH',\n  'uniswap': 'ETH',\n  'shiba-inu': 'ETH',\n  'aave': 'ETH',\n  'maker': 'ETH',\n  'the-graph': 'ETH',\n  'compound-governance-token': 'ETH',\n  'yearn-finance': 'ETH',\n  'sushi': 'ETH',\n  'curve-dao-token': 'ETH',\n  '1inch': 'ETH',\n  'ens': 'ETH',\n  'lido-dao': 'ETH',\n  'rocket-pool': 'ETH',\n  'frax': 'ETH',\n  'dai': 'ETH',\n  'pancakeswap-token': 'BNB',\n  'venus': 'BNB',\n  'baby-doge-coin': 'BNB',\n  'trust-wallet-token': 'BNB',\n  'raydium': 'SOL',\n  'bonk': 'SOL',\n  'jupiter-exchange-solana': 'SOL',\n  'jito-governance-token': 'SOL',\n  'trader-joe': 'AVAX',\n  'benqi': 'AVAX',\n  'gmx': 'ARB',\n  'magic': 'ARB',\n  'optimism': 'OP',\n  'tether-bsc': 'BNB',\n  'tether-tron': 'TRX',\n  'usd-coin-bsc': 'BNB',\n  'usd-coin-tron': 'TRX',\n};\n\n// Maps token IDs to parent chain SYMBOL for wallet address lookup\nexport const TOKEN_PARENT_CHAIN_SYMBOL: Record<string, string> = {\n  'tether': 'ETH',\n  'tether-bsc': 'BNB',\n  'tether-tron': 'TRX',\n  'usd-coin': 'ETH',\n  'usd-coin-bsc': 'BNB',\n  'usd-coin-tron': 'TRX',\n  'staked-ether': 'ETH',\n  'chainlink': 'ETH',\n  'wrapped-bitcoin': 'ETH',\n  'uniswap': 'ETH',\n  'shiba-inu': 'ETH',\n  'aave': 'ETH',\n  'maker': 'ETH',\n  'the-graph': 'ETH',\n  'dai': 'ETH',\n  'pancakeswap-token': 'BNB',\n  'venus': 'BNB',\n  'trust-wallet-token': 'BNB',\n  'binance-usd': 'BNB',\n  'first-digital-usd': 'BNB',\n  'wrapped-bitcoin-bsc': 'BNB',\n  'wrapped-ethereum-bsc': 'BNB',\n  'baby-doge-coin': 'BNB',\n  'raydium': 'SOL',\n  'bonk': 'SOL',\n  'jupiter-exchange-solana': 'SOL',\n  'jito-governance-token': 'SOL',\n  'trader-joe': 'AVAX',\n  'benqi': 'AVAX',\n  'gmx': 'ARB',\n  'magic': 'ARB',\n  'optimism': 'OP',\n};\n\n// Maps token IDs to parent chain NAME for display purposes\nexport const TOKEN_PARENT_CHAIN: Record<string, string> = {\n  'tether': 'Ethereum',\n  'tether-bsc': 'BNB Smart Chain',\n  'tether-tron': 'TRON',\n  'usd-coin': 'Ethereum',\n  'usd-coin-bsc': 'BNB Smart Chain',\n  'usd-coin-tron': 'TRON',\n  'staked-ether': 'Ethereum',\n  'chainlink': 'Ethereum',\n  'wrapped-bitcoin': 'Ethereum',\n  'uniswap': 'Ethereum',\n  'shiba-inu': 'Ethereum',\n  'aave': 'Ethereum',\n  'maker': 'Ethereum',\n  'the-graph': 'Ethereum',\n  'dai': 'Ethereum',\n  'pancakeswap-token': 'BNB Smart Chain',\n  'venus': 'BNB Smart Chain',\n  'trust-wallet-token': 'BNB Smart Chain',\n  'binance-usd': 'BNB Smart Chain',\n  'first-digital-usd': 'BNB Smart Chain',\n  'wrapped-bitcoin-bsc': 'BNB Smart Chain',\n  'wrapped-ethereum-bsc': 'BNB Smart Chain',\n  'baby-doge-coin': 'BNB Smart Chain',\n  'raydium': 'Solana',\n  'bonk': 'Solana',\n  'jupiter-exchange-solana': 'Solana',\n  'jito-governance-token': 'Solana',\n  'trader-joe': 'Avalanche',\n  'benqi': 'Avalanche',\n  'gmx': 'Arbitrum',\n  'magic': 'Arbitrum',\n  'optimism': 'Optimism',\n};\n\n/**\n * Computes the set of chain symbols that should have their balances fetched\n * based on enabled asset IDs. This includes:\n * - Native assets (e.g., 'ethereum' -> 'ETH')\n * - Parent chains of enabled tokens (e.g., 'tether-tron' -> 'TRX')\n */\nexport function getEnabledChainSymbols(enabledAssetIds: Set<string>): Set<string> {\n  const chainSymbols = new Set<string>();\n  \n  Array.from(enabledAssetIds).forEach(assetId => {\n    // Check if it's a token with a parent chain\n    const parentSymbol = TOKEN_PARENT_CHAIN_SYMBOL[assetId];\n    if (parentSymbol) {\n      chainSymbols.add(parentSymbol);\n    } else {\n      // Check if it's a native asset\n      const nativeSymbol = COINGECKO_ID_TO_CHAIN_SYMBOL[assetId];\n      if (nativeSymbol) {\n        chainSymbols.add(nativeSymbol);\n      }\n    }\n  });\n  \n  return chainSymbols;\n}\n","path":null,"size_bytes":4215,"size_tokens":null},"client/src/components/ui/switch.tsx":{"content":"import * as React from \"react\"\nimport * as SwitchPrimitives from \"@radix-ui/react-switch\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst Switch = React.forwardRef<\n  React.ElementRef<typeof SwitchPrimitives.Root>,\n  React.ComponentPropsWithoutRef<typeof SwitchPrimitives.Root>\n>(({ className, ...props }, ref) => (\n  <SwitchPrimitives.Root\n    className={cn(\n      \"peer inline-flex h-6 w-11 shrink-0 cursor-pointer items-center rounded-full border-2 border-transparent transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 focus-visible:ring-offset-background disabled:cursor-not-allowed disabled:opacity-50 data-[state=checked]:bg-primary data-[state=unchecked]:bg-input\",\n      className\n    )}\n    {...props}\n    ref={ref}\n  >\n    <SwitchPrimitives.Thumb\n      className={cn(\n        \"pointer-events-none block h-5 w-5 rounded-full bg-background shadow-lg ring-0 transition-transform data-[state=checked]:translate-x-5 data-[state=unchecked]:translate-x-0\"\n      )}\n    />\n  </SwitchPrimitives.Root>\n))\nSwitch.displayName = SwitchPrimitives.Root.displayName\n\nexport { Switch }\n","path":null,"size_bytes":1139,"size_tokens":null},"client/src/components/back-button.tsx":{"content":"import { ArrowLeft } from \"lucide-react\";\nimport { Button } from \"@/components/ui/button\";\nimport { useLocation } from \"wouter\";\n\ninterface BackButtonProps {\n  fallbackPath?: string;\n  className?: string;\n}\n\nexport function BackButton({ fallbackPath = \"/\", className }: BackButtonProps) {\n  const [, setLocation] = useLocation();\n\n  const handleBack = () => {\n    if (window.history.length > 1) {\n      window.history.back();\n    } else {\n      setLocation(fallbackPath);\n    }\n  };\n\n  return (\n    <Button\n      variant=\"ghost\"\n      size=\"icon\"\n      onClick={handleBack}\n      className={className}\n      data-testid=\"button-back\"\n    >\n      <ArrowLeft className=\"h-5 w-5\" />\n    </Button>\n  );\n}\n","path":null,"size_bytes":701,"size_tokens":null},"client/src/components/ui/carousel.tsx":{"content":"import * as React from \"react\"\nimport useEmblaCarousel, {\n  type UseEmblaCarouselType,\n} from \"embla-carousel-react\"\nimport { ArrowLeft, ArrowRight } from \"lucide-react\"\n\nimport { cn } from \"@/lib/utils\"\nimport { Button } from \"@/components/ui/button\"\n\ntype CarouselApi = UseEmblaCarouselType[1]\ntype UseCarouselParameters = Parameters<typeof useEmblaCarousel>\ntype CarouselOptions = UseCarouselParameters[0]\ntype CarouselPlugin = UseCarouselParameters[1]\n\ntype CarouselProps = {\n  opts?: CarouselOptions\n  plugins?: CarouselPlugin\n  orientation?: \"horizontal\" | \"vertical\"\n  setApi?: (api: CarouselApi) => void\n}\n\ntype CarouselContextProps = {\n  carouselRef: ReturnType<typeof useEmblaCarousel>[0]\n  api: ReturnType<typeof useEmblaCarousel>[1]\n  scrollPrev: () => void\n  scrollNext: () => void\n  canScrollPrev: boolean\n  canScrollNext: boolean\n} & CarouselProps\n\nconst CarouselContext = React.createContext<CarouselContextProps | null>(null)\n\nfunction useCarousel() {\n  const context = React.useContext(CarouselContext)\n\n  if (!context) {\n    throw new Error(\"useCarousel must be used within a <Carousel />\")\n  }\n\n  return context\n}\n\nconst Carousel = React.forwardRef<\n  HTMLDivElement,\n  React.HTMLAttributes<HTMLDivElement> & CarouselProps\n>(\n  (\n    {\n      orientation = \"horizontal\",\n      opts,\n      setApi,\n      plugins,\n      className,\n      children,\n      ...props\n    },\n    ref\n  ) => {\n    const [carouselRef, api] = useEmblaCarousel(\n      {\n        ...opts,\n        axis: orientation === \"horizontal\" ? \"x\" : \"y\",\n      },\n      plugins\n    )\n    const [canScrollPrev, setCanScrollPrev] = React.useState(false)\n    const [canScrollNext, setCanScrollNext] = React.useState(false)\n\n    const onSelect = React.useCallback((api: CarouselApi) => {\n      if (!api) {\n        return\n      }\n\n      setCanScrollPrev(api.canScrollPrev())\n      setCanScrollNext(api.canScrollNext())\n    }, [])\n\n    const scrollPrev = React.useCallback(() => {\n      api?.scrollPrev()\n    }, [api])\n\n    const scrollNext = React.useCallback(() => {\n      api?.scrollNext()\n    }, [api])\n\n    const handleKeyDown = React.useCallback(\n      (event: React.KeyboardEvent<HTMLDivElement>) => {\n        if (event.key === \"ArrowLeft\") {\n          event.preventDefault()\n          scrollPrev()\n        } else if (event.key === \"ArrowRight\") {\n          event.preventDefault()\n          scrollNext()\n        }\n      },\n      [scrollPrev, scrollNext]\n    )\n\n    React.useEffect(() => {\n      if (!api || !setApi) {\n        return\n      }\n\n      setApi(api)\n    }, [api, setApi])\n\n    React.useEffect(() => {\n      if (!api) {\n        return\n      }\n\n      onSelect(api)\n      api.on(\"reInit\", onSelect)\n      api.on(\"select\", onSelect)\n\n      return () => {\n        api?.off(\"select\", onSelect)\n      }\n    }, [api, onSelect])\n\n    return (\n      <CarouselContext.Provider\n        value={{\n          carouselRef,\n          api: api,\n          opts,\n          orientation:\n            orientation || (opts?.axis === \"y\" ? \"vertical\" : \"horizontal\"),\n          scrollPrev,\n          scrollNext,\n          canScrollPrev,\n          canScrollNext,\n        }}\n      >\n        <div\n          ref={ref}\n          onKeyDownCapture={handleKeyDown}\n          className={cn(\"relative\", className)}\n          role=\"region\"\n          aria-roledescription=\"carousel\"\n          {...props}\n        >\n          {children}\n        </div>\n      </CarouselContext.Provider>\n    )\n  }\n)\nCarousel.displayName = \"Carousel\"\n\nconst CarouselContent = React.forwardRef<\n  HTMLDivElement,\n  React.HTMLAttributes<HTMLDivElement>\n>(({ className, ...props }, ref) => {\n  const { carouselRef, orientation } = useCarousel()\n\n  return (\n    <div ref={carouselRef} className=\"overflow-hidden\">\n      <div\n        ref={ref}\n        className={cn(\n          \"flex\",\n          orientation === \"horizontal\" ? \"-ml-4\" : \"-mt-4 flex-col\",\n          className\n        )}\n        {...props}\n      />\n    </div>\n  )\n})\nCarouselContent.displayName = \"CarouselContent\"\n\nconst CarouselItem = React.forwardRef<\n  HTMLDivElement,\n  React.HTMLAttributes<HTMLDivElement>\n>(({ className, ...props }, ref) => {\n  const { orientation } = useCarousel()\n\n  return (\n    <div\n      ref={ref}\n      role=\"group\"\n      aria-roledescription=\"slide\"\n      className={cn(\n        \"min-w-0 shrink-0 grow-0 basis-full\",\n        orientation === \"horizontal\" ? \"pl-4\" : \"pt-4\",\n        className\n      )}\n      {...props}\n    />\n  )\n})\nCarouselItem.displayName = \"CarouselItem\"\n\nconst CarouselPrevious = React.forwardRef<\n  HTMLButtonElement,\n  React.ComponentProps<typeof Button>\n>(({ className, variant = \"outline\", size = \"icon\", ...props }, ref) => {\n  const { orientation, scrollPrev, canScrollPrev } = useCarousel()\n\n  return (\n    <Button\n      ref={ref}\n      variant={variant}\n      size={size}\n      className={cn(\n        \"absolute  h-8 w-8 rounded-full\",\n        orientation === \"horizontal\"\n          ? \"-left-12 top-1/2 -translate-y-1/2\"\n          : \"-top-12 left-1/2 -translate-x-1/2 rotate-90\",\n        className\n      )}\n      disabled={!canScrollPrev}\n      onClick={scrollPrev}\n      {...props}\n    >\n      <ArrowLeft className=\"h-4 w-4\" />\n      <span className=\"sr-only\">Previous slide</span>\n    </Button>\n  )\n})\nCarouselPrevious.displayName = \"CarouselPrevious\"\n\nconst CarouselNext = React.forwardRef<\n  HTMLButtonElement,\n  React.ComponentProps<typeof Button>\n>(({ className, variant = \"outline\", size = \"icon\", ...props }, ref) => {\n  const { orientation, scrollNext, canScrollNext } = useCarousel()\n\n  return (\n    <Button\n      ref={ref}\n      variant={variant}\n      size={size}\n      className={cn(\n        \"absolute h-8 w-8 rounded-full\",\n        orientation === \"horizontal\"\n          ? \"-right-12 top-1/2 -translate-y-1/2\"\n          : \"-bottom-12 left-1/2 -translate-x-1/2 rotate-90\",\n        className\n      )}\n      disabled={!canScrollNext}\n      onClick={scrollNext}\n      {...props}\n    >\n      <ArrowRight className=\"h-4 w-4\" />\n      <span className=\"sr-only\">Next slide</span>\n    </Button>\n  )\n})\nCarouselNext.displayName = \"CarouselNext\"\n\nexport {\n  type CarouselApi,\n  Carousel,\n  CarouselContent,\n  CarouselItem,\n  CarouselPrevious,\n  CarouselNext,\n}\n","path":null,"size_bytes":6210,"size_tokens":null},"client/src/components/chain-icon.tsx":{"content":"import { Bitcoin, Coins } from \"lucide-react\";\nimport { \n  SiEthereum, \n  SiBinance, \n  SiPolygon,\n  SiSolana,\n  SiLitecoin,\n  SiDogecoin,\n  SiRipple,\n  SiCardano,\n  SiPolkadot,\n  SiTether,\n} from \"react-icons/si\";\n\ninterface ChainIconProps {\n  symbol: string;\n  iconColor?: string;\n  className?: string;\n  size?: \"sm\" | \"md\" | \"lg\";\n}\n\nconst sizeClasses = {\n  sm: \"h-5 w-5\",\n  md: \"h-8 w-8\",\n  lg: \"h-12 w-12\",\n};\n\n// Chain brand colors\nconst CHAIN_COLORS: Record<string, string> = {\n  BTC: \"#F7931A\",\n  ETH: \"#627EEA\",\n  BNB: \"#F3BA2F\",\n  MATIC: \"#8247E5\",\n  SOL: \"#14F195\",\n  AVAX: \"#E84142\",\n  ARB: \"#12AAFF\",\n  XRP: \"#23292F\",\n  DOGE: \"#C2A633\",\n  ADA: \"#0033AD\",\n  TRX: \"#FF0013\",\n  DOT: \"#E6007A\",\n  LTC: \"#345D9D\",\n  BCH: \"#8DC351\",\n  USDT: \"#26A17B\",\n  USDC: \"#2775CA\",\n  ATOM: \"#2E3148\",\n  OSMO: \"#750BBB\",\n  OP: \"#FF0420\",\n};\n\n// SVG icons for chains without react-icons support\nfunction AvaxIcon({ className, style }: { className: string; style?: React.CSSProperties }) {\n  return (\n    <svg className={className} style={style} viewBox=\"0 0 24 24\" fill=\"currentColor\">\n      <path d=\"M12 2L2 19.5h6.5L12 13l3.5 6.5H22L12 2z\"/>\n    </svg>\n  );\n}\n\nfunction ArbIcon({ className, style }: { className: string; style?: React.CSSProperties }) {\n  return (\n    <svg className={className} style={style} viewBox=\"0 0 24 24\" fill=\"currentColor\">\n      <path d=\"M12 2L3 21h4.5l4.5-9 4.5 9H21L12 2zm0 7l2.5 5h-5L12 9z\"/>\n    </svg>\n  );\n}\n\nfunction TronIcon({ className, style }: { className: string; style?: React.CSSProperties }) {\n  return (\n    <svg className={className} style={style} viewBox=\"0 0 24 24\" fill=\"currentColor\">\n      <path d=\"M12 2L3 8.5v7L12 22l9-6.5v-7L12 2zm0 2.5l6 4.3-6 8.2-6-8.2 6-4.3z\"/>\n    </svg>\n  );\n}\n\nfunction BchIcon({ className, style }: { className: string; style?: React.CSSProperties }) {\n  return (\n    <svg className={className} style={style} viewBox=\"0 0 24 24\" fill=\"currentColor\">\n      <path d=\"M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1 14.5v1.5h-2v-1.5c-1.5-.3-2.5-1.1-2.8-2.3l1.5-.5c.2.8.9 1.3 1.8 1.3.7 0 1.5-.3 1.5-1 0-.6-.5-.9-1.5-1.2-1.5-.4-3-1-3-2.8 0-1.3 1-2.3 2.5-2.5V6h2v1.5c1.2.2 2.1.9 2.5 2l-1.5.5c-.2-.6-.7-1-1.5-1-.7 0-1.2.3-1.2.8 0 .5.4.8 1.5 1.1 1.5.4 3 1 3 2.9 0 1.5-1.2 2.5-2.8 2.7z\"/>\n    </svg>\n  );\n}\n\nfunction CosmosIcon({ className, style }: { className: string; style?: React.CSSProperties }) {\n  return (\n    <svg className={className} style={style} viewBox=\"0 0 24 24\" fill=\"currentColor\">\n      <circle cx=\"12\" cy=\"12\" r=\"3\"/>\n      <ellipse cx=\"12\" cy=\"12\" rx=\"10\" ry=\"4\" fill=\"none\" stroke=\"currentColor\" strokeWidth=\"1.5\"/>\n      <ellipse cx=\"12\" cy=\"12\" rx=\"10\" ry=\"4\" fill=\"none\" stroke=\"currentColor\" strokeWidth=\"1.5\" transform=\"rotate(60 12 12)\"/>\n      <ellipse cx=\"12\" cy=\"12\" rx=\"10\" ry=\"4\" fill=\"none\" stroke=\"currentColor\" strokeWidth=\"1.5\" transform=\"rotate(120 12 12)\"/>\n    </svg>\n  );\n}\n\nfunction OptimismIcon({ className, style }: { className: string; style?: React.CSSProperties }) {\n  return (\n    <svg className={className} style={style} viewBox=\"0 0 24 24\" fill=\"currentColor\">\n      <circle cx=\"12\" cy=\"12\" r=\"10\"/>\n    </svg>\n  );\n}\n\nexport function ChainIcon({ symbol, iconColor, className = \"\", size = \"md\" }: ChainIconProps) {\n  const sizeClass = sizeClasses[size];\n  const upperSymbol = symbol.toUpperCase();\n  const color = iconColor || CHAIN_COLORS[upperSymbol] || \"#6B7280\";\n\n  const iconMap: Record<string, JSX.Element> = {\n    BTC: <Bitcoin className={`${sizeClass} ${className}`} style={{ color: CHAIN_COLORS.BTC }} />,\n    ETH: <SiEthereum className={`${sizeClass} ${className}`} style={{ color: CHAIN_COLORS.ETH }} />,\n    BNB: <SiBinance className={`${sizeClass} ${className}`} style={{ color: CHAIN_COLORS.BNB }} />,\n    MATIC: <SiPolygon className={`${sizeClass} ${className}`} style={{ color: CHAIN_COLORS.MATIC }} />,\n    SOL: <SiSolana className={`${sizeClass} ${className}`} style={{ color: CHAIN_COLORS.SOL }} />,\n    LTC: <SiLitecoin className={`${sizeClass} ${className}`} style={{ color: CHAIN_COLORS.LTC }} />,\n    DOGE: <SiDogecoin className={`${sizeClass} ${className}`} style={{ color: CHAIN_COLORS.DOGE }} />,\n    XRP: <SiRipple className={`${sizeClass} ${className}`} style={{ color: CHAIN_COLORS.XRP }} />,\n    ADA: <SiCardano className={`${sizeClass} ${className}`} style={{ color: CHAIN_COLORS.ADA }} />,\n    DOT: <SiPolkadot className={`${sizeClass} ${className}`} style={{ color: CHAIN_COLORS.DOT }} />,\n    USDT: <SiTether className={`${sizeClass} ${className}`} style={{ color: CHAIN_COLORS.USDT }} />,\n    AVAX: <AvaxIcon className={`${sizeClass} ${className}`} style={{ color: CHAIN_COLORS.AVAX }} />,\n    ARB: <ArbIcon className={`${sizeClass} ${className}`} style={{ color: CHAIN_COLORS.ARB }} />,\n    TRX: <TronIcon className={`${sizeClass} ${className}`} style={{ color: CHAIN_COLORS.TRX }} />,\n    BCH: <BchIcon className={`${sizeClass} ${className}`} style={{ color: CHAIN_COLORS.BCH }} />,\n    ATOM: <CosmosIcon className={`${sizeClass} ${className}`} style={{ color: CHAIN_COLORS.ATOM }} />,\n    OSMO: <CosmosIcon className={`${sizeClass} ${className}`} style={{ color: CHAIN_COLORS.OSMO }} />,\n    OP: <OptimismIcon className={`${sizeClass} ${className}`} style={{ color: CHAIN_COLORS.OP }} />,\n  };\n\n  if (iconMap[upperSymbol]) {\n    return iconMap[upperSymbol];\n  }\n\n  // Fallback to colored circle with first letter\n  return (\n    <div \n      className={`flex items-center justify-center rounded-full ${sizeClass} ${className}`}\n      style={{ backgroundColor: color }}\n    >\n      <span className=\"text-white font-bold text-xs\">{upperSymbol.slice(0, 2)}</span>\n    </div>\n  );\n}\n","path":null,"size_bytes":5652,"size_tokens":null},"client/src/components/ui/button.tsx":{"content":"import * as React from \"react\"\nimport { Slot } from \"@radix-ui/react-slot\"\nimport { cva, type VariantProps } from \"class-variance-authority\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst buttonVariants = cva(\n  \"inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0\" +\n  \" hover-elevate active-elevate-2\",\n  {\n    variants: {\n      variant: {\n        default:\n          \"bg-primary text-primary-foreground border border-primary-border\",\n        destructive:\n          \"bg-destructive text-destructive-foreground border border-destructive-border\",\n        outline:\n          // Shows the background color of whatever card / sidebar / accent background it is inside of.\n          // Inherits the current text color.\n          \" border [border-color:var(--button-outline)]  shadow-xs active:shadow-none \",\n        secondary: \"border bg-secondary text-secondary-foreground border border-secondary-border \",\n        // Add a transparent border so that when someone toggles a border on later, it doesn't shift layout/size.\n        ghost: \"border border-transparent\",\n      },\n      // Heights are set as \"min\" heights, because sometimes Ai will place large amount of content\n      // inside buttons. With a min-height they will look appropriate with small amounts of content,\n      // but will expand to fit large amounts of content.\n      size: {\n        default: \"min-h-9 px-4 py-2\",\n        sm: \"min-h-8 rounded-md px-3 text-xs\",\n        lg: \"min-h-10 rounded-md px-8\",\n        icon: \"h-9 w-9\",\n      },\n    },\n    defaultVariants: {\n      variant: \"default\",\n      size: \"default\",\n    },\n  },\n)\n\nexport interface ButtonProps\n  extends React.ButtonHTMLAttributes<HTMLButtonElement>,\n    VariantProps<typeof buttonVariants> {\n  asChild?: boolean\n}\n\nconst Button = React.forwardRef<HTMLButtonElement, ButtonProps>(\n  ({ className, variant, size, asChild = false, ...props }, ref) => {\n    const Comp = asChild ? Slot : \"button\"\n    return (\n      <Comp\n        className={cn(buttonVariants({ variant, size, className }))}\n        ref={ref}\n        {...props}\n      />\n    )\n  },\n)\nButton.displayName = \"Button\"\n\nexport { Button, buttonVariants }\n","path":null,"size_bytes":2359,"size_tokens":null},"client/src/pages/chains.tsx":{"content":"import { useState } from \"react\";\nimport { \n  Plus, \n  ExternalLink, \n  Copy,\n  Layers,\n  Coins,\n  Trash2,\n  Loader2,\n  AlertCircle,\n  Edit2,\n} from \"lucide-react\";\nimport { BackButton } from \"@/components/back-button\";\nimport { Card, CardContent, CardHeader, CardTitle, CardDescription } from \"@/components/ui/card\";\nimport { Button } from \"@/components/ui/button\";\nimport { Input } from \"@/components/ui/input\";\nimport { Label } from \"@/components/ui/label\";\nimport { Badge } from \"@/components/ui/badge\";\nimport { Skeleton } from \"@/components/ui/skeleton\";\nimport { Tabs, TabsContent, TabsList, TabsTrigger } from \"@/components/ui/tabs\";\nimport {\n  Dialog,\n  DialogContent,\n  DialogDescription,\n  DialogHeader,\n  DialogTitle,\n  DialogTrigger,\n  DialogFooter,\n} from \"@/components/ui/dialog\";\nimport {\n  Select,\n  SelectContent,\n  SelectItem,\n  SelectTrigger,\n  SelectValue,\n} from \"@/components/ui/select\";\nimport { useWallet } from \"@/lib/wallet-context\";\nimport { useToast } from \"@/hooks/use-toast\";\nimport { ChainIcon } from \"@/components/chain-icon\";\nimport { SeedVerificationModal } from \"@/components/seed-verification-modal\";\nimport { HardwareStatusCard } from \"@/components/hardware-status\";\nimport { getTokenInfo } from \"@/lib/blockchain\";\nimport type { Chain, Token, Wallet } from \"@shared/schema\";\nimport type { CustomToken } from \"@/lib/client-storage\";\n\nfunction ChainCard({ chain, wallet, onRename }: { chain: Chain; wallet?: Wallet; onRename?: (walletId: string, newLabel: string) => Promise<void> }) {\n  const { toast } = useToast();\n  const [showRenameDialog, setShowRenameDialog] = useState(false);\n  const [newLabel, setNewLabel] = useState(wallet?.label || chain.name);\n  const [isRenaming, setIsRenaming] = useState(false);\n\n  const copyAddress = () => {\n    if (wallet) {\n      navigator.clipboard.writeText(wallet.address);\n      toast({\n        title: \"Address Copied\",\n        description: \"Wallet address copied to clipboard.\",\n      });\n    }\n  };\n\n  const handleRename = async () => {\n    if (!wallet || !onRename || !newLabel.trim()) return;\n    \n    setIsRenaming(true);\n    try {\n      await onRename(wallet.id, newLabel.trim());\n      toast({\n        title: \"Wallet Renamed\",\n        description: `Wallet renamed to \"${newLabel.trim()}\"`,\n      });\n      setShowRenameDialog(false);\n    } catch (error) {\n      toast({\n        title: \"Error\",\n        description: \"Failed to rename wallet\",\n        variant: \"destructive\",\n      });\n    } finally {\n      setIsRenaming(false);\n    }\n  };\n\n  return (\n    <Card className=\"overflow-hidden\" data-testid={`card-chain-${chain.symbol}`}>\n      <CardContent className=\"p-4\">\n        <div className=\"flex items-start justify-between\">\n          <div className=\"flex items-center gap-3\">\n            <ChainIcon symbol={chain.symbol} iconColor={chain.iconColor} size=\"lg\" />\n            <div>\n              <div className=\"flex items-center gap-1\">\n                <h3 className=\"font-semibold\">{wallet?.label || chain.name}</h3>\n                {wallet && onRename && (\n                  <Button \n                    size=\"icon\" \n                    variant=\"ghost\" \n                    className=\"h-6 w-6\"\n                    onClick={() => {\n                      setNewLabel(wallet.label || chain.name);\n                      setShowRenameDialog(true);\n                    }}\n                    data-testid={`button-rename-${chain.symbol}`}\n                  >\n                    <Edit2 className=\"h-3 w-3\" />\n                  </Button>\n                )}\n              </div>\n              <p className=\"text-sm text-muted-foreground\">{chain.symbol}</p>\n            </div>\n          </div>\n          <div className=\"flex gap-1\">\n            {chain.isDefault && (\n              <Badge variant=\"secondary\" className=\"text-xs\">Default</Badge>\n            )}\n          </div>\n        </div>\n\n        <div className=\"mt-4 space-y-2 text-sm\">\n          <div className=\"flex justify-between\">\n            <span className=\"text-muted-foreground\">Chain ID</span>\n            <span className=\"font-mono\">{chain.chainId}</span>\n          </div>\n          <div className=\"flex justify-between\">\n            <span className=\"text-muted-foreground\">Decimals</span>\n            <span>{chain.decimals}</span>\n          </div>\n          {wallet && (\n            <div className=\"flex items-center justify-between gap-2\">\n              <span className=\"text-muted-foreground\">Address</span>\n              <div className=\"flex items-center gap-1\">\n                <code className=\"text-xs font-mono\">\n                  {wallet.address.slice(0, 6)}...{wallet.address.slice(-4)}\n                </code>\n                <Button \n                  size=\"icon\" \n                  variant=\"ghost\" \n                  className=\"h-6 w-6\"\n                  onClick={copyAddress}\n                >\n                  <Copy className=\"h-3 w-3\" />\n                </Button>\n              </div>\n            </div>\n          )}\n        </div>\n\n        {chain.blockExplorer && (\n          <Button\n            variant=\"outline\"\n            size=\"sm\"\n            className=\"mt-4 w-full\"\n            onClick={() => window.open(chain.blockExplorer, \"_blank\")}\n            data-testid={`button-explorer-${chain.symbol}`}\n          >\n            <ExternalLink className=\"mr-2 h-4 w-4\" />\n            Block Explorer\n          </Button>\n        )}\n      </CardContent>\n\n      {/* Rename Dialog */}\n      <Dialog open={showRenameDialog} onOpenChange={setShowRenameDialog}>\n        <DialogContent className=\"sm:max-w-md\">\n          <DialogHeader>\n            <DialogTitle>Rename Wallet</DialogTitle>\n            <DialogDescription>\n              Give your {chain.name} wallet a custom name\n            </DialogDescription>\n          </DialogHeader>\n          <div className=\"py-4\">\n            <Label htmlFor=\"wallet-name\">Wallet Name</Label>\n            <Input\n              id=\"wallet-name\"\n              value={newLabel}\n              onChange={(e) => setNewLabel(e.target.value)}\n              placeholder=\"My Wallet\"\n              className=\"mt-2\"\n              data-testid=\"input-rename-wallet\"\n            />\n          </div>\n          <DialogFooter className=\"gap-2 sm:gap-0\">\n            <Button variant=\"outline\" onClick={() => setShowRenameDialog(false)}>\n              Cancel\n            </Button>\n            <Button \n              onClick={handleRename} \n              disabled={isRenaming || !newLabel.trim()}\n              data-testid=\"button-confirm-rename\"\n            >\n              {isRenaming ? (\n                <>\n                  <Loader2 className=\"mr-2 h-4 w-4 animate-spin\" />\n                  Saving...\n                </>\n              ) : (\n                \"Save\"\n              )}\n            </Button>\n          </DialogFooter>\n        </DialogContent>\n      </Dialog>\n    </Card>\n  );\n}\n\nfunction AddChainDialog({ addCustomChain }: { addCustomChain: (chain: Omit<import(\"@/lib/client-storage\").CustomChain, 'id' | 'addedAt'>) => Promise<import(\"@/lib/client-storage\").CustomChain> }) {\n  const { toast } = useToast();\n  const [open, setOpen] = useState(false);\n  const [isAdding, setIsAdding] = useState(false);\n  const [formData, setFormData] = useState({\n    name: \"\",\n    symbol: \"\",\n    rpcUrl: \"\",\n    chainId: \"\",\n    blockExplorer: \"\",\n    decimals: \"18\",\n  });\n\n  const resetForm = () => {\n    setFormData({\n      name: \"\",\n      symbol: \"\",\n      rpcUrl: \"\",\n      chainId: \"\",\n      blockExplorer: \"\",\n      decimals: \"18\",\n    });\n  };\n\n  const handleSubmit = async (e: React.FormEvent) => {\n    e.preventDefault();\n    setIsAdding(true);\n    try {\n      await addCustomChain({\n        name: formData.name,\n        symbol: formData.symbol.toUpperCase(),\n        rpcUrl: formData.rpcUrl,\n        chainId: parseInt(formData.chainId),\n        blockExplorer: formData.blockExplorer || undefined,\n        decimals: parseInt(formData.decimals),\n        iconColor: \"#6B7280\",\n      });\n      toast({\n        title: \"Network Added\",\n        description: `${formData.name} has been added successfully.`,\n      });\n      setOpen(false);\n      resetForm();\n    } catch (error) {\n      toast({\n        title: \"Error\",\n        description: \"Failed to add network. Please try again.\",\n        variant: \"destructive\",\n      });\n    } finally {\n      setIsAdding(false);\n    }\n  };\n\n  return (\n    <Dialog open={open} onOpenChange={setOpen}>\n      <DialogTrigger asChild>\n        <Button data-testid=\"button-add-chain\">\n          <Plus className=\"mr-2 h-4 w-4\" />\n          Add Network\n        </Button>\n      </DialogTrigger>\n      <DialogContent className=\"sm:max-w-md\">\n        <DialogHeader>\n          <DialogTitle>Add Custom Network</DialogTitle>\n          <DialogDescription>\n            Add a new blockchain network to your wallet\n          </DialogDescription>\n        </DialogHeader>\n        <form onSubmit={handleSubmit} className=\"space-y-4\">\n          <div className=\"space-y-2\">\n            <Label htmlFor=\"name\">Network Name</Label>\n            <Input\n              id=\"name\"\n              placeholder=\"Ethereum Mainnet\"\n              value={formData.name}\n              onChange={(e) => setFormData({ ...formData, name: e.target.value })}\n              required\n              data-testid=\"input-chain-name\"\n            />\n          </div>\n          <div className=\"grid grid-cols-2 gap-4\">\n            <div className=\"space-y-2\">\n              <Label htmlFor=\"symbol\">Currency Symbol</Label>\n              <Input\n                id=\"symbol\"\n                placeholder=\"ETH\"\n                value={formData.symbol}\n                onChange={(e) => setFormData({ ...formData, symbol: e.target.value.toUpperCase() })}\n                required\n                data-testid=\"input-chain-symbol\"\n              />\n            </div>\n            <div className=\"space-y-2\">\n              <Label htmlFor=\"chainId\">Chain ID</Label>\n              <Input\n                id=\"chainId\"\n                type=\"number\"\n                placeholder=\"1\"\n                value={formData.chainId}\n                onChange={(e) => setFormData({ ...formData, chainId: e.target.value })}\n                required\n                data-testid=\"input-chain-id\"\n              />\n            </div>\n          </div>\n          <div className=\"space-y-2\">\n            <Label htmlFor=\"rpcUrl\">RPC URL</Label>\n            <Input\n              id=\"rpcUrl\"\n              placeholder=\"https://mainnet.infura.io/v3/...\"\n              value={formData.rpcUrl}\n              onChange={(e) => setFormData({ ...formData, rpcUrl: e.target.value })}\n              required\n              data-testid=\"input-chain-rpc\"\n            />\n          </div>\n          <div className=\"space-y-2\">\n            <Label htmlFor=\"blockExplorer\">Block Explorer URL (Optional)</Label>\n            <Input\n              id=\"blockExplorer\"\n              placeholder=\"https://etherscan.io\"\n              value={formData.blockExplorer}\n              onChange={(e) => setFormData({ ...formData, blockExplorer: e.target.value })}\n              data-testid=\"input-chain-explorer\"\n            />\n          </div>\n          <div className=\"space-y-2\">\n            <Label htmlFor=\"decimals\">Decimals</Label>\n            <Input\n              id=\"decimals\"\n              type=\"number\"\n              placeholder=\"18\"\n              value={formData.decimals}\n              onChange={(e) => setFormData({ ...formData, decimals: e.target.value })}\n              required\n              data-testid=\"input-chain-decimals\"\n            />\n          </div>\n          <DialogFooter>\n            <Button type=\"button\" variant=\"outline\" onClick={() => setOpen(false)}>\n              Cancel\n            </Button>\n            <Button type=\"submit\" disabled={isAdding} data-testid=\"button-submit-chain\">\n              {isAdding ? \"Adding...\" : \"Add Network\"}\n            </Button>\n          </DialogFooter>\n        </form>\n      </DialogContent>\n    </Dialog>\n  );\n}\n\nconst SUPPORTED_TOKEN_CHAINS = [\n  { id: 'ETH', name: 'Ethereum (ERC-20)', evmChainId: 1, rpcUrl: 'https://eth.llamarpc.com', type: 'evm' as const },\n  { id: 'BNB', name: 'BNB Chain (BEP-20)', evmChainId: 56, rpcUrl: 'https://bsc-dataseed.binance.org', type: 'evm' as const },\n  { id: 'MATIC', name: 'Polygon', evmChainId: 137, rpcUrl: 'https://polygon-rpc.com', type: 'evm' as const },\n  { id: 'ARB', name: 'Arbitrum', evmChainId: 42161, rpcUrl: 'https://arb1.arbitrum.io/rpc', type: 'evm' as const },\n  { id: 'TRX', name: 'TRON (TRC-20)', evmChainId: 0, rpcUrl: '', type: 'tron' as const },\n];\n\ninterface TokenChainOption {\n  id: string;\n  name: string;\n  evmChainId: number;\n  rpcUrl: string;\n  type: 'evm' | 'tron';\n  isCustom?: boolean;\n}\n\nfunction AddTokenDialog({ addCustomToken, customChains }: { \n  addCustomToken: (token: Omit<CustomToken, 'id' | 'addedAt'>) => Promise<CustomToken>;\n  customChains: import(\"@/lib/client-storage\").CustomChain[];\n}) {\n  const { toast } = useToast();\n  const [open, setOpen] = useState(false);\n  const [selectedChain, setSelectedChain] = useState(\"\");\n  const [contractAddress, setContractAddress] = useState(\"\");\n  const [tokenInfo, setTokenInfo] = useState<{ name: string; symbol: string; decimals: number } | null>(null);\n  const [isFetchingInfo, setIsFetchingInfo] = useState(false);\n  const [fetchError, setFetchError] = useState(\"\");\n  const [isAdding, setIsAdding] = useState(false);\n  const [manualName, setManualName] = useState(\"\");\n  const [manualSymbol, setManualSymbol] = useState(\"\");\n  const [manualDecimals, setManualDecimals] = useState(\"18\");\n\n  // Merge default chains with custom chains\n  const allTokenChains: TokenChainOption[] = [\n    ...SUPPORTED_TOKEN_CHAINS,\n    ...customChains.map(c => ({\n      id: c.id,\n      name: `${c.name} (Custom)`,\n      evmChainId: c.chainId,\n      rpcUrl: c.rpcUrl,\n      type: 'evm' as const,\n      isCustom: true,\n    })),\n  ];\n\n  const selectedChainData = allTokenChains.find(c => c.id === selectedChain);\n  const isTronChain = selectedChainData?.type === 'tron';\n\n  const handleChainChange = (chainId: string) => {\n    setSelectedChain(chainId);\n    setTokenInfo(null);\n    setFetchError(\"\");\n    setManualName(\"\");\n    setManualSymbol(\"\");\n    setManualDecimals(\"18\");\n  };\n\n  const handleContractAddressChange = (address: string) => {\n    setContractAddress(address);\n    setTokenInfo(null);\n    setFetchError(\"\");\n  };\n\n  const fetchTokenInfoHandler = async () => {\n    if (!selectedChain || !contractAddress) return;\n    \n    const chain = allTokenChains.find(c => c.id === selectedChain);\n    if (!chain) return;\n\n    if (chain.type === 'tron') {\n      setFetchError(\"TRON tokens require manual entry. Please fill in the token details below.\");\n      return;\n    }\n\n    setIsFetchingInfo(true);\n    setFetchError(\"\");\n\n    try {\n      const info = await getTokenInfo(contractAddress, chain.rpcUrl, chain.evmChainId);\n      if (info) {\n        setTokenInfo(info);\n      } else {\n        setFetchError(\"Could not fetch token info. Please verify the contract address.\");\n      }\n    } catch (error) {\n      setFetchError(\"Failed to fetch token info. Please check the address.\");\n    } finally {\n      setIsFetchingInfo(false);\n    }\n  };\n\n  const canAddToken = () => {\n    if (!selectedChain || !contractAddress) return false;\n    if (isTronChain) {\n      return manualName.trim() && manualSymbol.trim() && manualDecimals;\n    }\n    return !!tokenInfo;\n  };\n\n  const handleAddToken = async () => {\n    if (!selectedChain || !contractAddress) return;\n\n    const chain = allTokenChains.find(c => c.id === selectedChain);\n    if (!chain) return;\n\n    const tokenData = isTronChain\n      ? { name: manualName.trim(), symbol: manualSymbol.trim().toUpperCase(), decimals: parseInt(manualDecimals) || 18 }\n      : tokenInfo;\n\n    if (!tokenData) return;\n\n    setIsAdding(true);\n    try {\n      await addCustomToken({\n        chainId: chain.id,\n        chainType: chain.type,\n        contractAddress: contractAddress.trim(),\n        name: tokenData.name,\n        symbol: tokenData.symbol,\n        decimals: tokenData.decimals,\n        evmChainId: chain.evmChainId,\n        rpcUrl: chain.rpcUrl,\n      });\n\n      toast({\n        title: \"Token Added\",\n        description: `${tokenData.name} has been added successfully.`,\n      });\n\n      resetDialog();\n      setOpen(false);\n    } catch (error) {\n      toast({\n        title: \"Error\",\n        description: \"Failed to add token. Please try again.\",\n        variant: \"destructive\",\n      });\n    } finally {\n      setIsAdding(false);\n    }\n  };\n\n  const resetDialog = () => {\n    setSelectedChain(\"\");\n    setContractAddress(\"\");\n    setTokenInfo(null);\n    setFetchError(\"\");\n    setManualName(\"\");\n    setManualSymbol(\"\");\n    setManualDecimals(\"18\");\n  };\n\n  return (\n    <Dialog open={open} onOpenChange={(isOpen) => {\n      setOpen(isOpen);\n      if (!isOpen) resetDialog();\n    }}>\n      <DialogTrigger asChild>\n        <Button variant=\"outline\" data-testid=\"button-add-token\">\n          <Plus className=\"mr-2 h-4 w-4\" />\n          Add Token\n        </Button>\n      </DialogTrigger>\n      <DialogContent className=\"sm:max-w-md\">\n        <DialogHeader>\n          <DialogTitle>Add Custom Token</DialogTitle>\n          <DialogDescription>\n            Add an ERC-20, BEP-20, or TRC-20 token by entering its contract address.\n          </DialogDescription>\n        </DialogHeader>\n        <div className=\"space-y-4 py-4\">\n          <div className=\"space-y-2\">\n            <Label htmlFor=\"chain\">Blockchain Network</Label>\n            <Select value={selectedChain} onValueChange={handleChainChange}>\n              <SelectTrigger id=\"chain\" data-testid=\"select-token-chain\">\n                <SelectValue placeholder=\"Select a network\" />\n              </SelectTrigger>\n              <SelectContent>\n                {allTokenChains.map((chain) => (\n                  <SelectItem key={chain.id} value={chain.id}>\n                    {chain.name}\n                  </SelectItem>\n                ))}\n              </SelectContent>\n            </Select>\n          </div>\n          <div className=\"space-y-2\">\n            <Label htmlFor=\"contract\">Contract Address</Label>\n            <div className=\"flex gap-2\">\n              <Input\n                id=\"contract\"\n                placeholder={isTronChain ? \"T...\" : \"0x...\"}\n                value={contractAddress}\n                onChange={(e) => handleContractAddressChange(e.target.value)}\n                className=\"font-mono\"\n                data-testid=\"input-token-contract\"\n              />\n              {!isTronChain && (\n                <Button\n                  variant=\"outline\"\n                  onClick={fetchTokenInfoHandler}\n                  disabled={!selectedChain || !contractAddress || isFetchingInfo}\n                  data-testid=\"button-fetch-info\"\n                >\n                  {isFetchingInfo ? (\n                    <Loader2 className=\"h-4 w-4 animate-spin\" />\n                  ) : (\n                    \"Fetch\"\n                  )}\n                </Button>\n              )}\n            </div>\n          </div>\n          {fetchError && (\n            <div className=\"flex items-center gap-2 text-sm text-amber-600 dark:text-amber-400\">\n              <AlertCircle className=\"h-4 w-4\" />\n              {fetchError}\n            </div>\n          )}\n          {isTronChain && selectedChain && (\n            <div className=\"space-y-3 rounded-md border p-3 bg-muted/50\">\n              <p className=\"text-sm text-muted-foreground\">Enter token details manually for TRC-20 tokens:</p>\n              <div className=\"space-y-2\">\n                <Label htmlFor=\"manualName\">Token Name</Label>\n                <Input\n                  id=\"manualName\"\n                  placeholder=\"e.g., Tether USD\"\n                  value={manualName}\n                  onChange={(e) => setManualName(e.target.value)}\n                  data-testid=\"input-manual-name\"\n                />\n              </div>\n              <div className=\"space-y-2\">\n                <Label htmlFor=\"manualSymbol\">Token Symbol</Label>\n                <Input\n                  id=\"manualSymbol\"\n                  placeholder=\"e.g., USDT\"\n                  value={manualSymbol}\n                  onChange={(e) => setManualSymbol(e.target.value)}\n                  data-testid=\"input-manual-symbol\"\n                />\n              </div>\n              <div className=\"space-y-2\">\n                <Label htmlFor=\"manualDecimals\">Decimals</Label>\n                <Input\n                  id=\"manualDecimals\"\n                  type=\"number\"\n                  min=\"0\"\n                  max=\"18\"\n                  placeholder=\"18\"\n                  value={manualDecimals}\n                  onChange={(e) => setManualDecimals(e.target.value)}\n                  data-testid=\"input-manual-decimals\"\n                />\n              </div>\n            </div>\n          )}\n          {tokenInfo && !isTronChain && (\n            <div className=\"rounded-md border p-3 space-y-2 bg-muted/50\">\n              <div className=\"flex justify-between\">\n                <span className=\"text-sm text-muted-foreground\">Name:</span>\n                <span className=\"font-medium\">{tokenInfo.name}</span>\n              </div>\n              <div className=\"flex justify-between\">\n                <span className=\"text-sm text-muted-foreground\">Symbol:</span>\n                <span className=\"font-medium\">{tokenInfo.symbol}</span>\n              </div>\n              <div className=\"flex justify-between\">\n                <span className=\"text-sm text-muted-foreground\">Decimals:</span>\n                <span className=\"font-medium\">{tokenInfo.decimals}</span>\n              </div>\n            </div>\n          )}\n        </div>\n        <DialogFooter>\n          <Button variant=\"outline\" onClick={() => { resetDialog(); setOpen(false); }}>\n            Cancel\n          </Button>\n          <Button\n            onClick={handleAddToken}\n            disabled={!canAddToken() || isAdding}\n            data-testid=\"button-submit-token\"\n          >\n            {isAdding ? (\n              <Loader2 className=\"mr-2 h-4 w-4 animate-spin\" />\n            ) : null}\n            Add Token\n          </Button>\n        </DialogFooter>\n      </DialogContent>\n    </Dialog>\n  );\n}\n\nfunction CustomTokenCard({ token, onRemove }: { token: CustomToken; onRemove: (id: string) => void }) {\n  const chain = SUPPORTED_TOKEN_CHAINS.find(c => c.id === token.chainId);\n  \n  return (\n    <Card data-testid={`card-token-${token.symbol}`}>\n      <CardContent className=\"p-4\">\n        <div className=\"flex items-start justify-between\">\n          <div className=\"flex items-center gap-3\">\n            <div \n              className=\"flex h-10 w-10 items-center justify-center rounded-full bg-primary/10\"\n            >\n              <Coins className=\"h-5 w-5 text-primary\" />\n            </div>\n            <div>\n              <h3 className=\"font-semibold\">{token.name}</h3>\n              <p className=\"text-sm text-muted-foreground\">{token.symbol}</p>\n            </div>\n          </div>\n          <div className=\"flex items-center gap-2\">\n            {chain && (\n              <Badge variant=\"outline\" className=\"text-xs\">\n                {chain.name.split(' ')[0]}\n              </Badge>\n            )}\n            <Button\n              variant=\"ghost\"\n              size=\"icon\"\n              onClick={() => onRemove(token.id)}\n              className=\"h-8 w-8 text-red-600 hover:text-red-700 hover:bg-red-100 dark:text-red-400 dark:hover:bg-red-900/20\"\n              data-testid={`button-remove-token-${token.id}`}\n            >\n              <Trash2 className=\"h-4 w-4\" />\n            </Button>\n          </div>\n        </div>\n\n        <div className=\"mt-4 space-y-2 text-sm\">\n          <div className=\"flex justify-between\">\n            <span className=\"text-muted-foreground\">Contract</span>\n            <code className=\"text-xs font-mono\">\n              {token.contractAddress.slice(0, 6)}...{token.contractAddress.slice(-4)}\n            </code>\n          </div>\n          <div className=\"flex justify-between\">\n            <span className=\"text-muted-foreground\">Decimals</span>\n            <span>{token.decimals}</span>\n          </div>\n          <div className=\"flex justify-between\">\n            <span className=\"text-muted-foreground\">Type</span>\n            <span className=\"uppercase text-xs\">{token.chainType}</span>\n          </div>\n        </div>\n      </CardContent>\n    </Card>\n  );\n}\n\nfunction AddNetworkCard({ chain, onClick }: { chain: Chain; onClick: () => void }) {\n  return (\n    <Card \n      className=\"cursor-pointer hover-elevate active-elevate-2 transition-all\" \n      onClick={onClick}\n      data-testid={`card-add-network-${chain.symbol}`}\n    >\n      <CardContent className=\"flex flex-col items-center justify-center p-6 text-center\">\n        <ChainIcon symbol={chain.symbol} iconColor={chain.iconColor} size=\"lg\" />\n        <h3 className=\"mt-3 font-semibold\">{chain.name}</h3>\n        <p className=\"text-xs text-muted-foreground mt-1\">Tap to add</p>\n      </CardContent>\n    </Card>\n  );\n}\n\nexport default function Chains() {\n  const { \n    wallets, \n    isUnlocked, \n    chains, \n    customTokens, \n    addCustomToken, \n    removeCustomToken, \n    addCustomChain, \n    customChains,\n    pendingAddChain,\n    setPendingAddChain,\n    walletMode,\n    renameWallet,\n  } = useWallet();\n  const hasWallet = wallets.length > 0;\n  const [activeTab, setActiveTab] = useState(\"chains\");\n  const [showVerificationModal, setShowVerificationModal] = useState(false);\n\n  // Separate chains into active (has wallet) and available (no wallet yet)\n  const activeChains = chains.filter(chain => wallets.some(w => w.chainId === chain.id));\n  const availableChains = chains.filter(chain => !wallets.some(w => w.chainId === chain.id));\n\n  const handleAddNetwork = (chain: Chain) => {\n    // For soft wallets, require seed verification\n    if (walletMode === \"soft_wallet\") {\n      setPendingAddChain({ chainId: chain.id, chainName: chain.name });\n      setShowVerificationModal(true);\n    }\n  };\n\n  if (!hasWallet || !isUnlocked) {\n    return (\n      <div className=\"p-6\">\n        <h1 className=\"mb-6 text-3xl font-bold\">Chains & Tokens</h1>\n        <HardwareStatusCard />\n      </div>\n    );\n  }\n\n  return (\n    <div className=\"p-6\">\n      <div className=\"mb-6 flex flex-wrap items-center justify-between gap-4\">\n        <div className=\"flex items-center gap-3\">\n          <BackButton />\n          <h1 className=\"text-3xl font-bold\">Chains & Tokens</h1>\n        </div>\n        <div className=\"flex gap-2\">\n          <AddTokenDialog addCustomToken={addCustomToken} customChains={customChains} />\n          <AddChainDialog addCustomChain={addCustomChain} />\n        </div>\n      </div>\n\n      <Tabs value={activeTab} onValueChange={setActiveTab}>\n        <TabsList className=\"mb-6\">\n          <TabsTrigger value=\"chains\" data-testid=\"tab-chains\">\n            <Layers className=\"mr-2 h-4 w-4\" />\n            Networks ({activeChains.length})\n          </TabsTrigger>\n          <TabsTrigger value=\"tokens\" data-testid=\"tab-tokens\">\n            <Coins className=\"mr-2 h-4 w-4\" />\n            Tokens ({customTokens.length})\n          </TabsTrigger>\n        </TabsList>\n\n        <TabsContent value=\"chains\" className=\"space-y-8\">\n          {/* Your Chains Section */}\n          <div>\n            <h2 className=\"text-lg font-semibold mb-2\">Your Chains</h2>\n            <p className=\"text-sm text-muted-foreground mb-4\">\n              {activeChains.length} network{activeChains.length !== 1 ? 's' : ''} active\n            </p>\n            {activeChains.length > 0 ? (\n              <div className=\"grid gap-4 sm:grid-cols-2 lg:grid-cols-3\">\n                {activeChains.map((chain) => {\n                  const wallet = wallets.find((w) => w.chainId === chain.id);\n                  return <ChainCard key={chain.id} chain={chain} wallet={wallet} onRename={renameWallet} />;\n                })}\n              </div>\n            ) : (\n              <Card>\n                <CardContent className=\"py-8 text-center\">\n                  <p className=\"text-muted-foreground\">No active networks. Add one below.</p>\n                </CardContent>\n              </Card>\n            )}\n          </div>\n\n          {/* Add Networks Section */}\n          {availableChains.length > 0 && (\n            <div>\n              <h2 className=\"text-lg font-semibold mb-2\">Add Networks</h2>\n              <p className=\"text-sm text-muted-foreground mb-4\">\n                {availableChains.length} available\n              </p>\n              <div className=\"grid gap-4 grid-cols-2 sm:grid-cols-3 lg:grid-cols-4\">\n                {availableChains.map((chain) => (\n                  <AddNetworkCard \n                    key={chain.id} \n                    chain={chain} \n                    onClick={() => handleAddNetwork(chain)}\n                  />\n                ))}\n              </div>\n            </div>\n          )}\n        </TabsContent>\n\n        <TabsContent value=\"tokens\">\n          {customTokens.length === 0 ? (\n            <Card>\n              <CardContent className=\"flex flex-col items-center justify-center py-12 text-center\">\n                <Coins className=\"h-12 w-12 text-muted-foreground/50 mb-4\" />\n                <h3 className=\"text-lg font-semibold mb-2\">No Custom Tokens</h3>\n                <p className=\"text-sm text-muted-foreground mb-4\">\n                  Add custom ERC-20, BEP-20, or TRC-20 tokens to track\n                </p>\n                <AddTokenDialog addCustomToken={addCustomToken} customChains={customChains} />\n              </CardContent>\n            </Card>\n          ) : (\n            <div className=\"grid gap-4 sm:grid-cols-2 lg:grid-cols-3\">\n              {customTokens.map((token) => (\n                <CustomTokenCard key={token.id} token={token} onRemove={removeCustomToken} />\n              ))}\n            </div>\n          )}\n        </TabsContent>\n      </Tabs>\n\n      {/* Seed Verification Modal */}\n      <SeedVerificationModal \n        open={showVerificationModal && !!pendingAddChain}\n        onOpenChange={setShowVerificationModal}\n      />\n    </div>\n  );\n}\n","path":null,"size_bytes":30175,"size_tokens":null},"client/src/components/ui/slider.tsx":{"content":"import * as React from \"react\"\nimport * as SliderPrimitive from \"@radix-ui/react-slider\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst Slider = React.forwardRef<\n  React.ElementRef<typeof SliderPrimitive.Root>,\n  React.ComponentPropsWithoutRef<typeof SliderPrimitive.Root>\n>(({ className, ...props }, ref) => (\n  <SliderPrimitive.Root\n    ref={ref}\n    className={cn(\n      \"relative flex w-full touch-none select-none items-center\",\n      className\n    )}\n    {...props}\n  >\n    <SliderPrimitive.Track className=\"relative h-2 w-full grow overflow-hidden rounded-full bg-secondary\">\n      <SliderPrimitive.Range className=\"absolute h-full bg-primary\" />\n    </SliderPrimitive.Track>\n    <SliderPrimitive.Thumb className=\"block h-5 w-5 rounded-full border-2 border-primary bg-background ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50\" />\n  </SliderPrimitive.Root>\n))\nSlider.displayName = SliderPrimitive.Root.displayName\n\nexport { Slider }\n","path":null,"size_bytes":1077,"size_tokens":null},"client/src/components/ui/select.tsx":{"content":"\"use client\"\n\nimport * as React from \"react\"\nimport * as SelectPrimitive from \"@radix-ui/react-select\"\nimport { Check, ChevronDown, ChevronUp } from \"lucide-react\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst Select = SelectPrimitive.Root\n\nconst SelectGroup = SelectPrimitive.Group\n\nconst SelectValue = SelectPrimitive.Value\n\nconst SelectTrigger = React.forwardRef<\n  React.ElementRef<typeof SelectPrimitive.Trigger>,\n  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Trigger>\n>(({ className, children, ...props }, ref) => (\n  <SelectPrimitive.Trigger\n    ref={ref}\n    className={cn(\n      \"flex h-9 w-full items-center justify-between rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background data-[placeholder]:text-muted-foreground focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 [&>span]:line-clamp-1\",\n      className\n    )}\n    {...props}\n  >\n    {children}\n    <SelectPrimitive.Icon asChild>\n      <ChevronDown className=\"h-4 w-4 opacity-50\" />\n    </SelectPrimitive.Icon>\n  </SelectPrimitive.Trigger>\n))\nSelectTrigger.displayName = SelectPrimitive.Trigger.displayName\n\nconst SelectScrollUpButton = React.forwardRef<\n  React.ElementRef<typeof SelectPrimitive.ScrollUpButton>,\n  React.ComponentPropsWithoutRef<typeof SelectPrimitive.ScrollUpButton>\n>(({ className, ...props }, ref) => (\n  <SelectPrimitive.ScrollUpButton\n    ref={ref}\n    className={cn(\n      \"flex cursor-default items-center justify-center py-1\",\n      className\n    )}\n    {...props}\n  >\n    <ChevronUp className=\"h-4 w-4\" />\n  </SelectPrimitive.ScrollUpButton>\n))\nSelectScrollUpButton.displayName = SelectPrimitive.ScrollUpButton.displayName\n\nconst SelectScrollDownButton = React.forwardRef<\n  React.ElementRef<typeof SelectPrimitive.ScrollDownButton>,\n  React.ComponentPropsWithoutRef<typeof SelectPrimitive.ScrollDownButton>\n>(({ className, ...props }, ref) => (\n  <SelectPrimitive.ScrollDownButton\n    ref={ref}\n    className={cn(\n      \"flex cursor-default items-center justify-center py-1\",\n      className\n    )}\n    {...props}\n  >\n    <ChevronDown className=\"h-4 w-4\" />\n  </SelectPrimitive.ScrollDownButton>\n))\nSelectScrollDownButton.displayName =\n  SelectPrimitive.ScrollDownButton.displayName\n\nconst SelectContent = React.forwardRef<\n  React.ElementRef<typeof SelectPrimitive.Content>,\n  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Content>\n>(({ className, children, position = \"popper\", ...props }, ref) => (\n  <SelectPrimitive.Portal>\n    <SelectPrimitive.Content\n      ref={ref}\n      className={cn(\n        \"relative z-50 max-h-[--radix-select-content-available-height] min-w-[8rem] overflow-y-auto overflow-x-hidden rounded-md border bg-popover text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 origin-[--radix-select-content-transform-origin]\",\n        position === \"popper\" &&\n          \"data-[side=bottom]:translate-y-1 data-[side=left]:-translate-x-1 data-[side=right]:translate-x-1 data-[side=top]:-translate-y-1\",\n        className\n      )}\n      position={position}\n      {...props}\n    >\n      <SelectScrollUpButton />\n      <SelectPrimitive.Viewport\n        className={cn(\n          \"p-1\",\n          position === \"popper\" &&\n            \"h-[var(--radix-select-trigger-height)] w-full min-w-[var(--radix-select-trigger-width)]\"\n        )}\n      >\n        {children}\n      </SelectPrimitive.Viewport>\n      <SelectScrollDownButton />\n    </SelectPrimitive.Content>\n  </SelectPrimitive.Portal>\n))\nSelectContent.displayName = SelectPrimitive.Content.displayName\n\nconst SelectLabel = React.forwardRef<\n  React.ElementRef<typeof SelectPrimitive.Label>,\n  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Label>\n>(({ className, ...props }, ref) => (\n  <SelectPrimitive.Label\n    ref={ref}\n    className={cn(\"py-1.5 pl-8 pr-2 text-sm font-semibold\", className)}\n    {...props}\n  />\n))\nSelectLabel.displayName = SelectPrimitive.Label.displayName\n\nconst SelectItem = React.forwardRef<\n  React.ElementRef<typeof SelectPrimitive.Item>,\n  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Item>\n>(({ className, children, ...props }, ref) => (\n  <SelectPrimitive.Item\n    ref={ref}\n    className={cn(\n      \"relative flex w-full cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50\",\n      className\n    )}\n    {...props}\n  >\n    <span className=\"absolute left-2 flex h-3.5 w-3.5 items-center justify-center\">\n      <SelectPrimitive.ItemIndicator>\n        <Check className=\"h-4 w-4\" />\n      </SelectPrimitive.ItemIndicator>\n    </span>\n\n    <SelectPrimitive.ItemText>{children}</SelectPrimitive.ItemText>\n  </SelectPrimitive.Item>\n))\nSelectItem.displayName = SelectPrimitive.Item.displayName\n\nconst SelectSeparator = React.forwardRef<\n  React.ElementRef<typeof SelectPrimitive.Separator>,\n  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Separator>\n>(({ className, ...props }, ref) => (\n  <SelectPrimitive.Separator\n    ref={ref}\n    className={cn(\"-mx-1 my-1 h-px bg-muted\", className)}\n    {...props}\n  />\n))\nSelectSeparator.displayName = SelectPrimitive.Separator.displayName\n\nexport {\n  Select,\n  SelectGroup,\n  SelectValue,\n  SelectTrigger,\n  SelectContent,\n  SelectLabel,\n  SelectItem,\n  SelectSeparator,\n  SelectScrollUpButton,\n  SelectScrollDownButton,\n}\n","path":null,"size_bytes":5741,"size_tokens":null},"postcss.config.js":{"content":"export default {\n  plugins: {\n    tailwindcss: {},\n    autoprefixer: {},\n  },\n}\n","path":null,"size_bytes":80,"size_tokens":null},"server/index.ts":{"content":"import express, { type Request, Response, NextFunction } from \"express\";\nimport { registerRoutes } from \"./routes\";\nimport { serveStatic } from \"./static\";\nimport { createServer } from \"http\";\n\nconst app = express();\nconst httpServer = createServer(app);\n\ndeclare module \"http\" {\n  interface IncomingMessage {\n    rawBody: unknown;\n  }\n}\n\napp.use(\n  express.json({\n    verify: (req, _res, buf) => {\n      req.rawBody = buf;\n    },\n  }),\n);\n\napp.use(express.urlencoded({ extended: false }));\n\nexport function log(message: string, source = \"express\") {\n  const formattedTime = new Date().toLocaleTimeString(\"en-US\", {\n    hour: \"numeric\",\n    minute: \"2-digit\",\n    second: \"2-digit\",\n    hour12: true,\n  });\n\n  console.log(`${formattedTime} [${source}] ${message}`);\n}\n\napp.use((req, res, next) => {\n  const start = Date.now();\n  const path = req.path;\n  let capturedJsonResponse: Record<string, any> | undefined = undefined;\n\n  const originalResJson = res.json;\n  res.json = function (bodyJson, ...args) {\n    capturedJsonResponse = bodyJson;\n    return originalResJson.apply(res, [bodyJson, ...args]);\n  };\n\n  res.on(\"finish\", () => {\n    const duration = Date.now() - start;\n    if (path.startsWith(\"/api\")) {\n      let logLine = `${req.method} ${path} ${res.statusCode} in ${duration}ms`;\n      if (capturedJsonResponse) {\n        logLine += ` :: ${JSON.stringify(capturedJsonResponse)}`;\n      }\n\n      log(logLine);\n    }\n  });\n\n  next();\n});\n\n(async () => {\n  await registerRoutes(httpServer, app);\n\n  app.use((err: any, _req: Request, res: Response, _next: NextFunction) => {\n    const status = err.status || err.statusCode || 500;\n    const message = err.message || \"Internal Server Error\";\n\n    res.status(status).json({ message });\n    throw err;\n  });\n\n  // importantly only setup vite in development and after\n  // setting up all the other routes so the catch-all route\n  // doesn't interfere with the other routes\n  if (process.env.NODE_ENV === \"production\") {\n    serveStatic(app);\n  } else {\n    const { setupVite } = await import(\"./vite\");\n    await setupVite(httpServer, app);\n  }\n\n  // ALWAYS serve the app on the port specified in the environment variable PORT\n  // Other ports are firewalled. Default to 5000 if not specified.\n  // this serves both the API and the client.\n  // It is the only port that is not firewalled.\n  const port = parseInt(process.env.PORT || \"5000\", 10);\n  httpServer.listen(\n    {\n      port,\n      host: \"0.0.0.0\",\n      reusePort: true,\n    },\n    () => {\n      log(`serving on port ${port}`);\n    },\n  );\n})();\n","path":null,"size_bytes":2560,"size_tokens":null},"client/src/hooks/use-mobile.tsx":{"content":"import * as React from \"react\"\n\nconst MOBILE_BREAKPOINT = 768\n\nexport function useIsMobile() {\n  const [isMobile, setIsMobile] = React.useState<boolean | undefined>(undefined)\n\n  React.useEffect(() => {\n    const mql = window.matchMedia(`(max-width: ${MOBILE_BREAKPOINT - 1}px)`)\n    const onChange = () => {\n      setIsMobile(window.innerWidth < MOBILE_BREAKPOINT)\n    }\n    mql.addEventListener(\"change\", onChange)\n    setIsMobile(window.innerWidth < MOBILE_BREAKPOINT)\n    return () => mql.removeEventListener(\"change\", onChange)\n  }, [])\n\n  return !!isMobile\n}\n","path":null,"size_bytes":565,"size_tokens":null},"client/src/lib/wallet-context.tsx":{"content":"import { createContext, useContext, useState, useCallback, useEffect, useMemo, useRef, type Dispatch, type SetStateAction } from \"react\";\nimport type { Chain, Wallet, Transaction, Token } from \"@shared/schema\";\nimport { DEFAULT_CHAINS, FALLBACK_TOP_ASSETS } from \"@shared/schema\";\nimport { hardwareWallet, type HardwareWalletState, type ConnectionStatus } from \"./hardware-wallet\";\nimport { softWallet, type SoftWalletState } from \"./soft-wallet\";\nimport { clientStorage, type StoredWallet, type StoredTransaction, type CustomToken, type CustomChain, type CachedBalance } from \"./client-storage\";\nimport { getUniversalBalance, getTokenBalanceForAsset, getCustomTokenBalance, isTokenAsset } from \"./blockchain\";\nimport { fetchAllTransactions, type ParsedTransaction } from \"./explorer-service\";\nimport { fetchTopAssets, type TopAsset } from \"./price-service\";\nimport { deriveAllAddresses, type DerivedAddress as MultiChainDerivedAddress } from \"./multi-chain-address\";\nimport { getEnabledChainSymbols } from \"./chain-mappings\";\n\ninterface WalletContextType {\n  hardwareState: HardwareWalletState;\n  isConnected: boolean;\n  isUnlocked: boolean;\n  hasWalletOnDevice: boolean;\n  walletMode: \"hard_wallet\" | \"soft_wallet\";\n  setWalletMode: (mode: \"hard_wallet\" | \"soft_wallet\") => void;\n  hasSoftWalletSetup: boolean;\n  hasHardWalletSetup: boolean;\n  currentModeHasWallet: boolean;\n  chains: Chain[];\n  wallets: Wallet[];\n  setWallets: (wallets: Wallet[]) => void;\n  transactions: Transaction[];\n  setTransactions: (transactions: Transaction[]) => void;\n  tokens: Token[];\n  setTokens: (tokens: Token[]) => void;\n  selectedChainId: string | null;\n  setSelectedChainId: (chainId: string | null) => void;\n  showPinModal: boolean;\n  setShowPinModal: (show: boolean) => void;\n  pinAction: \"unlock\" | \"sign\" | \"setup\" | \"recover\" | null;\n  setPinAction: (action: \"unlock\" | \"sign\" | \"setup\" | \"recover\" | null) => void;\n  pendingTransaction: { toAddress: string; amount: string; chainId: string; tokenSymbol?: string; tokenContractAddress?: string; isNativeToken?: boolean } | null;\n  setPendingTransaction: (tx: { toAddress: string; amount: string; chainId: string; tokenSymbol?: string; tokenContractAddress?: string; isNativeToken?: boolean } | null) => void;\n  connectLedger: () => Promise<boolean>;\n  connectRaspberryPi: () => Promise<{ success: boolean; hasWallet: boolean; error?: string }>;\n  connectSimulated: (seedPhrase: string) => Promise<boolean>;\n  unlockWallet: (pin: string) => Promise<boolean>;\n  lockWallet: () => void;\n  disconnectDevice: () => Promise<void>;\n  deriveWallets: (selectedChainIds?: string[]) => Promise<void>;\n  refreshBalances: () => Promise<void>;\n  refreshWalletBalance: (walletId: string) => Promise<void>;\n  refreshTransactions: () => Promise<void>;\n  resetSessionTimeout: () => void;\n  isLoading: boolean;\n  isLoadingTransactions: boolean;\n  error: string | null;\n  topAssets: TopAsset[];\n  enabledAssetIds: Set<string>;\n  isLoadingAssets: boolean;\n  toggleAssetEnabled: (assetId: string, enabled: boolean) => Promise<void>;\n  refreshTopAssets: () => Promise<void>;\n  enableAllAssets: () => Promise<void>;\n  disableAllAssets: () => Promise<void>;\n  createAdditionalWallet: (label?: string, chainId?: string) => Promise<void>;\n  createWalletWithNewSeed: (label?: string, pin?: string) => Promise<{ seedPhrase: string; walletGroupId: string }>;\n  generateNewSeedPhrase: () => string;\n  selectedAccountIndex: number;\n  setSelectedAccountIndex: (index: number) => void;\n  availableAccounts: { index: number; label?: string }[];\n  visibleWallets: Wallet[];\n  customTokens: CustomToken[];\n  loadCustomTokens: () => Promise<void>;\n  addCustomToken: (token: Omit<CustomToken, 'id' | 'addedAt'>) => Promise<CustomToken>;\n  removeCustomToken: (id: string) => Promise<void>;\n  tokenBalances: Record<string, string>;\n  setTokenBalances: Dispatch<SetStateAction<Record<string, string>>>;\n  customTokenBalances: Record<string, string>;\n  setCustomTokenBalances: Dispatch<SetStateAction<Record<string, string>>>;\n  customChains: CustomChain[];\n  loadCustomChains: () => Promise<void>;\n  addCustomChain: (chain: Omit<CustomChain, 'id' | 'addedAt'>) => Promise<CustomChain>;\n  removeCustomChain: (id: string) => Promise<void>;\n  balanceCacheStatus: { isStale: boolean; lastUpdated: number | null; isRefreshing: boolean };\n  // Secure add chain with seed verification\n  pendingAddChain: { chainId: string; chainName: string } | null;\n  setPendingAddChain: (chain: { chainId: string; chainName: string } | null) => void;\n  verifySeedForAddChain: (seedPhrase: string) => Promise<boolean>;\n  confirmAddChain: (customLabel?: string) => Promise<boolean>;\n  abortAddChain: () => void;\n  getSeedWordCount: () => number | null;\n  // Wallet rename\n  renameWallet: (walletId: string, newLabel: string) => Promise<void>;\n}\n\nconst WalletContext = createContext<WalletContextType | undefined>(undefined);\n\nexport function WalletProvider({ children }: { children: React.ReactNode }) {\n  const [hardwareState, setHardwareState] = useState<HardwareWalletState>(hardwareWallet.getState());\n  const [softWalletState, setSoftWalletState] = useState<SoftWalletState>(softWallet.getState());\n  const [chains, setChains] = useState<Chain[]>([]);\n  const [wallets, setWallets] = useState<Wallet[]>([]);\n  const [transactions, setTransactions] = useState<Transaction[]>([]);\n  const [tokens, setTokens] = useState<Token[]>([]);\n  const [selectedChainId, setSelectedChainId] = useState<string | null>(null);\n  const [showPinModal, setShowPinModal] = useState(false);\n  const [pinAction, setPinAction] = useState<\"unlock\" | \"sign\" | \"setup\" | \"recover\" | null>(null);\n  const [pendingTransaction, setPendingTransaction] = useState<{ toAddress: string; amount: string; chainId: string; tokenSymbol?: string; tokenContractAddress?: string; isNativeToken?: boolean } | null>(null);\n  const [isLoading, setIsLoading] = useState(false);\n  const [isLoadingTransactions, setIsLoadingTransactions] = useState(false);\n  const [error, setError] = useState<string | null>(null);\n  const [storageInitialized, setStorageInitialized] = useState(false);\n  const [topAssets, setTopAssets] = useState<TopAsset[]>([]);\n  const [enabledAssetIds, setEnabledAssetIds] = useState<Set<string>>(new Set());\n  const [isLoadingAssets, setIsLoadingAssets] = useState(false);\n  const [walletMode, setWalletModeInternal] = useState<\"hard_wallet\" | \"soft_wallet\">(() => {\n    // Load persisted wallet mode from localStorage\n    const savedMode = localStorage.getItem(\"walletMode\");\n    return savedMode === \"hard_wallet\" ? \"hard_wallet\" : \"soft_wallet\";\n  });\n  const [hasSoftWalletSetup, setHasSoftWalletSetup] = useState(false);\n  const [hasHardWalletSetup, setHasHardWalletSetup] = useState(false);\n  const [softWallets, setSoftWallets] = useState<Wallet[]>([]);\n  const [hardWallets, setHardWallets] = useState<Wallet[]>([]);\n  const [selectedAccountIndex, setSelectedAccountIndex] = useState<number>(0);\n  const [customTokens, setCustomTokens] = useState<CustomToken[]>([]);\n  const [customChains, setCustomChains] = useState<CustomChain[]>([]);\n  const [tokenBalances, setTokenBalances] = useState<Record<string, string>>({});\n  const [customTokenBalances, setCustomTokenBalances] = useState<Record<string, string>>({});\n  const [balanceCacheStatus, setBalanceCacheStatus] = useState<{ isStale: boolean; lastUpdated: number | null; isRefreshing: boolean }>({\n    isStale: false,\n    lastUpdated: null,\n    isRefreshing: false,\n  });\n  const [pendingAddChain, setPendingAddChain] = useState<{ chainId: string; chainName: string } | null>(null);\n  \n  // Ref to track mode switch operations and prevent race conditions\n  const modeSwitchIdRef = useRef<number>(0);\n  // Flag to indicate a mode switch is in progress\n  const isModeSwitchingRef = useRef<boolean>(false);\n  // Track cache loading per mode - only load once per mode\n  const hasLoadedCacheForModeRef = useRef<{ soft: boolean; hard: boolean }>({ soft: false, hard: false });\n  // Track if custom chains have been loaded initially\n  const hasLoadedCustomChainsRef = useRef<boolean>(false);\n\n  // Compute available accounts from wallets (unique account indices with labels)\n  const availableAccounts = useMemo(() => {\n    const accountMap = new Map<number, { index: number; label?: string }>();\n    wallets.forEach(w => {\n      if (!accountMap.has(w.accountIndex)) {\n        accountMap.set(w.accountIndex, { index: w.accountIndex, label: w.label });\n      }\n    });\n    return Array.from(accountMap.values()).sort((a, b) => a.index - b.index);\n  }, [wallets]);\n\n  // Filter wallets by selected account index - uses modeBasedWallets for race-condition-free display\n  const visibleWallets = useMemo(() => {\n    // Use modeBasedWallets which is computed synchronously from current mode\n    // This prevents hard wallet data from appearing in soft wallet mode during rapid switches\n    // For hard wallet mode, only show wallets when actually unlocked (not just connected)\n    const walletsToFilter = walletMode === \"soft_wallet\" ? softWallets : \n      (hardwareState.status === \"unlocked\" ? hardWallets : []);\n    return walletsToFilter.filter(w => w.accountIndex === selectedAccountIndex);\n  }, [walletMode, softWallets, hardWallets, hardwareState.status, selectedAccountIndex]);\n\n  // Normalize selectedAccountIndex when wallets change and current index becomes invalid\n  useEffect(() => {\n    if (wallets.length === 0) return;\n    const validIndices = new Set(wallets.map(w => w.accountIndex));\n    if (!validIndices.has(selectedAccountIndex)) {\n      const lowestIndex = Math.min(...Array.from(validIndices));\n      setSelectedAccountIndex(lowestIndex);\n    }\n  }, [wallets, selectedAccountIndex]);\n\n  useEffect(() => {\n    const unsubscribe = hardwareWallet.subscribe(setHardwareState);\n    return unsubscribe;\n  }, []);\n\n  useEffect(() => {\n    const unsubscribe = softWallet.subscribe(setSoftWalletState);\n    return unsubscribe;\n  }, []);\n\n  // Check if soft wallet exists after storage is initialized\n  useEffect(() => {\n    if (storageInitialized) {\n      softWallet.checkWalletExists();\n    }\n  }, [storageInitialized]);\n\n  useEffect(() => {\n    async function initStorage() {\n      try {\n        await clientStorage.init();\n        setStorageInitialized(true);\n        \n        // Load mode-specific wallet setup states\n        const softSetup = await clientStorage.isSoftWalletSetup();\n        const hardSetup = await clientStorage.isHardWalletSetup();\n        setHasSoftWalletSetup(softSetup);\n        setHasHardWalletSetup(hardSetup);\n        \n        // Get persisted wallet mode\n        const savedMode = localStorage.getItem(\"walletMode\");\n        const currentMode = savedMode === \"hard_wallet\" ? \"hard_wallet\" : \"soft_wallet\";\n        \n        // Load wallet data and check for cross-contamination\n        const softWalletData = softSetup ? await clientStorage.getSoftWalletData() : [];\n        const hardWalletData = hardSetup ? await clientStorage.getHardWalletData() : [];\n        \n        // Detect cross-contamination: if addresses match between soft and hard, clear the contaminated one\n        if (softWalletData.length > 0 && hardWalletData.length > 0) {\n          const softAddresses = new Set(softWalletData.map(w => w.address.toLowerCase()));\n          const hardAddresses = new Set(hardWalletData.map(w => w.address.toLowerCase()));\n          const overlap = Array.from(softAddresses).some(addr => hardAddresses.has(addr));\n          \n          if (overlap) {\n            console.log(\"[WalletContext] Detected cross-contamination - clearing soft wallet data\");\n            await clientStorage.clearSoftWallet();\n            await clientStorage.clearEncryptedSeed();\n            setHasSoftWalletSetup(false);\n            setSoftWallets([]);\n            \n            // Only load hard wallet data - but don't display until device connects\n            if (hardSetup) {\n              const mappedHardWallets: Wallet[] = hardWalletData.map(w => ({\n                id: w.id,\n                deviceId: \"hard\",\n                chainId: w.chainId,\n                address: w.address,\n                balance: \"0\",\n                isActive: true,\n                accountIndex: w.accountIndex ?? 0,\n                label: w.label,\n              }));\n              setHardWallets(mappedHardWallets);\n              // In hard wallet mode, don't set active wallets until device is connected\n              // User needs to click \"Connect\" first\n            }\n            return;\n          }\n        }\n        \n        // Load cached balances to apply immediately\n        const cachedBalances = await clientStorage.getAllCachedBalances();\n        const cachedBalanceMap = new Map<string, string>();\n        cachedBalances.forEach(c => {\n          cachedBalanceMap.set(`${c.address.toLowerCase()}-${c.chainSymbol}`, c.balance);\n        });\n        \n        // Update cache status\n        const lastRefresh = await clientStorage.getLastFullRefresh();\n        if (lastRefresh > 0) {\n          const isStale = clientStorage.isCacheStale(lastRefresh);\n          setBalanceCacheStatus({ isStale, lastUpdated: lastRefresh, isRefreshing: false });\n        }\n        \n        // Load soft wallet data if it's set up (no contamination)\n        if (softSetup && softWalletData.length > 0) {\n          const mappedWallets: Wallet[] = softWalletData.map(w => {\n            // Apply cached balance if available\n            const cacheKey = `${w.address.toLowerCase()}-${w.chainSymbol}`;\n            const cachedBalance = cachedBalanceMap.get(cacheKey);\n            return {\n              id: w.id,\n              deviceId: \"soft\",\n              chainId: w.chainId,\n              address: w.address,\n              balance: cachedBalance || \"0\",\n              isActive: true,\n              accountIndex: w.accountIndex ?? 0,\n              label: w.label,\n            };\n          });\n          setSoftWallets(mappedWallets);\n          // Set as active wallets if in soft wallet mode\n          if (currentMode === \"soft_wallet\") {\n            setWallets(mappedWallets);\n            // Mark cache as loaded for soft mode\n            hasLoadedCacheForModeRef.current.soft = true;\n          }\n        }\n        \n        // Load hard wallet data if it's set up - but don't display until device connects\n        if (hardSetup && hardWalletData.length > 0) {\n          const mappedWallets: Wallet[] = hardWalletData.map(w => {\n            // Apply cached balance if available\n            const cacheKey = `${w.address.toLowerCase()}-${w.chainSymbol}`;\n            const cachedBalance = cachedBalanceMap.get(cacheKey);\n            return {\n              id: w.id,\n              deviceId: \"hard\",\n              chainId: w.chainId,\n              address: w.address,\n              balance: cachedBalance || \"0\",\n              isActive: true,\n              accountIndex: w.accountIndex ?? 0,\n              label: w.label,\n            };\n          });\n          setHardWallets(mappedWallets);\n          // In hard wallet mode, don't set active wallets until device is connected\n          // User needs to click \"Connect\" first - wallets will be loaded when device connects\n        }\n      } catch (err) {\n        console.error(\"Failed to initialize storage:\", err);\n      }\n    }\n    initStorage();\n  }, []);\n  \n  // Handle wallet mode switching\n  const setWalletMode = useCallback(async (mode: \"hard_wallet\" | \"soft_wallet\") => {\n    if (mode === walletMode) return;\n    \n    // Mark that we're switching modes to prevent effects from interfering\n    isModeSwitchingRef.current = true;\n    \n    // Increment mode switch ID to track this operation and prevent race conditions\n    modeSwitchIdRef.current += 1;\n    const currentSwitchId = modeSwitchIdRef.current;\n    \n    // First, persist current mode's wallets to storage before switching\n    // Only save if wallets match the current mode (prevent cross-contamination)\n    const expectedDeviceId = walletMode === \"soft_wallet\" ? \"soft\" : \"hard\";\n    const walletsForCurrentMode = wallets.filter(w => w.deviceId === expectedDeviceId);\n    \n    if (walletsForCurrentMode.length > 0 && storageInitialized) {\n      const storedWalletsForCurrentMode: StoredWallet[] = walletsForCurrentMode.map(w => {\n        const chain = chains.find(c => c.id === w.chainId);\n        return {\n          id: w.id,\n          address: w.address,\n          chainId: w.chainId,\n          chainName: chain?.name || \"\",\n          chainSymbol: chain?.symbol || \"\",\n          balance: w.balance,\n          path: \"m/44'/60'/0'/0/0\",\n          lastUpdated: new Date().toISOString(),\n          accountIndex: w.accountIndex ?? 0,\n          label: w.label,\n        };\n      });\n      \n      if (walletMode === \"soft_wallet\") {\n        await clientStorage.saveSoftWalletData(storedWalletsForCurrentMode);\n        await clientStorage.setSoftWalletSetup(true);\n        // Check if this operation is still current before mutating state\n        if (modeSwitchIdRef.current !== currentSwitchId) return;\n        setHasSoftWalletSetup(true);\n        setSoftWallets(walletsForCurrentMode);\n      } else {\n        await clientStorage.saveHardWalletData(storedWalletsForCurrentMode);\n        await clientStorage.setHardWalletSetup(true);\n        if (modeSwitchIdRef.current !== currentSwitchId) return;\n        setHasHardWalletSetup(true);\n        setHardWallets(walletsForCurrentMode);\n      }\n    }\n    \n    // Check if this operation is still current\n    if (modeSwitchIdRef.current !== currentSwitchId) return;\n    \n    // Switch mode and immediately clear wallets to prevent stale data during async load\n    setWalletModeInternal(mode);\n    localStorage.setItem(\"walletMode\", mode);\n    setWallets([]);\n    \n    // Load wallets from storage for the target mode - no PIN required for viewing\n    try {\n      if (mode === \"soft_wallet\") {\n        const softSetup = await clientStorage.isSoftWalletSetup();\n        // Check if this operation is still current before mutating state\n        if (modeSwitchIdRef.current !== currentSwitchId) return;\n        setHasSoftWalletSetup(softSetup);\n        \n        if (softSetup) {\n          const softWalletData = await clientStorage.getSoftWalletData();\n          if (modeSwitchIdRef.current !== currentSwitchId) return;\n          \n          if (softWalletData.length > 0) {\n            const mappedWallets: Wallet[] = softWalletData.map(w => ({\n              id: w.id,\n              deviceId: \"soft\",\n              chainId: w.chainId,\n              address: w.address,\n              balance: \"0\",\n              isActive: true,\n              accountIndex: w.accountIndex ?? 0,\n              label: w.label,\n            }));\n            setSoftWallets(mappedWallets);\n            setWallets(mappedWallets);\n          } else {\n            // No wallet data even though setup flag is true - just show empty state\n            setWallets([]);\n          }\n        } else {\n          // Not set up - show empty state, user can set up from dashboard\n          setWallets([]);\n        }\n      } else {\n        // Hard wallet mode - only load wallet data into cache, NOT into active display\n        // Wallets will only be displayed when device is actually connected\n        const hardSetup = await clientStorage.isHardWalletSetup();\n        const hasStoredHardWallet = await hardwareWallet.hasStoredHardWallet();\n        \n        // Check if this operation is still current before mutating state\n        if (modeSwitchIdRef.current !== currentSwitchId) return;\n        \n        if (hardSetup || hasStoredHardWallet) {\n          const hardWalletData = await clientStorage.getHardWalletData();\n          if (modeSwitchIdRef.current !== currentSwitchId) return;\n          \n          if (hardWalletData.length > 0) {\n            const mappedWallets: Wallet[] = hardWalletData.map(w => ({\n              id: w.id,\n              deviceId: \"hard\",\n              chainId: w.chainId,\n              address: w.address,\n              balance: \"0\",\n              isActive: true,\n              accountIndex: w.accountIndex ?? 0,\n              label: w.label,\n            }));\n            setHardWallets(mappedWallets);\n            setHasHardWalletSetup(true);\n            // Don't set active wallets - wait for device connection\n            // The useEffect watching isConnected will populate wallets when device connects\n            setWallets([]);\n          } else {\n            // No wallet data - show empty state\n            setHasHardWalletSetup(false);\n            setHardWallets([]);\n            setWallets([]);\n          }\n        } else {\n          // Not set up - show empty state, user can set up from dashboard\n          setHasHardWalletSetup(false);\n          setWallets([]);\n        }\n      }\n    } catch (err) {\n      console.error(\"Failed to load wallet data for mode:\", mode, err);\n      if (modeSwitchIdRef.current === currentSwitchId) {\n        setWallets([]);\n      }\n    } finally {\n      // Only clear the switching flag if this is still the current operation\n      if (modeSwitchIdRef.current === currentSwitchId) {\n        isModeSwitchingRef.current = false;\n      }\n    }\n  }, [walletMode, wallets, storageInitialized, chains]);\n\n  // Load top assets and enabled preferences on mount\n  useEffect(() => {\n    async function loadAssetsAndPreferences() {\n      if (!storageInitialized) return;\n      \n      setIsLoadingAssets(true);\n      try {\n        // Fetch top assets from API\n        const assets = await fetchTopAssets(20);\n        setTopAssets(assets);\n        \n        const newAssetIds = new Set(assets.map(a => a.id));\n        \n        // Load enabled preferences from storage\n        const hasPreference = await clientStorage.hasEnabledAssetsPreference();\n        if (hasPreference) {\n          const storedEnabled = await clientStorage.getEnabledAssets();\n          // Reconcile: keep only IDs that exist in the new assets\n          const synced = new Set<string>();\n          for (const id of Array.from(storedEnabled)) {\n            if (newAssetIds.has(id)) {\n              synced.add(id);\n            }\n          }\n          // If after reconciliation we lost all enabled assets, re-enable all\n          if (synced.size === 0 && storedEnabled.size > 0) {\n            setEnabledAssetIds(newAssetIds);\n            await clientStorage.setEnabledAssets(newAssetIds);\n          } else {\n            setEnabledAssetIds(synced);\n            // Only persist if we actually removed stale entries\n            if (synced.size !== storedEnabled.size) {\n              await clientStorage.setEnabledAssets(synced);\n            }\n          }\n        } else {\n          // First time: enable only BTC, ETH, BNB, TRX by default\n          const defaultEnabledIds = new Set<string>();\n          const defaultAssetIds = ['bitcoin', 'ethereum', 'binancecoin', 'tron'];\n          for (const id of defaultAssetIds) {\n            if (newAssetIds.has(id)) {\n              defaultEnabledIds.add(id);\n            }\n          }\n          // If none of the defaults exist, fall back to enabling the first 4 assets\n          if (defaultEnabledIds.size === 0) {\n            const firstFour = Array.from(newAssetIds).slice(0, 4);\n            firstFour.forEach(id => defaultEnabledIds.add(id));\n          }\n          setEnabledAssetIds(defaultEnabledIds);\n          await clientStorage.setEnabledAssets(defaultEnabledIds);\n        }\n      } catch (err) {\n        console.error(\"Failed to load assets:\", err);\n      } finally {\n        setIsLoadingAssets(false);\n      }\n    }\n    loadAssetsAndPreferences();\n  }, [storageInitialized]);\n\n  useEffect(() => {\n    async function loadTransactions() {\n      if (!storageInitialized) return;\n      try {\n        const storedTxs = await clientStorage.getAllTransactions();\n        const mappedTxs: Transaction[] = storedTxs.map(tx => ({\n          id: tx.id,\n          walletId: tx.walletId,\n          chainId: tx.chainId,\n          type: tx.type,\n          status: tx.status,\n          amount: tx.amount,\n          tokenSymbol: tx.tokenSymbol,\n          toAddress: tx.toAddress,\n          fromAddress: tx.fromAddress,\n          txHash: tx.txHash || undefined,\n          gasUsed: tx.gasUsed || undefined,\n          timestamp: tx.timestamp,\n        }));\n        setTransactions(mappedTxs);\n      } catch (err) {\n        console.error(\"Failed to load transactions:\", err);\n      }\n    }\n    loadTransactions();\n  }, [storageInitialized]);\n\n  useEffect(() => {\n    const defaultChains: Chain[] = DEFAULT_CHAINS.map((c, i) => ({\n      ...c,\n      id: `chain-${i}`,\n    }));\n    \n    // Merge default chains with custom chains\n    const customChainsAsMapped: Chain[] = customChains.map((c) => ({\n      id: c.id,\n      name: c.name,\n      symbol: c.symbol,\n      rpcUrl: c.rpcUrl,\n      chainId: c.chainId,\n      blockExplorer: c.blockExplorer || \"\",\n      iconColor: c.iconColor || \"#6B7280\",\n      isDefault: false,\n      decimals: c.decimals,\n    }));\n    \n    setChains([...defaultChains, ...customChainsAsMapped]);\n    if (defaultChains.length > 0 && !selectedChainId) {\n      setSelectedChainId(defaultChains[0].id);\n    }\n  }, [customChains]);\n\n  useEffect(() => {\n    const handleActivity = () => {\n      if (walletMode === \"soft_wallet\") {\n        if (softWalletState.status === \"unlocked\") {\n          softWallet.resetSessionTimeout();\n        }\n      } else {\n        if (hardwareState.status === \"unlocked\") {\n          hardwareWallet.resetSessionTimeout();\n        }\n      }\n    };\n\n    const events = [\"mousedown\", \"keydown\", \"touchstart\", \"scroll\"];\n    events.forEach(event => {\n      window.addEventListener(event, handleActivity, { passive: true });\n    });\n\n    return () => {\n      events.forEach(event => {\n        window.removeEventListener(event, handleActivity);\n      });\n    };\n  }, [walletMode, hardwareState.status, softWalletState.status]);\n\n  const fetchedWalletIdsRef = useRef<Set<string>>(new Set());\n  const isRefreshingRef = useRef<boolean>(false);\n  \n  // Reset fetched wallet IDs when wallet mode changes\n  useEffect(() => {\n    fetchedWalletIdsRef.current = new Set();\n  }, [walletMode]);\n\n  useEffect(() => {\n    // Skip automatic fetch if refreshBalances is in progress\n    if (isRefreshingRef.current) return;\n    \n    if (wallets.length === 0) {\n      fetchedWalletIdsRef.current = new Set();\n      return;\n    }\n    \n    if (chains.length === 0) return;\n    \n    // Find wallets that haven't had their balances fetched yet\n    const unfetchedWallets = wallets.filter(w => !fetchedWalletIdsRef.current.has(w.id));\n    if (unfetchedWallets.length === 0) return;\n    \n    // Mark these wallets as being fetched (using ref to avoid re-render loop)\n    unfetchedWallets.forEach(w => fetchedWalletIdsRef.current.add(w.id));\n    \n    (async () => {\n      // Fetch balances only for the wallets that need updating\n      const balanceUpdates = new Map<string, string>();\n      \n      await Promise.all(\n        unfetchedWallets.map(async (wallet) => {\n          // Only fetch balance for wallets that need it\n          if (wallet.balance !== \"0\") return;\n          \n          const chain = chains.find(c => c.id === wallet.chainId);\n          if (!chain || chain.chainId === 0) return;\n          try {\n            const customRpcUrl = !chain.isDefault && chain.rpcUrl ? chain.rpcUrl : undefined;\n            const balance = await getUniversalBalance(wallet.address, chain.chainId, chain.symbol, customRpcUrl);\n            balanceUpdates.set(wallet.id, balance);\n          } catch {\n            // Keep existing balance on error\n          }\n        })\n      );\n      \n      // Use functional update to merge balance updates with current wallets\n      // This prevents overwriting wallets added while fetching was in progress\n      setWallets(currentWallets => \n        currentWallets.map(w => {\n          const newBalance = balanceUpdates.get(w.id);\n          return newBalance ? { ...w, balance: newBalance } : w;\n        })\n      );\n    })();\n  }, [wallets, chains.length, walletMode]);\n\n  // For soft wallet mode, use softWalletState; for hard wallet mode, use hardwareState\n  const isConnected = walletMode === \"soft_wallet\" \n    ? (softWalletState.status === \"locked\" || softWalletState.status === \"unlocked\" || softWalletState.hasWallet)\n    : (hardwareState.status === \"connected\" || hardwareState.status === \"unlocked\");\n  const isUnlocked = walletMode === \"soft_wallet\"\n    ? softWalletState.status === \"unlocked\"\n    : hardwareState.status === \"unlocked\";\n  \n  // Computed value for whether current mode has a wallet set up\n  const currentModeHasWallet = walletMode === \"soft_wallet\" ? hasSoftWalletSetup : hasHardWalletSetup;\n\n  // CRITICAL: Compute displayed wallets synchronously based on current mode\n  // This eliminates race conditions from async state updates\n  const modeBasedWallets = useMemo(() => {\n    if (walletMode === \"soft_wallet\") {\n      // In soft wallet mode, ONLY show soft wallet data\n      return softWallets;\n    } else {\n      // In hard wallet mode, ONLY show hard wallet data when device is UNLOCKED (not just connected)\n      // This ensures addresses are not visible until PIN is entered\n      return hardwareState.status === \"unlocked\" ? hardWallets : [];\n    }\n  }, [walletMode, softWallets, hardWallets, hardwareState.status]);\n\n  // Track last hard wallet connection status for triggering balance refresh\n  const lastHardConnectedRef = useRef<boolean>(false);\n  \n  // Sync wallets array from modeBasedWallets when hard wallet UNLOCKS or mode changes\n  // This ensures the wallets array is populated for components that depend on it\n  // IMPORTANT: Only sync when UNLOCKED, not just connected - this protects sensitive data\n  useEffect(() => {\n    if (isModeSwitchingRef.current) return; // Don't sync during mode switch\n    \n    if (walletMode === \"hard_wallet\") {\n      // Only use unlocked status, not connected - addresses should only show after PIN\n      const hardUnlocked = hardwareState.status === \"unlocked\";\n      \n      // Detect when hard wallet just unlocked (transition from not unlocked to unlocked)\n      const justUnlocked = hardUnlocked && !lastHardConnectedRef.current;\n      lastHardConnectedRef.current = hardUnlocked;\n      \n      if (hardUnlocked && hardWallets.length > 0) {\n        // Clear the fetched wallet IDs ref so balances get fetched fresh\n        // This happens on initial sync OR when hard wallet unlocks\n        if (wallets.length === 0 || justUnlocked) {\n          fetchedWalletIdsRef.current = new Set();\n          // Clone hardWallets to ensure React detects the state change\n          setWallets([...hardWallets]);\n        }\n      } else if (!hardUnlocked) {\n        // When locked, clear visible wallets\n        if (wallets.length > 0 && wallets[0]?.deviceId === \"hard\") {\n          setWallets([]);\n        }\n      }\n    } else {\n      // Reset the ref when switching away from hard wallet mode\n      lastHardConnectedRef.current = false;\n    }\n  }, [walletMode, hardwareState.status, hardWallets, wallets.length]);\n\n  // Track previous unlock status to detect unlock transition\n  const wasUnlockedRef = useRef<boolean>(false);\n  \n  // Sync chain preferences from hardware wallet on unlock\n  useEffect(() => {\n    if (walletMode !== \"hard_wallet\") {\n      wasUnlockedRef.current = false;\n      return;\n    }\n    \n    const justUnlocked = hardwareState.status === \"unlocked\" && !wasUnlockedRef.current;\n    wasUnlockedRef.current = hardwareState.status === \"unlocked\";\n    \n    if (!justUnlocked || !storageInitialized) return;\n    \n    (async () => {\n      try {\n        console.log(\"[WalletContext] Hardware wallet unlocked - syncing chain preferences\");\n        const chainPrefs = await hardwareWallet.getChainPreferences();\n        \n        if (chainPrefs && chainPrefs.length > 0) {\n          console.log(\"[WalletContext] Loaded chain preferences from hardware:\", chainPrefs);\n          \n          // Derive addresses for the stored chain preferences\n          const mnemonic = await hardwareWallet.getSeedPhraseFromDevice();\n          if (!mnemonic) {\n            console.error(\"[WalletContext] Cannot get seed phrase from device\");\n            return;\n          }\n          \n          const currentChains = chains.length > 0 ? chains : DEFAULT_CHAINS.map((c, i) => ({\n            ...c,\n            id: `chain-${i}`,\n          }));\n          \n          const newWallets: Wallet[] = [];\n          \n          for (const pref of chainPrefs) {\n            const chain = currentChains.find(c => c.symbol === pref.symbol);\n            if (!chain) continue;\n            \n            const derivedAddresses = await deriveAllAddresses(mnemonic, [pref.symbol], pref.accountIndex);\n            const derived = derivedAddresses[0];\n            \n            if (derived && derived.address) {\n              newWallets.push({\n                id: `wallet-${Date.now()}-${chain.id}-${pref.accountIndex}`,\n                deviceId: \"hard\",\n                chainId: chain.id,\n                address: derived.address,\n                balance: \"0\",\n                isActive: true,\n                accountIndex: pref.accountIndex,\n                label: pref.label,\n              });\n            }\n          }\n          \n          if (newWallets.length > 0) {\n            console.log(\"[WalletContext] Derived wallets from chain preferences:\", newWallets.length);\n            setHardWallets(newWallets);\n            setWallets(newWallets);\n            setHasHardWalletSetup(true);\n            \n            // Save to browser storage for balance caching\n            const walletsToSave: StoredWallet[] = newWallets.map(w => {\n              const chain = currentChains.find(c => c.id === w.chainId);\n              return {\n                id: w.id,\n                chainId: w.chainId,\n                chainName: chain?.name || \"\",\n                chainSymbol: chain?.symbol || \"\",\n                address: w.address,\n                balance: w.balance,\n                path: `m/44'/${chain?.symbol === 'ETH' ? '60' : chain?.symbol === 'BTC' ? '0' : '501'}'/0'/0/${w.accountIndex}`,\n                lastUpdated: new Date().toISOString(),\n                accountIndex: w.accountIndex,\n                label: w.label,\n              };\n            });\n            await clientStorage.saveHardWalletData(walletsToSave);\n            await clientStorage.setHardWalletSetup(true);\n          }\n        }\n      } catch (err) {\n        console.error(\"[WalletContext] Failed to sync chain preferences:\", err);\n      }\n    })();\n  }, [walletMode, hardwareState.status, storageInitialized, chains]);\n\n  const connectLedger = useCallback(async (): Promise<boolean> => {\n    setIsLoading(true);\n    setError(null);\n    try {\n      const result = await hardwareWallet.connectLedger();\n      return result;\n    } catch (err: any) {\n      setError(err.message || \"Failed to connect Ledger\");\n      return false;\n    } finally {\n      setIsLoading(false);\n    }\n  }, []);\n\n  const connectRaspberryPi = useCallback(async (): Promise<{ success: boolean; hasWallet: boolean; error?: string }> => {\n    console.log(\"[WalletContext] connectRaspberryPi() called\");\n    setIsLoading(true);\n    setError(null);\n    try {\n      const result = await hardwareWallet.connectRaspberryPi();\n      console.log(\"[WalletContext] hardwareWallet.connectRaspberryPi() result:\", result);\n      \n      if (result) {\n        const hasWallet = hardwareWallet.hasWalletOnDevice();\n        console.log(\"[WalletContext] Device has wallet:\", hasWallet);\n        \n        // Check if the Pico has a wallet - if not, clear cached wallets\n        if (!hasWallet) {\n          console.log(\"[WalletContext] NEW DEVICE - No wallet found, clearing cache\");\n          setWallets([]);\n          setTransactions([]);\n          await clientStorage.clearAll();\n        } else {\n          console.log(\"[WalletContext] EXISTING DEVICE - Wallet found on device\");\n        }\n        return { success: true, hasWallet };\n      } else {\n        // Connection failed - reset hasWallet to false and return error\n        console.log(\"[WalletContext] Connection failed\");\n        hardwareWallet.setHasWalletOnDevice(false);\n        const errorMsg = hardwareWallet.getState().error;\n        return { success: false, hasWallet: false, error: errorMsg || undefined };\n      }\n    } catch (err: any) {\n      // Exception thrown - reset hasWallet to false\n      console.log(\"[WalletContext] Exception:\", err);\n      hardwareWallet.setHasWalletOnDevice(false);\n      const errorMsg = err.message || \"Failed to connect Raspberry Pi\";\n      setError(errorMsg);\n      return { success: false, hasWallet: false, error: errorMsg };\n    } finally {\n      setIsLoading(false);\n    }\n  }, []);\n\n  const connectSimulated = useCallback(async (seedPhrase: string): Promise<boolean> => {\n    setIsLoading(true);\n    setError(null);\n    try {\n      const result = await hardwareWallet.connectSimulated(seedPhrase);\n      return result;\n    } catch (err: any) {\n      setError(err.message || \"Failed to create simulated wallet\");\n      return false;\n    } finally {\n      setIsLoading(false);\n    }\n  }, []);\n\n  const unlockWallet = useCallback(async (pin: string): Promise<boolean> => {\n    setIsLoading(true);\n    setError(null);\n    try {\n      let result: boolean;\n      if (walletMode === \"soft_wallet\") {\n        result = await softWallet.unlock(pin);\n        if (!result && softWallet.getState().error) {\n          setError(softWallet.getState().error);\n        }\n      } else {\n        result = await hardwareWallet.unlock(pin);\n      }\n      if (result) {\n        setShowPinModal(false);\n      }\n      return result;\n    } catch (err: any) {\n      setError(err.message || \"Failed to unlock wallet\");\n      return false;\n    } finally {\n      setIsLoading(false);\n    }\n  }, [walletMode]);\n\n  const lockWallet = useCallback(() => {\n    if (walletMode === \"soft_wallet\") {\n      softWallet.lock();\n    } else {\n      hardwareWallet.lock();\n    }\n  }, [walletMode]);\n\n  const resetSessionTimeout = useCallback(() => {\n    if (walletMode === \"soft_wallet\") {\n      softWallet.resetSessionTimeout();\n    } else {\n      hardwareWallet.resetSessionTimeout();\n    }\n  }, [walletMode]);\n\n  const disconnectDevice = useCallback(async () => {\n    if (walletMode === \"soft_wallet\") {\n      await softWallet.reset();\n      setHasSoftWalletSetup(false);\n      setSoftWallets([]);\n    } else {\n      await hardwareWallet.disconnect();\n      await clientStorage.clearHardWallet();\n      setHasHardWalletSetup(false);\n      setHardWallets([]);\n    }\n    setWallets([]);\n    setTransactions([]);\n  }, [walletMode]);\n\n  const deriveWallets = useCallback(async (selectedChainIds?: string[]) => {\n    // Check unlock status based on wallet mode\n    if (walletMode === \"soft_wallet\") {\n      if (softWallet.getState().status !== \"unlocked\") {\n        setError(\"Wallet must be unlocked to derive wallets\");\n        return;\n      }\n    } else {\n      const currentState = hardwareWallet.getState();\n      if (currentState.status !== \"unlocked\") {\n        setError(\"Device must be unlocked to derive wallets\");\n        return;\n      }\n    }\n\n    // Before deriving new wallets, check if we have stored wallets\n    if (storageInitialized && !selectedChainIds) {\n      const storedWallets = walletMode === \"soft_wallet\" \n        ? await clientStorage.getSoftWalletData()\n        : await clientStorage.getHardWalletData();\n      \n      if (storedWallets.length > 0) {\n        // Load from storage\n        const mappedWallets: Wallet[] = storedWallets.map(w => ({\n          id: w.id,\n          deviceId: walletMode === \"soft_wallet\" ? \"soft\" : \"hard\",\n          chainId: w.chainId,\n          address: w.address,\n          balance: \"0\",\n          isActive: true,\n          accountIndex: w.accountIndex ?? 0,\n          label: w.label,\n        }));\n        \n        // Don't auto-derive for new chains - user manually adds chains they want\n        // Just load existing wallets from storage\n        setWallets(mappedWallets);\n        if (walletMode === \"soft_wallet\") {\n          setSoftWallets(mappedWallets);\n        } else {\n          setHardWallets(mappedWallets);\n        }\n        return;\n      }\n    }\n\n    // New wallet - create wallets for selected chains\n    setIsLoading(true);\n    try {\n      const currentChains = chains.length > 0 ? chains : DEFAULT_CHAINS.map((c, i) => ({\n        ...c,\n        id: `chain-${i}`,\n      }));\n      \n      // If selectedChainIds provided, create wallets for those chains\n      if (selectedChainIds && selectedChainIds.length > 0) {\n        const mnemonic = walletMode === \"soft_wallet\" \n          ? softWallet.getSeedPhrase()\n          : await hardwareWallet.getSeedPhraseFromDevice();\n        \n        if (!mnemonic) {\n          throw new Error(\"Cannot access seed phrase\");\n        }\n        \n        // Filter chains to selected ones\n        const targetChains = currentChains.filter(c => selectedChainIds.includes(c.id));\n        const chainSymbols = targetChains.map(c => c.symbol);\n        \n        const derivedAddresses = await deriveAllAddresses(mnemonic, chainSymbols, 0);\n        \n        const newWallets: Wallet[] = [];\n        for (const derived of derivedAddresses) {\n          const chain = targetChains.find(c => c.symbol === derived.chainSymbol);\n          if (!chain || !derived.address) continue;\n          \n          newWallets.push({\n            id: `wallet-${Date.now()}-${chain.id}-0`,\n            deviceId: walletMode === \"soft_wallet\" ? \"soft\" : \"hard\",\n            chainId: chain.id,\n            address: derived.address,\n            balance: \"0\",\n            isActive: true,\n            accountIndex: 0,\n          });\n        }\n        \n        // Set both states together to ensure consistency\n        if (walletMode === \"soft_wallet\") {\n          setSoftWallets(newWallets);\n        } else {\n          setHardWallets(newWallets);\n        }\n        setWallets(newWallets);\n        \n        // Save to storage\n        if (storageInitialized) {\n          const walletsToSave: StoredWallet[] = newWallets.map(w => {\n            const chain = targetChains.find(c => c.id === w.chainId);\n            return {\n              id: w.id,\n              chainId: w.chainId,\n              chainName: chain?.name || \"\",\n              chainSymbol: chain?.symbol || \"\",\n              address: w.address,\n              balance: w.balance,\n              path: `m/44'/${chain?.symbol === 'ETH' ? '60' : chain?.symbol === 'BTC' ? '0' : '501'}'/0'/0/${w.accountIndex}`,\n              lastUpdated: new Date().toISOString(),\n              accountIndex: w.accountIndex,\n              label: w.label,\n            };\n          });\n          \n          if (walletMode === \"soft_wallet\") {\n            await clientStorage.saveSoftWalletData(walletsToSave);\n            await clientStorage.setSoftWalletSetup(true);\n            setHasSoftWalletSetup(true);\n          } else {\n            await clientStorage.saveHardWalletData(walletsToSave);\n            await clientStorage.setHardWalletSetup(true);\n            setHasHardWalletSetup(true);\n            \n            // Save chain preferences to hardware for portability\n            const chainPrefs = newWallets.map(w => {\n              const chain = targetChains.find(c => c.id === w.chainId);\n              return {\n                symbol: chain?.symbol || \"\",\n                accountIndex: w.accountIndex,\n                label: w.label,\n              };\n            });\n            await hardwareWallet.saveChainPreferences(chainPrefs);\n          }\n        }\n      } else {\n        // No chains selected - start with empty wallets\n        const newWallets: Wallet[] = [];\n        setWallets(newWallets);\n        \n        // Mark wallet as set up (with empty chain list)\n        if (storageInitialized) {\n          if (walletMode === \"soft_wallet\") {\n            await clientStorage.saveSoftWalletData([]);\n            await clientStorage.setSoftWalletSetup(true);\n            setHasSoftWalletSetup(true);\n            setSoftWallets([]);\n          } else {\n            await clientStorage.saveHardWalletData([]);\n            await clientStorage.setHardWalletSetup(true);\n            setHasHardWalletSetup(true);\n            setHardWallets([]);\n          }\n        }\n      }\n      \n      if (chains.length === 0) {\n        setChains(currentChains);\n      }\n    } catch (err: any) {\n      setError(err.message || \"Failed to initialize wallet\");\n    } finally {\n      setIsLoading(false);\n    }\n  }, [chains, selectedChainId, storageInitialized, walletMode]);\n\n  const loadCachedBalances = useCallback(async () => {\n    const currentWallets = walletMode === \"soft_wallet\" ? softWallets : hardWallets;\n    if (currentWallets.length === 0 || chains.length === 0) return;\n    \n    try {\n      const cachedBalances = await clientStorage.getAllCachedBalances();\n      if (cachedBalances.length === 0) return;\n      \n      const lastRefresh = await clientStorage.getLastFullRefresh();\n      const isStale = lastRefresh > 0 ? clientStorage.isCacheStale(lastRefresh) : true;\n      \n      setBalanceCacheStatus(prev => ({\n        ...prev,\n        isStale,\n        lastUpdated: lastRefresh || null,\n      }));\n      \n      const updatedWallets = currentWallets.map(wallet => {\n        const chain = chains.find(c => c.id === wallet.chainId);\n        if (!chain) return wallet;\n        \n        const cached = cachedBalances.find(\n          c => c.address.toLowerCase() === wallet.address.toLowerCase() && c.chainSymbol === chain.symbol\n        );\n        \n        if (cached) {\n          return { ...wallet, balance: cached.balance };\n        }\n        return wallet;\n      });\n      \n      setWallets([...updatedWallets]);\n      if (walletMode === \"soft_wallet\") {\n        setSoftWallets([...updatedWallets]);\n      } else {\n        setHardWallets([...updatedWallets]);\n      }\n    } catch (err) {\n      console.error(\"Failed to load cached balances:\", err);\n    }\n  }, [walletMode, softWallets, hardWallets, chains]);\n\n  const refreshBalances = useCallback(async () => {\n    isRefreshingRef.current = true;\n    fetchedWalletIdsRef.current = new Set();\n    \n    setBalanceCacheStatus(prev => ({ ...prev, isRefreshing: true }));\n    \n    try {\n      const currentWallets = walletMode === \"soft_wallet\" ? softWallets : hardWallets;\n      \n      if (currentWallets.length === 0 || chains.length === 0) {\n        // No wallets to refresh - clear refreshing but don't update lastUpdated\n        // Keep isStale: false since there's nothing to be stale, but don't claim we just refreshed\n        setBalanceCacheStatus(prev => ({ ...prev, isStale: false, isRefreshing: false }));\n        return;\n      }\n      \n      // Only fetch balances for chains that have enabled assets\n      const enabledChainSymbols = getEnabledChainSymbols(enabledAssetIds);\n      const walletsToRefresh = currentWallets.filter(wallet => {\n        const chain = chains.find(c => c.id === wallet.chainId);\n        return chain && enabledChainSymbols.has(chain.symbol);\n      });\n      \n      // If no wallets match enabled chains, skip refresh but don't mark as stale\n      if (walletsToRefresh.length === 0) {\n        setBalanceCacheStatus(prev => ({ ...prev, isStale: false, isRefreshing: false }));\n        return;\n      }\n      \n      const balancesToCache: Array<{ address: string; chainSymbol: string; chainId: number; balance: string }> = [];\n      \n      const updatedWalletsPartial = await Promise.all(\n        walletsToRefresh.map(async (wallet) => {\n          const chain = chains.find(c => c.id === wallet.chainId);\n          if (!chain) {\n            return wallet;\n          }\n          \n          try {\n            const customRpcUrl = !chain.isDefault && chain.rpcUrl ? chain.rpcUrl : undefined;\n            const balance = await getUniversalBalance(wallet.address, chain.chainId, chain.symbol, customRpcUrl);\n            \n            balancesToCache.push({\n              address: wallet.address,\n              chainSymbol: chain.symbol,\n              chainId: chain.chainId,\n              balance,\n            });\n            \n            return { ...wallet, balance };\n          } catch (err) {\n            console.error(`Failed to fetch balance for ${wallet.address}:`, err);\n            return wallet;\n          }\n        })\n      );\n      \n      // Merge updated wallets with unchanged ones\n      const updatedWalletIds = new Set(updatedWalletsPartial.map(w => w.id));\n      const updatedWallets = currentWallets.map(wallet => {\n        if (updatedWalletIds.has(wallet.id)) {\n          return updatedWalletsPartial.find(w => w.id === wallet.id) || wallet;\n        }\n        return wallet;\n      });\n      \n      // Only update wallets if at least one balance was successfully fetched\n      // This preserves cached balances when all fetches fail\n      if (balancesToCache.length > 0) {\n        setWallets([...updatedWallets]);\n        \n        if (walletMode === \"soft_wallet\") {\n          setSoftWallets([...updatedWallets]);\n        } else {\n          setHardWallets([...updatedWallets]);\n        }\n      }\n      \n      if (storageInitialized && balancesToCache.length > 0) {\n        await clientStorage.setCachedBalances(balancesToCache);\n        \n        const storedWalletsForMode: StoredWallet[] = updatedWallets.map(w => {\n          const chain = chains.find(c => c.id === w.chainId);\n          return {\n            id: w.id,\n            address: w.address,\n            chainId: w.chainId,\n            chainName: chain?.name || \"\",\n            chainSymbol: chain?.symbol || \"\",\n            balance: w.balance,\n            path: \"m/44'/60'/0'/0/0\",\n            lastUpdated: new Date().toISOString(),\n            accountIndex: w.accountIndex ?? 0,\n            label: w.label,\n            walletGroupId: w.walletGroupId,\n          };\n        });\n        \n        if (walletMode === \"soft_wallet\") {\n          await clientStorage.saveSoftWalletData(storedWalletsForMode);\n        } else {\n          await clientStorage.saveHardWalletData(storedWalletsForMode);\n        }\n        \n        // Only mark as fresh if at least one balance was successfully fetched\n        setBalanceCacheStatus({\n          isStale: false,\n          lastUpdated: Date.now(),\n          isRefreshing: false,\n        });\n      } else {\n        // No balances fetched successfully - keep stale state, just clear refreshing\n        setBalanceCacheStatus(prev => ({ ...prev, isRefreshing: false }));\n      }\n    } catch (err: any) {\n      console.error(\"Failed to refresh balances:\", err);\n      setBalanceCacheStatus(prev => ({ ...prev, isRefreshing: false }));\n    } finally {\n      isRefreshingRef.current = false;\n    }\n  }, [chains, storageInitialized, walletMode, softWallets, hardWallets, enabledAssetIds]);\n\n  const refreshWalletBalance = useCallback(async (walletId: string) => {\n    const currentWallets = walletMode === \"soft_wallet\" ? softWallets : hardWallets;\n    const wallet = currentWallets.find(w => w.id === walletId);\n    if (!wallet) return;\n\n    const chain = chains.find(c => c.id === wallet.chainId);\n    if (!chain) return;\n\n    try {\n      const customRpcUrl = !chain.isDefault && chain.rpcUrl ? chain.rpcUrl : undefined;\n      const balance = await getUniversalBalance(wallet.address, chain.chainId, chain.symbol, customRpcUrl);\n\n      const updatedWallet = { ...wallet, balance };\n\n      const updateWalletInList = (list: Wallet[]) =>\n        list.map(w => w.id === walletId ? updatedWallet : w);\n\n      setWallets(prev => updateWalletInList(prev));\n      if (walletMode === \"soft_wallet\") {\n        setSoftWallets(prev => updateWalletInList(prev));\n      } else {\n        setHardWallets(prev => updateWalletInList(prev));\n      }\n\n      if (storageInitialized) {\n        await clientStorage.setCachedBalances([{\n          address: wallet.address,\n          chainSymbol: chain.symbol,\n          chainId: chain.chainId,\n          balance,\n        }]);\n      }\n    } catch (err) {\n      console.error(`Failed to fetch balance for wallet ${walletId}:`, err);\n    }\n  }, [chains, storageInitialized, walletMode, softWallets, hardWallets]);\n\n  const refreshTransactions = useCallback(async () => {\n    if (wallets.length === 0 || chains.length === 0) return;\n    \n    setIsLoadingTransactions(true);\n    try {\n      const walletData = wallets.map(wallet => {\n        const chain = chains.find(c => c.id === wallet.chainId);\n        return {\n          id: wallet.id,\n          address: wallet.address,\n          chainId: wallet.chainId,\n          numericChainId: chain?.chainId || 0,\n          chainSymbol: chain?.symbol || \"ETH\",\n          blockExplorerUrl: chain?.blockExplorer,\n        };\n      });\n      \n      const explorerTxs = await fetchAllTransactions(walletData);\n      \n      const storedTxs = await clientStorage.getAllTransactions();\n      const storedTxHashes = new Set(storedTxs.map(tx => tx.txHash).filter(Boolean));\n      \n      const newExplorerTxs = explorerTxs.filter(tx => !storedTxHashes.has(tx.txHash));\n      \n      const allTxs: Transaction[] = [\n        ...storedTxs.map(tx => ({\n          id: tx.id,\n          walletId: tx.walletId,\n          chainId: tx.chainId,\n          type: tx.type as \"send\" | \"receive\",\n          status: tx.status as \"pending\" | \"confirmed\" | \"failed\",\n          amount: tx.amount,\n          tokenSymbol: tx.tokenSymbol,\n          toAddress: tx.toAddress,\n          fromAddress: tx.fromAddress,\n          txHash: tx.txHash || undefined,\n          gasUsed: tx.gasUsed || undefined,\n          timestamp: tx.timestamp,\n        })),\n        ...newExplorerTxs.map(tx => ({\n          id: tx.id,\n          walletId: tx.walletId,\n          chainId: tx.chainId,\n          type: tx.type,\n          status: tx.status,\n          amount: tx.amount,\n          tokenSymbol: tx.tokenSymbol,\n          toAddress: tx.toAddress,\n          fromAddress: tx.fromAddress,\n          txHash: tx.txHash,\n          gasUsed: undefined,\n          timestamp: tx.timestamp,\n        })),\n      ];\n      \n      allTxs.sort((a, b) => new Date(b.timestamp).getTime() - new Date(a.timestamp).getTime());\n      \n      setTransactions(allTxs);\n    } catch (err) {\n      console.error(\"Failed to refresh transactions:\", err);\n    } finally {\n      setIsLoadingTransactions(false);\n    }\n  }, [wallets, chains]);\n\n  const hasWalletOnDevice = hardwareState.type === \"raspberry_pi\" ? hardwareWallet.hasWalletOnDevice() : true;\n\n  const toggleAssetEnabled = useCallback(async (assetId: string, enabled: boolean) => {\n    const updated = await clientStorage.toggleAsset(assetId, enabled);\n    setEnabledAssetIds(new Set(updated));\n  }, []);\n\n  const refreshTopAssets = useCallback(async () => {\n    setIsLoadingAssets(true);\n    try {\n      const assets = await fetchTopAssets(20);\n      setTopAssets(assets);\n      \n      // Sync enabledAssetIds with new asset list\n      // Keep only IDs that exist in the new assets, preserve user preferences\n      const newAssetIds = new Set(assets.map(a => a.id));\n      setEnabledAssetIds(prev => {\n        const synced = new Set<string>();\n        // Keep enabled IDs that still exist in the new assets\n        for (const id of Array.from(prev)) {\n          if (newAssetIds.has(id)) {\n            synced.add(id);\n          }\n        }\n        // If after sync we lost all enabled assets but had some before, re-enable all\n        if (synced.size === 0 && prev.size > 0) {\n          clientStorage.setEnabledAssets(newAssetIds);\n          return newAssetIds;\n        }\n        // Persist the synced preferences if changed\n        if (synced.size !== prev.size) {\n          clientStorage.setEnabledAssets(synced);\n        }\n        return synced;\n      });\n    } catch (err) {\n      console.error(\"Failed to refresh top assets:\", err);\n    } finally {\n      setIsLoadingAssets(false);\n    }\n  }, []);\n\n  const enableAllAssets = useCallback(async () => {\n    const allIds = new Set(topAssets.map(a => a.id));\n    setEnabledAssetIds(allIds);\n    await clientStorage.setEnabledAssets(allIds);\n  }, [topAssets]);\n\n  const disableAllAssets = useCallback(async () => {\n    setEnabledAssetIds(new Set());\n    await clientStorage.setEnabledAssets(new Set());\n  }, []);\n\n  const loadCustomTokens = useCallback(async () => {\n    try {\n      const tokens = await clientStorage.getCustomTokens();\n      const enrichedTokens = tokens.map(token => {\n        if (token.image) return token;\n        const tokenSymbolUpper = token.symbol.toUpperCase().trim();\n        const matchingAsset = FALLBACK_TOP_ASSETS.find(\n          a => a.symbol.toUpperCase().trim() === tokenSymbolUpper\n        );\n        return {\n          ...token,\n          image: matchingAsset?.image\n        };\n      });\n      setCustomTokens(enrichedTokens);\n    } catch (err) {\n      console.error(\"Failed to load custom tokens:\", err);\n    }\n  }, []);\n\n  const addCustomToken = useCallback(async (token: Omit<CustomToken, 'id' | 'addedAt'>): Promise<CustomToken> => {\n    const newToken = await clientStorage.addCustomToken(token);\n    setCustomTokens(prev => {\n      const existingIndex = prev.findIndex(t => t.id === newToken.id);\n      if (existingIndex >= 0) {\n        const updated = [...prev];\n        updated[existingIndex] = newToken;\n        return updated;\n      }\n      return [...prev, newToken];\n    });\n    return newToken;\n  }, []);\n\n  const removeCustomToken = useCallback(async (id: string): Promise<void> => {\n    await clientStorage.removeCustomToken(id);\n    setCustomTokens(prev => prev.filter(t => t.id !== id));\n  }, []);\n\n  useEffect(() => {\n    if (storageInitialized) {\n      loadCustomTokens();\n    }\n  }, [storageInitialized, loadCustomTokens]);\n\n  const loadCustomChains = useCallback(async () => {\n    try {\n      const chains = await clientStorage.getCustomChains();\n      setCustomChains(chains);\n    } catch (err) {\n      console.error(\"Failed to load custom chains:\", err);\n    }\n  }, []);\n\n  const addCustomChain = useCallback(async (chain: Omit<CustomChain, 'id' | 'addedAt'>): Promise<CustomChain> => {\n    const newChain = await clientStorage.addCustomChain(chain);\n    setCustomChains(prev => {\n      const existingIndex = prev.findIndex(c => c.id === newChain.id);\n      if (existingIndex >= 0) {\n        const updated = [...prev];\n        updated[existingIndex] = newChain;\n        return updated;\n      }\n      return [...prev, newChain];\n    });\n    return newChain;\n  }, []);\n\n  const removeCustomChain = useCallback(async (id: string): Promise<void> => {\n    await clientStorage.removeCustomChain(id);\n    setCustomChains(prev => prev.filter(c => c.id !== id));\n  }, []);\n\n  useEffect(() => {\n    if (storageInitialized && !hasLoadedCustomChainsRef.current) {\n      hasLoadedCustomChainsRef.current = true;\n      loadCustomChains();\n    }\n  }, [storageInitialized, loadCustomChains]);\n\n  // Fetch token balances for enabled tokens\n  useEffect(() => {\n    if (wallets.length === 0 || topAssets.length === 0) return;\n\n    const walletAddresses: Record<string, string> = {};\n    wallets.forEach(w => {\n      const chain = chains.find(c => c.id === w.chainId);\n      if (chain) {\n        walletAddresses[chain.symbol] = w.address;\n      }\n    });\n\n    const fetchTokenBalances = async () => {\n      const tokenAssetIds = topAssets\n        .filter(a => enabledAssetIds.has(a.id) && isTokenAsset(a.id))\n        .map(a => a.id);\n      \n      const balancePromises = tokenAssetIds.map(async (assetId) => {\n        try {\n          const balance = await getTokenBalanceForAsset(assetId, walletAddresses);\n          return [assetId, balance] as [string, string];\n        } catch {\n          return [assetId, \"0\"] as [string, string];\n        }\n      });\n      \n      const results = await Promise.all(balancePromises);\n      const newBalances: Record<string, string> = {};\n      results.forEach(([id, bal]) => {\n        newBalances[id] = bal;\n      });\n      setTokenBalances(newBalances);\n    };\n\n    fetchTokenBalances();\n    const tokenBalanceInterval = setInterval(fetchTokenBalances, 30000);\n    return () => clearInterval(tokenBalanceInterval);\n  }, [wallets.length, topAssets.length, enabledAssetIds.size, chains]);\n\n  // Fetch custom token balances\n  useEffect(() => {\n    if (wallets.length === 0 || customTokens.length === 0) return;\n    \n    // Store wallet addresses by both chain symbol (e.g., \"ETH\") and chain ID (e.g., \"ethereum\")\n    const walletAddresses: Record<string, string> = {};\n    wallets.forEach(w => {\n      const chain = chains.find(c => c.id === w.chainId);\n      if (chain) {\n        walletAddresses[chain.symbol] = w.address;\n        walletAddresses[chain.id] = w.address;\n      }\n    });\n\n    const fetchCustomTokenBalances = async () => {\n      const balancePromises = customTokens.map(async (token) => {\n        // Try both the chain symbol and chain ID to find the wallet address\n        const walletAddress = walletAddresses[token.chainId] || walletAddresses[token.chainId.toUpperCase()];\n        if (!walletAddress) return [token.id, \"0\"] as [string, string];\n        \n        try {\n          const balance = await getCustomTokenBalance(\n            walletAddress,\n            token.contractAddress,\n            token.chainType,\n            token.evmChainId || 0,\n            token.rpcUrl || \"\",\n            token.decimals\n          );\n          return [token.id, balance] as [string, string];\n        } catch {\n          return [token.id, \"0\"] as [string, string];\n        }\n      });\n      \n      const results = await Promise.all(balancePromises);\n      const newBalances: Record<string, string> = {};\n      results.forEach(([id, bal]) => {\n        newBalances[id] = bal;\n      });\n      setCustomTokenBalances(newBalances);\n    };\n\n    fetchCustomTokenBalances();\n    const customTokenBalanceInterval = setInterval(fetchCustomTokenBalances, 30000);\n    return () => clearInterval(customTokenBalanceInterval);\n  }, [wallets.length, customTokens.length, chains]);\n\n  // Secure add chain: verify seed phrase before adding new chain\n  const verifySeedForAddChain = useCallback(async (inputSeedPhrase: string): Promise<boolean> => {\n    if (walletMode !== \"soft_wallet\") {\n      return false;\n    }\n    return await softWallet.verifySeedPhrase(inputSeedPhrase);\n  }, [walletMode]);\n\n  const getSeedWordCount = useCallback((): number | null => {\n    if (walletMode !== \"soft_wallet\") {\n      return null;\n    }\n    return softWallet.getSeedWordCount();\n  }, [walletMode]);\n\n  const confirmAddChain = useCallback(async (customLabel?: string): Promise<boolean> => {\n    if (!pendingAddChain) {\n      return false;\n    }\n\n    try {\n      // Derive wallet for the pending chain\n      const chainId = pendingAddChain.chainId;\n      const targetChain = chains.find(c => c.id === chainId);\n      if (!targetChain) {\n        setPendingAddChain(null);\n        return false;\n      }\n\n      let derivedAddress: string | null = null;\n      \n      if (walletMode === \"soft_wallet\") {\n        // Derive address using soft wallet\n        const addresses = await softWallet.deriveAddresses([targetChain.symbol], 0);\n        if (addresses.length === 0) {\n          setPendingAddChain(null);\n          return false;\n        }\n        derivedAddress = addresses[0].address;\n      } else {\n        // Derive address using hardware wallet\n        const mnemonic = await hardwareWallet.getSeedPhraseFromDevice();\n        if (!mnemonic) {\n          setPendingAddChain(null);\n          return false;\n        }\n        const derivedAddresses = await deriveAllAddresses(mnemonic, [targetChain.symbol], 0);\n        if (derivedAddresses.length === 0 || !derivedAddresses[0].address) {\n          setPendingAddChain(null);\n          return false;\n        }\n        derivedAddress = derivedAddresses[0].address;\n      }\n\n      const newWallet: Wallet = {\n        id: `wallet-${chainId}-${Date.now()}`,\n        deviceId: walletMode === \"soft_wallet\" ? \"soft\" : \"hard\",\n        chainId: chainId,\n        address: derivedAddress,\n        balance: \"0\",\n        isActive: true,\n        accountIndex: 0,\n        label: customLabel || targetChain.name,\n      };\n\n      // Update state\n      const currentWallets = walletMode === \"soft_wallet\" ? softWallets : hardWallets;\n      const updatedWallets = [...currentWallets, newWallet];\n      \n      if (walletMode === \"soft_wallet\") {\n        setSoftWallets(updatedWallets);\n      } else {\n        setHardWallets(updatedWallets);\n      }\n      setWallets(updatedWallets);\n\n      // Save to storage\n      if (storageInitialized) {\n        const walletsToSave: StoredWallet[] = updatedWallets.map(w => {\n          const chain = chains.find(c => c.id === w.chainId);\n          return {\n            id: w.id,\n            chainId: w.chainId,\n            chainName: chain?.name || \"\",\n            chainSymbol: chain?.symbol || \"\",\n            address: w.address,\n            balance: w.balance,\n            path: `m/44'/${chain?.symbol === 'ETH' ? '60' : chain?.symbol === 'BTC' ? '0' : '501'}'/0'/0/${w.accountIndex}`,\n            lastUpdated: new Date().toISOString(),\n            accountIndex: w.accountIndex,\n            label: w.label,\n          };\n        });\n        \n        if (walletMode === \"soft_wallet\") {\n          await clientStorage.saveSoftWalletData(walletsToSave);\n        } else {\n          await clientStorage.saveHardWalletData(walletsToSave);\n          \n          // Save chain preferences to hardware for portability\n          const chainPrefs = updatedWallets.map(w => {\n            const chain = chains.find(c => c.id === w.chainId);\n            return {\n              symbol: chain?.symbol || \"\",\n              accountIndex: w.accountIndex,\n              label: w.label,\n            };\n          });\n          await hardwareWallet.saveChainPreferences(chainPrefs);\n        }\n      }\n\n      setPendingAddChain(null);\n      return true;\n    } catch (err) {\n      console.error(\"Failed to add chain:\", err);\n      setPendingAddChain(null);\n      return false;\n    }\n  }, [pendingAddChain, chains, walletMode, softWallets, hardWallets, storageInitialized]);\n\n  const abortAddChain = useCallback(() => {\n    setPendingAddChain(null);\n  }, []);\n\n  // Rename wallet\n  const renameWallet = useCallback(async (walletId: string, newLabel: string): Promise<void> => {\n    const currentWallets = walletMode === \"soft_wallet\" ? softWallets : hardWallets;\n    const updatedWallets = currentWallets.map(w => \n      w.id === walletId ? { ...w, label: newLabel } : w\n    );\n\n    if (walletMode === \"soft_wallet\") {\n      setSoftWallets(updatedWallets);\n    } else {\n      setHardWallets(updatedWallets);\n    }\n    setWallets(updatedWallets);\n\n    // Save to storage\n    if (storageInitialized) {\n      const walletsToSave: StoredWallet[] = updatedWallets.map(w => {\n        const chain = chains.find(c => c.id === w.chainId);\n        return {\n          id: w.id,\n          chainId: w.chainId,\n          chainName: chain?.name || \"\",\n          chainSymbol: chain?.symbol || \"\",\n          address: w.address,\n          balance: w.balance,\n          path: `m/44'/${chain?.symbol === 'ETH' ? '60' : chain?.symbol === 'BTC' ? '0' : '501'}'/0'/0/${w.accountIndex}`,\n          lastUpdated: new Date().toISOString(),\n          accountIndex: w.accountIndex,\n          label: w.label,\n        };\n      });\n      \n      if (walletMode === \"soft_wallet\") {\n        await clientStorage.saveSoftWalletData(walletsToSave);\n      } else {\n        await clientStorage.saveHardWalletData(walletsToSave);\n        \n        // Save chain preferences to hardware for portability\n        const chainPrefs = updatedWallets.map(w => {\n          const chain = chains.find(c => c.id === w.chainId);\n          return {\n            symbol: chain?.symbol || \"\",\n            accountIndex: w.accountIndex,\n            label: w.label,\n          };\n        });\n        await hardwareWallet.saveChainPreferences(chainPrefs);\n      }\n    }\n  }, [walletMode, softWallets, hardWallets, chains, storageInitialized]);\n\n  const createAdditionalWallet = useCallback(async (label?: string, chainId?: string) => {\n    // Check unlock status based on wallet mode\n    if (walletMode === \"soft_wallet\") {\n      if (softWallet.getState().status !== \"unlocked\") {\n        const errorMsg = \"Wallet must be unlocked to create additional wallet\";\n        setError(errorMsg);\n        throw new Error(errorMsg);\n      }\n    } else {\n      const currentState = hardwareWallet.getState();\n      if (currentState.status !== \"unlocked\") {\n        const errorMsg = \"Device must be unlocked to create additional wallet\";\n        setError(errorMsg);\n        throw new Error(errorMsg);\n      }\n    }\n\n    setIsLoading(true);\n    try {\n      let mnemonic: string | null;\n      if (walletMode === \"soft_wallet\") {\n        mnemonic = softWallet.getSeedPhrase();\n      } else {\n        mnemonic = await hardwareWallet.getSeedPhraseFromDevice();\n      }\n      if (!mnemonic) {\n        throw new Error(\"Cannot access seed phrase\");\n      }\n\n      const currentChains = chains.length > 0 ? chains : DEFAULT_CHAINS.map((c, i) => ({\n        ...c,\n        id: `chain-${i}`,\n      }));\n\n      // Get current wallets from storage (source of truth for sequential adds)\n      const currentData = walletMode === \"soft_wallet\"\n        ? await clientStorage.getSoftWalletData()\n        : await clientStorage.getHardWalletData();\n      \n      // Convert stored wallets to Wallet objects for merging\n      const existingWallets: Wallet[] = currentData.map(w => ({\n        id: w.id,\n        deviceId: walletMode === \"soft_wallet\" ? \"soft\" : \"hard\",\n        chainId: w.chainId,\n        address: w.address,\n        balance: w.balance || \"0\",\n        isActive: true,\n        accountIndex: w.accountIndex ?? 0,\n        label: w.label,\n      }));\n\n      // If chainId provided, get next index for that specific chain only\n      const chainWallets = chainId \n        ? currentData.filter(w => w.chainId === chainId)\n        : currentData;\n      const nextIndex = chainWallets.length > 0 \n        ? Math.max(...chainWallets.map(w => w.accountIndex ?? 0)) + 1 \n        : 0;\n\n      // Determine which chains to create wallets for\n      const targetChains = chainId \n        ? currentChains.filter(c => c.id === chainId)\n        : currentChains;\n      \n      if (targetChains.length === 0) {\n        throw new Error(\"Invalid chain selected\");\n      }\n\n      // Derive addresses only for target chain(s)\n      const chainSymbols = targetChains.map(c => c.symbol);\n      const derivedAddresses = await deriveAllAddresses(mnemonic, chainSymbols, nextIndex);\n\n      // Create wallet objects with accountIndex and label\n      const newWallets: Wallet[] = [];\n      for (const derived of derivedAddresses) {\n        const chain = targetChains.find(c => c.symbol === derived.chainSymbol);\n        if (!chain || !derived.address) continue;\n\n        const walletId = `wallet-${chain.id}-${derived.address.slice(0, 8)}-${nextIndex}`;\n\n        const wallet: Wallet = {\n          id: walletId,\n          deviceId: walletMode === \"soft_wallet\" ? \"soft\" : \"hard\",\n          chainId: chain.id,\n          address: derived.address,\n          balance: \"0\",\n          isActive: true,\n          accountIndex: nextIndex,\n          label: label || `Wallet ${nextIndex + 1}`,\n        };\n\n        newWallets.push(wallet);\n      }\n\n      // Merge with existing wallets from storage (not stale state)\n      const mergedWallets = [...existingWallets, ...newWallets];\n      setWallets(mergedWallets);\n\n      // Save to mode-specific storage with accountIndex and label\n      if (storageInitialized) {\n        const storedWalletsForMode: StoredWallet[] = mergedWallets.map(w => {\n          const chain = currentChains.find(c => c.id === w.chainId);\n          return {\n            id: w.id,\n            address: w.address,\n            chainId: w.chainId,\n            chainName: chain?.name || \"\",\n            chainSymbol: chain?.symbol || \"\",\n            balance: w.balance,\n            path: `m/44'/60'/${w.accountIndex ?? 0}'/0/0`,\n            lastUpdated: new Date().toISOString(),\n            accountIndex: w.accountIndex ?? 0,\n            label: w.label,\n          };\n        });\n\n        if (walletMode === \"soft_wallet\") {\n          await clientStorage.saveSoftWalletData(storedWalletsForMode);\n          setSoftWallets(mergedWallets);\n        } else {\n          await clientStorage.saveHardWalletData(storedWalletsForMode);\n          setHardWallets(mergedWallets);\n        }\n      }\n    } catch (err: any) {\n      setError(err.message || \"Failed to create additional wallet\");\n      throw err;\n    } finally {\n      setIsLoading(false);\n    }\n  }, [chains, wallets, walletMode, storageInitialized]);\n\n  // Generate a new seed phrase (for UI to display before confirming)\n  const generateNewSeedPhrase = useCallback((): string => {\n    return softWallet.generateNewSeedPhrase();\n  }, []);\n\n  // Create a wallet with a completely new independent seed phrase\n  const createWalletWithNewSeed = useCallback(async (label?: string, pin?: string): Promise<{ seedPhrase: string; walletGroupId: string }> => {\n    if (walletMode !== \"soft_wallet\") {\n      throw new Error(\"Independent seed wallets are only available in soft wallet mode\");\n    }\n    \n    if (!pin) {\n      throw new Error(\"PIN is required to encrypt the new seed phrase\");\n    }\n\n    setIsLoading(true);\n    try {\n      // Generate new seed phrase\n      const newSeedPhrase = softWallet.generateNewSeedPhrase();\n      const walletGroupId = `wallet-group-${Date.now()}`;\n\n      // Encrypt and store the new seed\n      const { encryptedSeed, pinHash, pinSalt } = await softWallet.encryptSeedForWalletGroup(\n        newSeedPhrase,\n        pin,\n        walletGroupId\n      );\n\n      await clientStorage.saveWalletSeed({\n        walletGroupId,\n        encryptedSeed,\n        pinHash,\n        pinSalt,\n        createdAt: new Date().toISOString(),\n      });\n\n      const currentChains = chains.length > 0 ? chains : DEFAULT_CHAINS.map((c, i) => ({\n        ...c,\n        id: `chain-${i}`,\n      }));\n\n      // Get current wallets to find next account index\n      const currentData = await clientStorage.getSoftWalletData();\n      const nextIndex = clientStorage.getNextAccountIndex(currentData);\n\n      // Derive addresses for all chains with the new seed (accountIndex 0 for this seed)\n      const chainSymbols = currentChains.map(c => c.symbol);\n      const derivedAddresses = await deriveAllAddresses(newSeedPhrase, chainSymbols, 0);\n\n      // Create wallet objects with the new walletGroupId\n      const newWallets: Wallet[] = [];\n      for (const derived of derivedAddresses) {\n        const chain = currentChains.find(c => c.symbol === derived.chainSymbol);\n        if (!chain || !derived.address) continue;\n\n        const walletId = `wallet-${chain.id}-${derived.address.slice(0, 8)}-${nextIndex}`;\n\n        const wallet: Wallet = {\n          id: walletId,\n          deviceId: \"soft\",\n          chainId: chain.id,\n          address: derived.address,\n          balance: \"0\",\n          isActive: true,\n          accountIndex: nextIndex,\n          label: label || `Wallet ${nextIndex + 1}`,\n          walletGroupId,\n        };\n\n        newWallets.push(wallet);\n      }\n\n      // Merge with existing wallets\n      const mergedWallets = [...wallets, ...newWallets];\n      setWallets(mergedWallets);\n\n      // Save to storage\n      if (storageInitialized) {\n        const storedWalletsForMode: StoredWallet[] = mergedWallets.map(w => {\n          const chain = currentChains.find(c => c.id === w.chainId);\n          return {\n            id: w.id,\n            address: w.address,\n            chainId: w.chainId,\n            chainName: chain?.name || \"\",\n            chainSymbol: chain?.symbol || \"\",\n            balance: w.balance,\n            path: `m/44'/60'/${w.accountIndex ?? 0}'/0/0`,\n            lastUpdated: new Date().toISOString(),\n            accountIndex: w.accountIndex ?? 0,\n            label: w.label,\n            walletGroupId: w.walletGroupId,\n          };\n        });\n\n        await clientStorage.saveSoftWalletData(storedWalletsForMode);\n        setSoftWallets(mergedWallets);\n      }\n\n      return { seedPhrase: newSeedPhrase, walletGroupId };\n    } catch (err: any) {\n      setError(err.message || \"Failed to create wallet with new seed\");\n      throw err;\n    } finally {\n      setIsLoading(false);\n    }\n  }, [chains, wallets, walletMode, storageInitialized]);\n\n  return (\n    <WalletContext.Provider\n      value={{\n        hardwareState,\n        isConnected,\n        isUnlocked,\n        hasWalletOnDevice,\n        walletMode,\n        setWalletMode,\n        hasSoftWalletSetup,\n        hasHardWalletSetup,\n        currentModeHasWallet,\n        chains,\n        wallets,\n        setWallets,\n        transactions,\n        setTransactions,\n        tokens,\n        setTokens,\n        selectedChainId,\n        setSelectedChainId,\n        showPinModal,\n        setShowPinModal,\n        pinAction,\n        setPinAction,\n        pendingTransaction,\n        setPendingTransaction,\n        connectLedger,\n        connectRaspberryPi,\n        connectSimulated,\n        unlockWallet,\n        lockWallet,\n        disconnectDevice,\n        deriveWallets,\n        refreshBalances,\n        refreshWalletBalance,\n        refreshTransactions,\n        resetSessionTimeout,\n        isLoading,\n        isLoadingTransactions,\n        error,\n        topAssets,\n        enabledAssetIds,\n        isLoadingAssets,\n        toggleAssetEnabled,\n        refreshTopAssets,\n        enableAllAssets,\n        disableAllAssets,\n        createAdditionalWallet,\n        createWalletWithNewSeed,\n        generateNewSeedPhrase,\n        selectedAccountIndex,\n        setSelectedAccountIndex,\n        availableAccounts,\n        visibleWallets,\n        customTokens,\n        loadCustomTokens,\n        addCustomToken,\n        removeCustomToken,\n        tokenBalances,\n        setTokenBalances,\n        customTokenBalances,\n        setCustomTokenBalances,\n        customChains,\n        loadCustomChains,\n        addCustomChain,\n        removeCustomChain,\n        balanceCacheStatus,\n        pendingAddChain,\n        setPendingAddChain,\n        verifySeedForAddChain,\n        confirmAddChain,\n        abortAddChain,\n        getSeedWordCount,\n        renameWallet,\n      }}\n    >\n      {children}\n    </WalletContext.Provider>\n  );\n}\n\nexport function useWallet() {\n  const context = useContext(WalletContext);\n  if (!context) {\n    throw new Error(\"useWallet must be used within WalletProvider\");\n  }\n  return context;\n}\n","path":null,"size_bytes":78440,"size_tokens":null},"client/src/components/ui/context-menu.tsx":{"content":"import * as React from \"react\"\nimport * as ContextMenuPrimitive from \"@radix-ui/react-context-menu\"\nimport { Check, ChevronRight, Circle } from \"lucide-react\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst ContextMenu = ContextMenuPrimitive.Root\n\nconst ContextMenuTrigger = ContextMenuPrimitive.Trigger\n\nconst ContextMenuGroup = ContextMenuPrimitive.Group\n\nconst ContextMenuPortal = ContextMenuPrimitive.Portal\n\nconst ContextMenuSub = ContextMenuPrimitive.Sub\n\nconst ContextMenuRadioGroup = ContextMenuPrimitive.RadioGroup\n\nconst ContextMenuSubTrigger = React.forwardRef<\n  React.ElementRef<typeof ContextMenuPrimitive.SubTrigger>,\n  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.SubTrigger> & {\n    inset?: boolean\n  }\n>(({ className, inset, children, ...props }, ref) => (\n  <ContextMenuPrimitive.SubTrigger\n    ref={ref}\n    className={cn(\n      \"flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[state=open]:bg-accent data-[state=open]:text-accent-foreground\",\n      inset && \"pl-8\",\n      className\n    )}\n    {...props}\n  >\n    {children}\n    <ChevronRight className=\"ml-auto h-4 w-4\" />\n  </ContextMenuPrimitive.SubTrigger>\n))\nContextMenuSubTrigger.displayName = ContextMenuPrimitive.SubTrigger.displayName\n\nconst ContextMenuSubContent = React.forwardRef<\n  React.ElementRef<typeof ContextMenuPrimitive.SubContent>,\n  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.SubContent>\n>(({ className, ...props }, ref) => (\n  <ContextMenuPrimitive.SubContent\n    ref={ref}\n    className={cn(\n      \"z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 origin-[--radix-context-menu-content-transform-origin]\",\n      className\n    )}\n    {...props}\n  />\n))\nContextMenuSubContent.displayName = ContextMenuPrimitive.SubContent.displayName\n\nconst ContextMenuContent = React.forwardRef<\n  React.ElementRef<typeof ContextMenuPrimitive.Content>,\n  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.Content>\n>(({ className, ...props }, ref) => (\n  <ContextMenuPrimitive.Portal>\n    <ContextMenuPrimitive.Content\n      ref={ref}\n      className={cn(\n        \"z-50 max-h-[--radix-context-menu-content-available-height] min-w-[8rem] overflow-y-auto overflow-x-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-md animate-in fade-in-80 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 origin-[--radix-context-menu-content-transform-origin]\",\n        className\n      )}\n      {...props}\n    />\n  </ContextMenuPrimitive.Portal>\n))\nContextMenuContent.displayName = ContextMenuPrimitive.Content.displayName\n\nconst ContextMenuItem = React.forwardRef<\n  React.ElementRef<typeof ContextMenuPrimitive.Item>,\n  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.Item> & {\n    inset?: boolean\n  }\n>(({ className, inset, ...props }, ref) => (\n  <ContextMenuPrimitive.Item\n    ref={ref}\n    className={cn(\n      \"relative flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50\",\n      inset && \"pl-8\",\n      className\n    )}\n    {...props}\n  />\n))\nContextMenuItem.displayName = ContextMenuPrimitive.Item.displayName\n\nconst ContextMenuCheckboxItem = React.forwardRef<\n  React.ElementRef<typeof ContextMenuPrimitive.CheckboxItem>,\n  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.CheckboxItem>\n>(({ className, children, checked, ...props }, ref) => (\n  <ContextMenuPrimitive.CheckboxItem\n    ref={ref}\n    className={cn(\n      \"relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50\",\n      className\n    )}\n    checked={checked}\n    {...props}\n  >\n    <span className=\"absolute left-2 flex h-3.5 w-3.5 items-center justify-center\">\n      <ContextMenuPrimitive.ItemIndicator>\n        <Check className=\"h-4 w-4\" />\n      </ContextMenuPrimitive.ItemIndicator>\n    </span>\n    {children}\n  </ContextMenuPrimitive.CheckboxItem>\n))\nContextMenuCheckboxItem.displayName =\n  ContextMenuPrimitive.CheckboxItem.displayName\n\nconst ContextMenuRadioItem = React.forwardRef<\n  React.ElementRef<typeof ContextMenuPrimitive.RadioItem>,\n  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.RadioItem>\n>(({ className, children, ...props }, ref) => (\n  <ContextMenuPrimitive.RadioItem\n    ref={ref}\n    className={cn(\n      \"relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50\",\n      className\n    )}\n    {...props}\n  >\n    <span className=\"absolute left-2 flex h-3.5 w-3.5 items-center justify-center\">\n      <ContextMenuPrimitive.ItemIndicator>\n        <Circle className=\"h-2 w-2 fill-current\" />\n      </ContextMenuPrimitive.ItemIndicator>\n    </span>\n    {children}\n  </ContextMenuPrimitive.RadioItem>\n))\nContextMenuRadioItem.displayName = ContextMenuPrimitive.RadioItem.displayName\n\nconst ContextMenuLabel = React.forwardRef<\n  React.ElementRef<typeof ContextMenuPrimitive.Label>,\n  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.Label> & {\n    inset?: boolean\n  }\n>(({ className, inset, ...props }, ref) => (\n  <ContextMenuPrimitive.Label\n    ref={ref}\n    className={cn(\n      \"px-2 py-1.5 text-sm font-semibold text-foreground\",\n      inset && \"pl-8\",\n      className\n    )}\n    {...props}\n  />\n))\nContextMenuLabel.displayName = ContextMenuPrimitive.Label.displayName\n\nconst ContextMenuSeparator = React.forwardRef<\n  React.ElementRef<typeof ContextMenuPrimitive.Separator>,\n  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.Separator>\n>(({ className, ...props }, ref) => (\n  <ContextMenuPrimitive.Separator\n    ref={ref}\n    className={cn(\"-mx-1 my-1 h-px bg-border\", className)}\n    {...props}\n  />\n))\nContextMenuSeparator.displayName = ContextMenuPrimitive.Separator.displayName\n\nconst ContextMenuShortcut = ({\n  className,\n  ...props\n}: React.HTMLAttributes<HTMLSpanElement>) => {\n  return (\n    <span\n      className={cn(\n        \"ml-auto text-xs tracking-widest text-muted-foreground\",\n        className\n      )}\n      {...props}\n    />\n  )\n}\nContextMenuShortcut.displayName = \"ContextMenuShortcut\"\n\nexport {\n  ContextMenu,\n  ContextMenuTrigger,\n  ContextMenuContent,\n  ContextMenuItem,\n  ContextMenuCheckboxItem,\n  ContextMenuRadioItem,\n  ContextMenuLabel,\n  ContextMenuSeparator,\n  ContextMenuShortcut,\n  ContextMenuGroup,\n  ContextMenuPortal,\n  ContextMenuSub,\n  ContextMenuSubContent,\n  ContextMenuSubTrigger,\n  ContextMenuRadioGroup,\n}\n","path":null,"size_bytes":7428,"size_tokens":null},"client/src/components/ui/tabs.tsx":{"content":"import * as React from \"react\"\nimport * as TabsPrimitive from \"@radix-ui/react-tabs\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst Tabs = TabsPrimitive.Root\n\nconst TabsList = React.forwardRef<\n  React.ElementRef<typeof TabsPrimitive.List>,\n  React.ComponentPropsWithoutRef<typeof TabsPrimitive.List>\n>(({ className, ...props }, ref) => (\n  <TabsPrimitive.List\n    ref={ref}\n    className={cn(\n      \"inline-flex h-10 items-center justify-center rounded-md bg-muted p-1 text-muted-foreground\",\n      className\n    )}\n    {...props}\n  />\n))\nTabsList.displayName = TabsPrimitive.List.displayName\n\nconst TabsTrigger = React.forwardRef<\n  React.ElementRef<typeof TabsPrimitive.Trigger>,\n  React.ComponentPropsWithoutRef<typeof TabsPrimitive.Trigger>\n>(({ className, ...props }, ref) => (\n  <TabsPrimitive.Trigger\n    ref={ref}\n    className={cn(\n      \"inline-flex items-center justify-center whitespace-nowrap rounded-sm px-3 py-1.5 text-sm font-medium ring-offset-background transition-all focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 data-[state=active]:bg-background data-[state=active]:text-foreground data-[state=active]:shadow-sm\",\n      className\n    )}\n    {...props}\n  />\n))\nTabsTrigger.displayName = TabsPrimitive.Trigger.displayName\n\nconst TabsContent = React.forwardRef<\n  React.ElementRef<typeof TabsPrimitive.Content>,\n  React.ComponentPropsWithoutRef<typeof TabsPrimitive.Content>\n>(({ className, ...props }, ref) => (\n  <TabsPrimitive.Content\n    ref={ref}\n    className={cn(\n      \"mt-2 ring-offset-background focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2\",\n      className\n    )}\n    {...props}\n  />\n))\nTabsContent.displayName = TabsPrimitive.Content.displayName\n\nexport { Tabs, TabsList, TabsTrigger, TabsContent }\n","path":null,"size_bytes":1883,"size_tokens":null},"client/src/components/hardware-status.tsx":{"content":"import { useState } from \"react\";\nimport { motion } from \"framer-motion\";\nimport { Usb, Lock, Unlock, Shield, Unplug, RotateCcw, AlertTriangle, Laptop, Cpu, Copy, Check, Plus, Download, Smartphone } from \"lucide-react\";\nimport { Button } from \"@/components/ui/button\";\nimport { Badge } from \"@/components/ui/badge\";\nimport { Input } from \"@/components/ui/input\";\nimport { Label } from \"@/components/ui/label\";\nimport { Alert, AlertDescription } from \"@/components/ui/alert\";\nimport { Checkbox } from \"@/components/ui/checkbox\";\nimport {\n  Dialog,\n  DialogContent,\n  DialogDescription,\n  DialogHeader,\n  DialogTitle,\n  DialogFooter,\n} from \"@/components/ui/dialog\";\nimport { Tabs, TabsContent, TabsList, TabsTrigger } from \"@/components/ui/tabs\";\nimport { ScrollArea } from \"@/components/ui/scroll-area\";\nimport { useWallet } from \"@/lib/wallet-context\";\nimport { useToast } from \"@/hooks/use-toast\";\nimport { hardwareWallet } from \"@/lib/hardware-wallet\";\nimport { softWallet } from \"@/lib/soft-wallet\";\nimport { ethers } from \"ethers\";\nimport { DEFAULT_CHAINS } from \"@shared/schema\";\nimport { ChainIcon } from \"@/components/chain-icon\";\n\nfunction getChainIcon(symbol: string) {\n  return <ChainIcon symbol={symbol} size=\"sm\" />;\n}\n\nexport function HardwareStatus() {\n  const { \n    isConnected, \n    isUnlocked, \n    hardwareState,\n    setShowPinModal,\n    setPinAction,\n    lockWallet,\n    connectRaspberryPi,\n    connectLedger,\n    connectSimulated,\n    unlockWallet,\n    deriveWallets,\n    isLoading,\n    walletMode,\n    setWalletMode,\n  } = useWallet();\n  const { toast } = useToast();\n  \n  const [showHeaderSetupDialog, setShowHeaderSetupDialog] = useState(false);\n  const [showHeaderPicoSetupDialog, setShowHeaderPicoSetupDialog] = useState(false);\n  const [headerSetupTab, setHeaderSetupTab] = useState<\"hard_wallet\" | \"soft_wallet\">(\"soft_wallet\");\n  \n  // Soft wallet wizard states - chain selection is first step\n  const [softWalletStep, setSoftWalletStep] = useState<\"select-chains\" | \"choose\" | \"display\" | \"confirm\" | \"pin\">(\"select-chains\");\n  const [softWalletWordCount, setSoftWalletWordCount] = useState<12 | 24>(24);\n  const [softWalletGeneratedSeed, setSoftWalletGeneratedSeed] = useState(\"\");\n  const [softWalletSeedConfirmed, setSoftWalletSeedConfirmed] = useState(false);\n  const [softWalletCopied, setSoftWalletCopied] = useState(false);\n  const [softWalletMode, setSoftWalletMode] = useState<\"create\" | \"import\">(\"create\");\n  const [softWalletImportSeed, setSoftWalletImportSeed] = useState(\"\");\n  const [softWalletSelectedChains, setSoftWalletSelectedChains] = useState<Set<string>>(new Set());\n  \n  // Form states for soft wallet\n  const [softWalletPin, setSoftWalletPin] = useState(\"\");\n  const [softWalletConfirmPin, setSoftWalletConfirmPin] = useState(\"\");\n  const [softWalletError, setSoftWalletError] = useState(\"\");\n  const [softWalletLoading, setSoftWalletLoading] = useState(false);\n  \n  // Form states for Pico setup - multi-step wizard\n  const [headerPicoStep, setHeaderPicoStep] = useState<\"choose\" | \"display\" | \"confirm\" | \"pin\">(\"choose\");\n  const [headerPicoWordCount, setHeaderPicoWordCount] = useState<12 | 24>(24);\n  const [headerPicoGeneratedSeed, setHeaderPicoGeneratedSeed] = useState(\"\");\n  const [headerPicoSeedConfirmed, setHeaderPicoSeedConfirmed] = useState(false);\n  const [headerPicoCopied, setHeaderPicoCopied] = useState(false);\n  const [headerPicoPin, setHeaderPicoPin] = useState(\"\");\n  const [headerPicoConfirmPin, setHeaderPicoConfirmPin] = useState(\"\");\n  const [headerPicoError, setHeaderPicoError] = useState(\"\");\n  const [headerPicoLoading, setHeaderPicoLoading] = useState(false);\n  const [headerPicoMode, setHeaderPicoMode] = useState<\"create\" | \"import\">(\"create\");\n  const [headerPicoImportSeed, setHeaderPicoImportSeed] = useState(\"\");\n\n  const handleConnect = () => {\n    console.log(\"[HardwareStatus] handleConnect() - isConnected:\", isConnected, \"isUnlocked:\", isUnlocked);\n    if (!isConnected) {\n      console.log(\"[HardwareStatus] Not connected - showing setup dialog\");\n      // Set the dialog tab to match the current wallet mode\n      setHeaderSetupTab(walletMode);\n      // Pre-select default chains (ETH, BTC, BNB, TRX) using chain-${index} format\n      const popularChains = new Set<string>();\n      DEFAULT_CHAINS.forEach((chain, index) => {\n        if (['ETH', 'BTC', 'BNB', 'TRX'].includes(chain.symbol)) {\n          popularChains.add(`chain-${index}`);\n        }\n      });\n      setSoftWalletSelectedChains(popularChains);\n      setSoftWalletStep(\"select-chains\");\n      setShowHeaderSetupDialog(true);\n    } else if (!isUnlocked) {\n      console.log(\"[HardwareStatus] Connected but locked - showing PIN unlock\");\n      setPinAction(\"unlock\");\n      setShowPinModal(true);\n    }\n  };\n  \n  const handleHeaderConnectRaspberryPi = async () => {\n    console.log(\"[HardwareStatus] handleHeaderConnectRaspberryPi() called\");\n    const result = await connectRaspberryPi();\n    console.log(\"[HardwareStatus] connectRaspberryPi result:\", result);\n    \n    if (result.success) {\n      setShowHeaderSetupDialog(false);\n      \n      if (!result.hasWallet) {\n        console.log(\"[HardwareStatus] NEW DEVICE - showing wallet setup\");\n        toast({\n          title: \"New Device Detected\",\n          description: \"This is a new device. Let's set up your wallet.\",\n        });\n        // Reset all Pico setup state\n        setHeaderPicoStep(\"choose\");\n        setHeaderPicoMode(\"create\");\n        setHeaderPicoWordCount(24);\n        setHeaderPicoGeneratedSeed(\"\");\n        setHeaderPicoSeedConfirmed(false);\n        setHeaderPicoCopied(false);\n        setHeaderPicoPin(\"\");\n        setHeaderPicoConfirmPin(\"\");\n        setHeaderPicoError(\"\");\n        setHeaderPicoImportSeed(\"\");\n        setShowHeaderPicoSetupDialog(true);\n      } else {\n        console.log(\"[HardwareStatus] EXISTING WALLET - showing PIN unlock\");\n        toast({\n          title: \"Wallet Found\",\n          description: \"Existing wallet detected. Please enter your PIN to unlock.\",\n        });\n        setPinAction(\"unlock\");\n        setShowPinModal(true);\n      }\n    } else {\n      console.log(\"[HardwareStatus] Connection failed:\", result.error);\n      toast({\n        title: \"Connection Failed\",\n        description: result.error || \"Failed to connect\",\n        variant: \"destructive\",\n      });\n    }\n  };\n  \n  const handleHeaderConnectLedger = async () => {\n    const success = await connectLedger();\n    if (success) {\n      setShowHeaderSetupDialog(false);\n      toast({ title: \"Ledger Connected\", description: \"Please enter your PIN to unlock.\" });\n      setPinAction(\"unlock\");\n      setShowPinModal(true);\n    } else if (hardwareState.error) {\n      toast({ title: \"Connection Failed\", description: hardwareState.error, variant: \"destructive\" });\n    }\n  };\n  \n  // Soft wallet wizard functions\n  const handleSoftWalletGenerateSeed = () => {\n    try {\n      let phrase: string;\n      if (softWalletWordCount === 12) {\n        const entropy = ethers.randomBytes(16);\n        phrase = ethers.Mnemonic.entropyToPhrase(entropy);\n      } else {\n        const entropy = ethers.randomBytes(32);\n        phrase = ethers.Mnemonic.entropyToPhrase(entropy);\n      }\n      setSoftWalletGeneratedSeed(phrase);\n      setSoftWalletStep(\"display\");\n    } catch (error: any) {\n      setSoftWalletError(\"Failed to generate seed phrase\");\n    }\n  };\n\n  const handleSoftWalletCopySeed = async () => {\n    try {\n      await navigator.clipboard.writeText(softWalletGeneratedSeed);\n      setSoftWalletCopied(true);\n      setTimeout(() => setSoftWalletCopied(false), 2000);\n    } catch {\n      toast({ title: \"Copy failed\", description: \"Please manually select and copy\", variant: \"destructive\" });\n    }\n  };\n\n  // Validate chain selection and proceed to recovery phrase step\n  const handleConfirmChainSelection = () => {\n    if (softWalletSelectedChains.size === 0) {\n      setSoftWalletError(\"Please select at least one chain.\");\n      return;\n    }\n    setSoftWalletError(\"\");\n    setSoftWalletStep(\"choose\");\n  };\n\n  // Validate PIN and create wallet\n  const handleValidatePinAndCreateWallet = () => {\n    setSoftWalletError(\"\");\n    \n    const seedToUse = softWalletMode === \"create\" ? softWalletGeneratedSeed : softWalletImportSeed;\n    \n    if (!seedToUse || seedToUse.trim().length === 0) {\n      setSoftWalletError(\"No recovery phrase found. Please go back and generate one.\");\n      return;\n    }\n    \n    const words = seedToUse.trim().toLowerCase().split(/\\s+/);\n    \n    if (words.length !== 12 && words.length !== 24) {\n      setSoftWalletError(\"Recovery phrase must be 12 or 24 words.\");\n      return;\n    }\n    if (softWalletPin.length !== 5 || !/^\\d+$/.test(softWalletPin)) {\n      setSoftWalletError(\"PIN must be 5 digits.\");\n      return;\n    }\n    if (softWalletPin !== softWalletConfirmPin) {\n      setSoftWalletError(\"PINs do not match.\");\n      return;\n    }\n    \n    // Proceed to create wallet\n    handleSetupSoftWallet();\n  };\n\n  const handleSetupSoftWallet = async () => {\n    console.log(\"[handleSetupSoftWallet] Starting soft wallet setup\");\n    setSoftWalletError(\"\");\n    \n    if (softWalletSelectedChains.size === 0) {\n      setSoftWalletError(\"Please select at least one chain.\");\n      return;\n    }\n    \n    const seedToUse = softWalletMode === \"create\" ? softWalletGeneratedSeed : softWalletImportSeed;\n    const words = seedToUse.trim().toLowerCase().split(/\\s+/);\n    \n    setSoftWalletLoading(true);\n    try {\n      console.log(\"[handleSetupSoftWallet] Calling softWallet.setup()\");\n      const success = await softWallet.setup(words.join(\" \"), softWalletPin);\n      console.log(\"[handleSetupSoftWallet] softWallet.setup() result:\", success);\n      \n      if (success) {\n        console.log(\"[handleSetupSoftWallet] Creating wallets for selected chains:\", Array.from(softWalletSelectedChains));\n        // Create wallets only for selected chains\n        await deriveWallets(Array.from(softWalletSelectedChains));\n        console.log(\"[handleSetupSoftWallet] deriveWallets() completed\");\n        \n        setShowHeaderSetupDialog(false);\n        // Reset soft wallet wizard state\n        setSoftWalletStep(\"select-chains\");\n        setSoftWalletGeneratedSeed(\"\");\n        setSoftWalletImportSeed(\"\");\n        setSoftWalletPin(\"\");\n        setSoftWalletConfirmPin(\"\");\n        setSoftWalletSeedConfirmed(false);\n        setSoftWalletSelectedChains(new Set());\n        toast({ title: \"Wallet Created\", description: \"Your soft wallet is ready.\" });\n      } else {\n        const errorMsg = softWallet.getState().error;\n        console.log(\"[handleSetupSoftWallet] Setup failed:\", errorMsg);\n        setSoftWalletError(errorMsg || \"Failed to set up wallet.\");\n      }\n    } catch (error: any) {\n      console.error(\"[handleSetupSoftWallet] Exception:\", error);\n      setSoftWalletError(error.message || \"Failed to create wallet.\");\n    } finally {\n      setSoftWalletLoading(false);\n    }\n  };\n  \n  const handleHeaderGenerateSeed = () => {\n    try {\n      let phrase: string;\n      if (headerPicoWordCount === 12) {\n        const entropy = ethers.randomBytes(16);\n        phrase = ethers.Mnemonic.entropyToPhrase(entropy);\n      } else {\n        const entropy = ethers.randomBytes(32);\n        phrase = ethers.Mnemonic.entropyToPhrase(entropy);\n      }\n      setHeaderPicoGeneratedSeed(phrase);\n      setHeaderPicoStep(\"display\");\n    } catch (error: any) {\n      setHeaderPicoError(\"Failed to generate seed phrase\");\n    }\n  };\n\n  const handleHeaderCopySeed = async () => {\n    try {\n      await navigator.clipboard.writeText(headerPicoGeneratedSeed);\n      setHeaderPicoCopied(true);\n      setTimeout(() => setHeaderPicoCopied(false), 2000);\n    } catch {\n      toast({ title: \"Copy failed\", description: \"Please manually select and copy\", variant: \"destructive\" });\n    }\n  };\n\n  const handleHeaderSetupPico = async () => {\n    setHeaderPicoError(\"\");\n    \n    const seedToUse = headerPicoMode === \"create\" ? headerPicoGeneratedSeed : headerPicoImportSeed;\n    const words = seedToUse.trim().toLowerCase().split(/\\s+/);\n    if (words.length !== 12 && words.length !== 24) {\n      setHeaderPicoError(\"Recovery phrase must be 12 or 24 words.\");\n      return;\n    }\n    if (headerPicoPin.length < 4 || headerPicoPin.length > 6 || !/^\\d+$/.test(headerPicoPin)) {\n      setHeaderPicoError(\"PIN must be 4-6 digits.\");\n      return;\n    }\n    if (headerPicoPin !== headerPicoConfirmPin) {\n      setHeaderPicoError(\"PINs do not match.\");\n      return;\n    }\n    \n    setHeaderPicoLoading(true);\n    try {\n      // Use hardwareWallet.setupWallet which routes correctly for mobile vs desktop\n      const success = await hardwareWallet.setupWallet(headerPicoPin, words.join(\" \"));\n      if (success) {\n        hardwareWallet.setHasWalletOnDevice(true);\n        const unlocked = await unlockWallet(headerPicoPin);\n        if (unlocked) {\n          // Derive wallets for default chains (ETH, BTC, BNB, TRX)\n          const defaultChainIds: string[] = [];\n          DEFAULT_CHAINS.forEach((chain, index) => {\n            if (['ETH', 'BTC', 'BNB', 'TRX'].includes(chain.symbol)) {\n              defaultChainIds.push(`chain-${index}`);\n            }\n          });\n          await deriveWallets(defaultChainIds);\n          setShowHeaderPicoSetupDialog(false);\n          setHeaderPicoGeneratedSeed(\"\");\n          setHeaderPicoImportSeed(\"\");\n          setHeaderPicoPin(\"\");\n          setHeaderPicoConfirmPin(\"\");\n          toast({ title: \"Wallet Created\", description: \"Your hardware wallet is ready.\" });\n        }\n      } else {\n        setHeaderPicoError(\"Failed to set up wallet on device.\");\n      }\n    } catch (error: any) {\n      setHeaderPicoError(error.message || \"Failed to create wallet.\");\n    } finally {\n      setHeaderPicoLoading(false);\n    }\n  };\n\n  const isWebHIDSupported = hardwareWallet.isWebHIDSupported();\n\n  // For soft wallet mode, show different statuses\n  const statusBadge = walletMode === \"soft_wallet\" ? (\n    // Soft wallet mode - no device connection needed\n    !isConnected ? (\n      <div className=\"flex items-center gap-2\">\n        <Badge variant=\"outline\" className=\"gap-1.5 text-muted-foreground\">\n          <Laptop className=\"h-3 w-3\" />\n          <span className=\"hidden sm:inline\">Not Set Up</span>\n        </Badge>\n        <Button size=\"sm\" onClick={handleConnect} data-testid=\"button-setup-soft-wallet\">\n          <Shield className=\"mr-1.5 h-4 w-4\" />\n          Set Up\n        </Button>\n      </div>\n    ) : !isUnlocked ? (\n      <div className=\"flex items-center gap-2\">\n        <Badge variant=\"secondary\" className=\"gap-1.5\">\n          <Lock className=\"h-3 w-3\" />\n          <span className=\"hidden sm:inline\">Locked</span>\n        </Badge>\n        <Button size=\"sm\" onClick={handleConnect} data-testid=\"button-unlock-wallet\">\n          <Unlock className=\"mr-1.5 h-4 w-4\" />\n          Unlock\n        </Button>\n      </div>\n    ) : (\n      <div className=\"flex items-center gap-2\">\n        <Badge className=\"gap-1.5 bg-green-500/10 text-green-600 dark:text-green-400 border-green-500/20\">\n          <div className=\"h-2 w-2 rounded-full bg-green-500 animate-pulse\" />\n          <span className=\"hidden sm:inline\">Active</span>\n        </Badge>\n        <Button size=\"sm\" variant=\"ghost\" onClick={lockWallet} data-testid=\"button-lock-wallet\">\n          <Lock className=\"h-4 w-4\" />\n        </Button>\n      </div>\n    )\n  ) : (\n    // Hard wallet mode - device connection required\n    !isConnected ? (\n      <div className=\"flex items-center gap-2\">\n        <Badge variant=\"outline\" className=\"gap-1.5 text-muted-foreground\">\n          <Unplug className=\"h-3 w-3\" />\n          <span className=\"hidden sm:inline\">No Device</span>\n        </Badge>\n        <Button size=\"sm\" onClick={handleConnect} data-testid=\"button-connect-device\">\n          <Usb className=\"mr-1.5 h-4 w-4\" />\n          Connect\n        </Button>\n      </div>\n    ) : !isUnlocked ? (\n      <div className=\"flex items-center gap-2\">\n        <Badge variant=\"secondary\" className=\"gap-1.5\">\n          <Lock className=\"h-3 w-3\" />\n          <span className=\"hidden sm:inline\">Locked</span>\n        </Badge>\n        <Button size=\"sm\" onClick={handleConnect} data-testid=\"button-unlock-wallet\">\n          <Unlock className=\"mr-1.5 h-4 w-4\" />\n          Unlock\n        </Button>\n      </div>\n    ) : (\n      <div className=\"flex items-center gap-2\">\n        <Badge className=\"gap-1.5 bg-green-500/10 text-green-600 dark:text-green-400 border-green-500/20\">\n          <div className=\"h-2 w-2 rounded-full bg-green-500 animate-pulse\" />\n          <span className=\"hidden sm:inline\">{hardwareState.deviceName || \"Connected\"}</span>\n        </Badge>\n        <Button size=\"sm\" variant=\"ghost\" onClick={lockWallet} data-testid=\"button-lock-wallet\">\n          <Lock className=\"h-4 w-4\" />\n        </Button>\n      </div>\n    )\n  );\n\n  return (\n    <>\n      {statusBadge}\n      \n      {/* Device Selection Dialog */}\n      <Dialog open={showHeaderSetupDialog} onOpenChange={setShowHeaderSetupDialog}>\n        <DialogContent className=\"max-w-md\">\n          <DialogHeader>\n            <DialogTitle>\n              {walletMode === \"soft_wallet\" ? (\n                <>\n                  {softWalletStep === \"select-chains\" && \"Select Chains\"}\n                  {softWalletStep === \"choose\" && \"Set Up Recovery Phrase\"}\n                  {softWalletStep === \"display\" && \"Your Recovery Phrase\"}\n                  {softWalletStep === \"confirm\" && \"Confirm Backup\"}\n                  {softWalletStep === \"pin\" && \"Create Your PIN\"}\n                </>\n              ) : \"Connect Your Wallet\"}\n            </DialogTitle>\n            <DialogDescription>\n              {walletMode === \"soft_wallet\" ? (\n                <>\n                  {softWalletStep === \"select-chains\" && \"Choose the blockchain networks for your wallet.\"}\n                  {softWalletStep === \"choose\" && \"Generate a new recovery phrase or import an existing one.\"}\n                  {softWalletStep === \"display\" && \"Write down these words in order and store them safely.\"}\n                  {softWalletStep === \"confirm\" && \"Confirm that you have saved your recovery phrase.\"}\n                  {softWalletStep === \"pin\" && \"Set a PIN to protect your wallet.\"}\n                </>\n              ) : \"Choose how you want to set up your wallet.\"}\n            </DialogDescription>\n          </DialogHeader>\n          \n          {/* Hard Wallet Mode - Show tabs for device selection */}\n          {walletMode === \"hard_wallet\" && (\n            <div className=\"space-y-4 mt-4\">\n              {/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) ? (\n                <>\n                  <Alert>\n                    <Smartphone className=\"h-4 w-4\" />\n                    <AlertDescription>\n                      USB connection is not available on mobile devices. Use the Mobile Bridge to connect through a desktop computer.\n                    </AlertDescription>\n                  </Alert>\n                  <Button \n                    className=\"w-full\" \n                    onClick={() => {\n                      setShowHeaderSetupDialog(false);\n                      window.location.href = \"/bridge\";\n                    }}\n                    data-testid=\"button-mobile-bridge\"\n                  >\n                    <Smartphone className=\"h-4 w-4 mr-2\" />\n                    Open Mobile Bridge\n                  </Button>\n                  <p className=\"text-xs text-muted-foreground text-center\">\n                    Or use a desktop browser with USB support.\n                  </p>\n                </>\n              ) : (\n                <>\n                  <p className=\"text-sm text-muted-foreground\">Connect your hardware wallet device via USB.</p>\n                  <Button className=\"w-full\" onClick={handleHeaderConnectRaspberryPi} disabled={isLoading} data-testid=\"button-header-connect-hard-wallet\">\n                    {isLoading ? \"Connecting...\" : \"Connect Hard Wallet\"}\n                  </Button>\n                </>\n              )}\n            </div>\n          )}\n          \n          {/* Soft Wallet Mode - Direct wizard flow */}\n          {walletMode === \"soft_wallet\" && (\n            <>\n              {/* Soft Wallet Wizard - Step 1: Select Chains (FIRST) */}\n              {softWalletStep === \"select-chains\" && (\n                <div className=\"space-y-4 mt-4\">\n                  <p className=\"text-sm text-muted-foreground\">\n                    Select the blockchain networks you want to use. You can add more chains later.\n                  </p>\n                  <ScrollArea className=\"h-64\">\n                    <div className=\"space-y-2 pr-4\">\n                      {DEFAULT_CHAINS.map((chain, index) => {\n                        const chainId = `chain-${index}`;\n                        const isSelected = softWalletSelectedChains.has(chainId);\n                        return (\n                          <div\n                            key={chainId}\n                            className={`flex items-center gap-3 p-3 rounded-md border cursor-pointer transition-colors ${\n                              isSelected \n                                ? \"border-primary bg-primary/5\" \n                                : \"border-border hover:border-muted-foreground/50\"\n                            }`}\n                            onClick={() => {\n                              const newSet = new Set(softWalletSelectedChains);\n                              if (isSelected) {\n                                newSet.delete(chainId);\n                              } else {\n                                newSet.add(chainId);\n                              }\n                              setSoftWalletSelectedChains(newSet);\n                            }}\n                            data-testid={`chain-select-${chain.symbol}`}\n                          >\n                            <Checkbox \n                              checked={isSelected}\n                              onCheckedChange={(checked) => {\n                                const newSet = new Set(softWalletSelectedChains);\n                                if (checked) {\n                                  newSet.add(chainId);\n                                } else {\n                                  newSet.delete(chainId);\n                                }\n                                setSoftWalletSelectedChains(newSet);\n                              }}\n                            />\n                            <div className=\"flex items-center gap-2 flex-1\">\n                              {getChainIcon(chain.symbol)}\n                              <div>\n                                <p className=\"font-medium text-sm\">{chain.name}</p>\n                                <p className=\"text-xs text-muted-foreground\">{chain.symbol}</p>\n                              </div>\n                            </div>\n                          </div>\n                        );\n                      })}\n                    </div>\n                  </ScrollArea>\n                  <div className=\"flex items-center justify-between text-sm text-muted-foreground\">\n                    <span>{softWalletSelectedChains.size} chain{softWalletSelectedChains.size !== 1 ? 's' : ''} selected</span>\n                    <Button\n                      variant=\"ghost\"\n                      size=\"sm\"\n                      onClick={() => {\n                        if (softWalletSelectedChains.size === DEFAULT_CHAINS.length) {\n                          setSoftWalletSelectedChains(new Set());\n                        } else {\n                          setSoftWalletSelectedChains(new Set(DEFAULT_CHAINS.map((_, i) => `chain-${i}`)));\n                        }\n                      }}\n                    >\n                      {softWalletSelectedChains.size === DEFAULT_CHAINS.length ? \"Deselect All\" : \"Select All\"}\n                    </Button>\n                  </div>\n                  {softWalletError && <Alert variant=\"destructive\"><AlertTriangle className=\"h-4 w-4\" /><AlertDescription>{softWalletError}</AlertDescription></Alert>}\n                  <Button\n                    className=\"w-full\"\n                    onClick={handleConfirmChainSelection}\n                    disabled={softWalletSelectedChains.size === 0}\n                    data-testid=\"button-confirm-chains\"\n                  >\n                    Continue\n                  </Button>\n                </div>\n              )}\n\n              {/* Soft Wallet Wizard - Step 2: Choose word count */}\n              {softWalletStep === \"choose\" && (\n                <div className=\"space-y-4 mt-4\">\n                  <p className=\"text-sm text-muted-foreground\">Choose the number of words for your recovery phrase:</p>\n                  <div className=\"flex gap-2\">\n                    <Button\n                      variant={softWalletWordCount === 12 ? \"default\" : \"outline\"}\n                      onClick={() => setSoftWalletWordCount(12)}\n                      className=\"flex-1\"\n                      data-testid=\"button-soft-12-words\"\n                    >\n                      12 Words\n                    </Button>\n                    <Button\n                      variant={softWalletWordCount === 24 ? \"default\" : \"outline\"}\n                      onClick={() => setSoftWalletWordCount(24)}\n                      className=\"flex-1\"\n                      data-testid=\"button-soft-24-words\"\n                    >\n                      24 Words (Recommended)\n                    </Button>\n                  </div>\n                  <div className=\"flex gap-2\">\n                    <Button variant=\"outline\" onClick={() => setSoftWalletStep(\"select-chains\")} className=\"flex-1\" data-testid=\"button-back-to-chains\">\n                      Back\n                    </Button>\n                    <Button className=\"flex-1\" onClick={handleSoftWalletGenerateSeed} data-testid=\"button-soft-generate-seed\">\n                      <Shield className=\"mr-2 h-4 w-4\" />Generate\n                    </Button>\n                  </div>\n                </div>\n              )}\n\n              {/* Soft Wallet Wizard - Step 2: Display Seed */}\n              {softWalletStep === \"display\" && (\n                <div className=\"space-y-4\">\n                  <Alert><AlertTriangle className=\"h-4 w-4\" /><AlertDescription>Write these words down on paper. Never store them digitally or share with anyone.</AlertDescription></Alert>\n                  <div className=\"grid grid-cols-3 gap-2 p-4 bg-muted rounded-md\">\n                    {softWalletGeneratedSeed.split(\" \").map((word, idx) => (\n                      <div key={idx} className=\"flex items-center gap-2 text-sm\">\n                        <span className=\"text-muted-foreground w-5 text-right\">{idx + 1}.</span>\n                        <span className=\"font-mono\" data-testid={`soft-word-${idx + 1}`}>{word}</span>\n                      </div>\n                    ))}\n                  </div>\n                  <Button variant=\"outline\" className=\"w-full\" onClick={handleSoftWalletCopySeed} data-testid=\"button-soft-copy-seed\">\n                    {softWalletCopied ? <><Check className=\"mr-2 h-4 w-4\" />Copied!</> : <><Copy className=\"mr-2 h-4 w-4\" />Copy to Clipboard</>}\n                  </Button>\n                  <div className=\"flex items-center space-x-2\">\n                    <Checkbox\n                      id=\"soft-seed-confirmed\"\n                      checked={softWalletSeedConfirmed}\n                      onCheckedChange={(checked) => setSoftWalletSeedConfirmed(checked === true)}\n                      data-testid=\"checkbox-soft-seed-confirmed\"\n                    />\n                    <label htmlFor=\"soft-seed-confirmed\" className=\"text-sm cursor-pointer\">\n                      I have written down my recovery phrase and stored it safely\n                    </label>\n                  </div>\n                  <Button\n                    className=\"w-full\"\n                    onClick={() => setSoftWalletStep(\"confirm\")}\n                    disabled={!softWalletSeedConfirmed}\n                    data-testid=\"button-soft-continue-to-confirm\"\n                  >\n                    Continue\n                  </Button>\n                </div>\n              )}\n\n              {/* Soft Wallet Wizard - Step 3: Confirm */}\n              {softWalletStep === \"confirm\" && (\n                <div className=\"space-y-4\">\n                  <Alert variant=\"destructive\">\n                    <AlertTriangle className=\"h-4 w-4\" />\n                    <AlertDescription>\n                      <strong>Important:</strong> Your recovery phrase is the ONLY way to recover your wallet if you lose access. \n                      If you lose it, your funds will be lost forever. Make sure you have stored it safely before continuing.\n                    </AlertDescription>\n                  </Alert>\n                  <div className=\"flex gap-2\">\n                    <Button variant=\"outline\" onClick={() => setSoftWalletStep(\"display\")} className=\"flex-1\" data-testid=\"button-soft-go-back\">\n                      Go Back\n                    </Button>\n                    <Button onClick={() => setSoftWalletStep(\"pin\")} className=\"flex-1\" data-testid=\"button-soft-continue-to-pin\">\n                      I Understand, Continue\n                    </Button>\n                  </div>\n                </div>\n              )}\n\n              {/* Soft Wallet Wizard - Step 4: PIN */}\n              {softWalletStep === \"pin\" && (\n                <div className=\"space-y-4\">\n                  <p className=\"text-sm text-muted-foreground\">Create a PIN (5 digits) to protect your wallet. You will need this PIN every time you want to unlock your wallet.</p>\n                  <div className=\"space-y-2\">\n                    <Label>New PIN (5 digits)</Label>\n                    <Input\n                      type=\"password\"\n                      inputMode=\"numeric\"\n                      maxLength={5}\n                      placeholder=\"Enter PIN\"\n                      value={softWalletPin}\n                      onChange={(e) => { setSoftWalletPin(e.target.value.replace(/\\D/g, \"\")); setSoftWalletError(\"\"); }}\n                      data-testid=\"input-soft-wallet-pin\"\n                    />\n                  </div>\n                  <div className=\"space-y-2\">\n                    <Label>Confirm PIN</Label>\n                    <Input\n                      type=\"password\"\n                      inputMode=\"numeric\"\n                      maxLength={5}\n                      placeholder=\"Confirm PIN\"\n                      value={softWalletConfirmPin}\n                      onChange={(e) => { setSoftWalletConfirmPin(e.target.value.replace(/\\D/g, \"\")); setSoftWalletError(\"\"); }}\n                      data-testid=\"input-soft-wallet-confirm-pin\"\n                    />\n                  </div>\n                  {softWalletError && <Alert variant=\"destructive\"><AlertTriangle className=\"h-4 w-4\" /><AlertDescription>{softWalletError}</AlertDescription></Alert>}\n                  <div className=\"flex gap-2\">\n                    <Button\n                      variant=\"outline\"\n                      onClick={() => setSoftWalletStep(softWalletMode === \"create\" ? \"confirm\" : \"choose\")}\n                      className=\"flex-1\"\n                      data-testid=\"button-soft-back\"\n                    >\n                      Back\n                    </Button>\n                    <Button\n                      onClick={handleValidatePinAndCreateWallet}\n                      disabled={!softWalletPin || !softWalletConfirmPin || softWalletLoading}\n                      className=\"flex-1\"\n                      data-testid=\"button-soft-wallet-create\"\n                    >\n                      {softWalletLoading ? \"Creating...\" : \"Create Wallet\"}\n                    </Button>\n                  </div>\n                </div>\n              )}\n            </>\n          )}\n        </DialogContent>\n      </Dialog>\n      \n      {/* Pico Wallet Setup Dialog - Multi-step Wizard */}\n      <Dialog open={showHeaderPicoSetupDialog} onOpenChange={setShowHeaderPicoSetupDialog}>\n        <DialogContent className=\"max-w-lg\">\n          <DialogHeader>\n            <DialogTitle>\n              {headerPicoStep === \"choose\" && \"Set Up New Wallet\"}\n              {headerPicoStep === \"display\" && \"Your Recovery Phrase\"}\n              {headerPicoStep === \"confirm\" && \"Confirm Backup\"}\n              {headerPicoStep === \"pin\" && \"Create Your PIN\"}\n            </DialogTitle>\n            <DialogDescription>\n              {headerPicoStep === \"choose\" && \"Create a new wallet or import an existing one\"}\n              {headerPicoStep === \"display\" && \"Write down these words in order and store them safely\"}\n              {headerPicoStep === \"confirm\" && \"Confirm that you have saved your recovery phrase\"}\n              {headerPicoStep === \"pin\" && \"Set a PIN to protect your wallet\"}\n            </DialogDescription>\n          </DialogHeader>\n\n          {/* Step 1: Choose create or import */}\n          {headerPicoStep === \"choose\" && (\n            <div className=\"space-y-4\">\n              <Tabs value={headerPicoMode} onValueChange={(v) => setHeaderPicoMode(v as \"create\" | \"import\")}>\n                <TabsList className=\"grid w-full grid-cols-2\">\n                  <TabsTrigger value=\"create\" data-testid=\"tab-create-new\">\n                    <Plus className=\"mr-2 h-4 w-4\" />Create New\n                  </TabsTrigger>\n                  <TabsTrigger value=\"import\" data-testid=\"tab-import-existing\">\n                    <Download className=\"mr-2 h-4 w-4\" />Import Existing\n                  </TabsTrigger>\n                </TabsList>\n\n                <TabsContent value=\"create\" className=\"space-y-4 mt-4\">\n                  <p className=\"text-sm text-muted-foreground\">Generate a new recovery phrase for your wallet. Choose the number of words:</p>\n                  <div className=\"flex gap-2\">\n                    <Button\n                      variant={headerPicoWordCount === 12 ? \"default\" : \"outline\"}\n                      onClick={() => setHeaderPicoWordCount(12)}\n                      className=\"flex-1\"\n                      data-testid=\"button-12-words\"\n                    >\n                      12 Words\n                    </Button>\n                    <Button\n                      variant={headerPicoWordCount === 24 ? \"default\" : \"outline\"}\n                      onClick={() => setHeaderPicoWordCount(24)}\n                      className=\"flex-1\"\n                      data-testid=\"button-24-words\"\n                    >\n                      24 Words (Recommended)\n                    </Button>\n                  </div>\n                  <Button className=\"w-full\" onClick={handleHeaderGenerateSeed} data-testid=\"button-generate-seed\">\n                    <Shield className=\"mr-2 h-4 w-4\" />Generate Recovery Phrase\n                  </Button>\n                </TabsContent>\n\n                <TabsContent value=\"import\" className=\"space-y-4 mt-4\">\n                  <Alert><AlertTriangle className=\"h-4 w-4\" /><AlertDescription>Only import a phrase you trust. Never share it with anyone.</AlertDescription></Alert>\n                  <div className=\"space-y-2\">\n                    <Label>Recovery Phrase (12 or 24 words)</Label>\n                    <textarea\n                      className=\"flex min-h-[100px] w-full rounded-md border border-input bg-background px-3 py-2 text-sm\"\n                      placeholder=\"Enter your recovery phrase, separated by spaces\"\n                      value={headerPicoImportSeed}\n                      onChange={(e) => { setHeaderPicoImportSeed(e.target.value); setHeaderPicoError(\"\"); }}\n                      data-testid=\"input-import-seed\"\n                    />\n                  </div>\n                  {headerPicoError && <Alert variant=\"destructive\"><AlertTriangle className=\"h-4 w-4\" /><AlertDescription>{headerPicoError}</AlertDescription></Alert>}\n                  <Button\n                    className=\"w-full\"\n                    onClick={() => {\n                      const words = headerPicoImportSeed.trim().toLowerCase().split(/\\s+/);\n                      if (words.length !== 12 && words.length !== 24) {\n                        setHeaderPicoError(\"Recovery phrase must be 12 or 24 words.\");\n                        return;\n                      }\n                      setHeaderPicoStep(\"pin\");\n                    }}\n                    disabled={!headerPicoImportSeed.trim()}\n                    data-testid=\"button-continue-import\"\n                  >\n                    Continue to PIN Setup\n                  </Button>\n                </TabsContent>\n              </Tabs>\n            </div>\n          )}\n\n          {/* Step 2: Display generated seed */}\n          {headerPicoStep === \"display\" && (\n            <div className=\"space-y-4\">\n              <Alert><AlertTriangle className=\"h-4 w-4\" /><AlertDescription>Write these words down on paper. Never store them digitally or share with anyone.</AlertDescription></Alert>\n              <div className=\"grid grid-cols-3 gap-2 p-4 bg-muted rounded-md\">\n                {headerPicoGeneratedSeed.split(\" \").map((word, idx) => (\n                  <div key={idx} className=\"flex items-center gap-2 text-sm\">\n                    <span className=\"text-muted-foreground w-5 text-right\">{idx + 1}.</span>\n                    <span className=\"font-mono\" data-testid={`word-${idx + 1}`}>{word}</span>\n                  </div>\n                ))}\n              </div>\n              <Button variant=\"outline\" className=\"w-full\" onClick={handleHeaderCopySeed} data-testid=\"button-copy-seed\">\n                {headerPicoCopied ? <><Check className=\"mr-2 h-4 w-4\" />Copied!</> : <><Copy className=\"mr-2 h-4 w-4\" />Copy to Clipboard</>}\n              </Button>\n              <div className=\"flex items-center space-x-2\">\n                <Checkbox\n                  id=\"seed-confirmed\"\n                  checked={headerPicoSeedConfirmed}\n                  onCheckedChange={(checked) => setHeaderPicoSeedConfirmed(checked === true)}\n                  data-testid=\"checkbox-seed-confirmed\"\n                />\n                <label htmlFor=\"seed-confirmed\" className=\"text-sm cursor-pointer\">\n                  I have written down my recovery phrase and stored it safely\n                </label>\n              </div>\n              <Button\n                className=\"w-full\"\n                onClick={() => setHeaderPicoStep(\"confirm\")}\n                disabled={!headerPicoSeedConfirmed}\n                data-testid=\"button-continue-to-confirm\"\n              >\n                Continue\n              </Button>\n            </div>\n          )}\n\n          {/* Step 3: Confirm backup warning */}\n          {headerPicoStep === \"confirm\" && (\n            <div className=\"space-y-4\">\n              <Alert variant=\"destructive\">\n                <AlertTriangle className=\"h-4 w-4\" />\n                <AlertDescription>\n                  <strong>Important:</strong> Your recovery phrase is the ONLY way to recover your wallet if you lose access. \n                  If you lose it, your funds will be lost forever. Make sure you have stored it safely before continuing.\n                </AlertDescription>\n              </Alert>\n              <div className=\"flex gap-2\">\n                <Button variant=\"outline\" onClick={() => setHeaderPicoStep(\"display\")} className=\"flex-1\">\n                  Go Back\n                </Button>\n                <Button onClick={() => setHeaderPicoStep(\"pin\")} className=\"flex-1\" data-testid=\"button-continue-to-pin\">\n                  I Understand, Continue\n                </Button>\n              </div>\n            </div>\n          )}\n\n          {/* Step 4: PIN setup */}\n          {headerPicoStep === \"pin\" && (\n            <div className=\"space-y-4\">\n              <p className=\"text-sm text-muted-foreground\">Create a PIN (4-6 digits) to protect your wallet. You will need this PIN every time you want to unlock your wallet.</p>\n              <div className=\"space-y-2\">\n                <Label>New PIN (4-6 digits)</Label>\n                <Input\n                  type=\"password\"\n                  inputMode=\"numeric\"\n                  maxLength={6}\n                  placeholder=\"Enter PIN\"\n                  value={headerPicoPin}\n                  onChange={(e) => { setHeaderPicoPin(e.target.value.replace(/\\D/g, \"\")); setHeaderPicoError(\"\"); }}\n                  data-testid=\"input-header-pico-pin\"\n                />\n              </div>\n              <div className=\"space-y-2\">\n                <Label>Confirm PIN</Label>\n                <Input\n                  type=\"password\"\n                  inputMode=\"numeric\"\n                  maxLength={6}\n                  placeholder=\"Confirm PIN\"\n                  value={headerPicoConfirmPin}\n                  onChange={(e) => { setHeaderPicoConfirmPin(e.target.value.replace(/\\D/g, \"\")); setHeaderPicoError(\"\"); }}\n                  data-testid=\"input-header-pico-confirm-pin\"\n                />\n              </div>\n              {headerPicoError && <Alert variant=\"destructive\"><AlertTriangle className=\"h-4 w-4\" /><AlertDescription>{headerPicoError}</AlertDescription></Alert>}\n              <div className=\"flex gap-2\">\n                <Button\n                  variant=\"outline\"\n                  onClick={() => setHeaderPicoStep(headerPicoMode === \"create\" ? \"confirm\" : \"choose\")}\n                  className=\"flex-1\"\n                >\n                  Back\n                </Button>\n                <Button\n                  onClick={handleHeaderSetupPico}\n                  disabled={!headerPicoPin || !headerPicoConfirmPin || headerPicoLoading}\n                  className=\"flex-1\"\n                  data-testid=\"button-header-setup-pico\"\n                >\n                  {headerPicoLoading ? \"Setting up...\" : \"Create Wallet\"}\n                </Button>\n              </div>\n            </div>\n          )}\n\n          <DialogFooter className=\"flex-col sm:flex-row gap-2\">\n            <Button variant=\"ghost\" onClick={() => setShowHeaderPicoSetupDialog(false)} className=\"w-full sm:w-auto\">\n              Cancel\n            </Button>\n          </DialogFooter>\n        </DialogContent>\n      </Dialog>\n    </>\n  );\n}\n\nexport function HardwareStatusCard() {\n  const { \n    isConnected, \n    isUnlocked, \n    hardwareState,\n    hasWalletOnDevice,\n    setShowPinModal, \n    setPinAction, \n    connectLedger,\n    connectRaspberryPi,\n    connectSimulated,\n    unlockWallet,\n    deriveWallets,\n    isLoading,\n    walletMode,\n  } = useWallet();\n  const { toast } = useToast();\n  \n  const [showSetupDialog, setShowSetupDialog] = useState(false);\n  const [showRecoverDialog, setShowRecoverDialog] = useState(false);\n  const [showPicoSetupDialog, setShowPicoSetupDialog] = useState(false);\n  const [seedPhraseInput, setSeedPhraseInput] = useState(\"\");\n  const [newPin, setNewPin] = useState(\"\");\n  const [confirmPin, setConfirmPin] = useState(\"\");\n  const [recoverError, setRecoverError] = useState(\"\");\n  const [isRecovering, setIsRecovering] = useState(false);\n  const [setupTab, setSetupTab] = useState<\"hard_wallet\" | \"soft_wallet\">(\"soft_wallet\");\n  \n  // Soft wallet setup - multi-step wizard state (chain selection is first step)\n  const [softWalletStep, setSoftWalletStep] = useState<\"select-chains\" | \"choose\" | \"display\" | \"confirm\" | \"pin\">(\"select-chains\");\n  const [softWalletSelectedChains, setSoftWalletSelectedChains] = useState<Set<string>>(() => {\n    // Pre-select ETH, BTC, BNB, TRX by default\n    const defaultSelected = new Set<string>();\n    DEFAULT_CHAINS.forEach((chain, index) => {\n      if (['ETH', 'BTC', 'BNB', 'TRX'].includes(chain.symbol)) {\n        defaultSelected.add(`chain-${index}`);\n      }\n    });\n    return defaultSelected;\n  });\n  const [softWalletWordCount, setSoftWalletWordCount] = useState<12 | 24>(24);\n  const [softWalletGeneratedSeed, setSoftWalletGeneratedSeed] = useState(\"\");\n  const [softWalletSeedConfirmed, setSoftWalletSeedConfirmed] = useState(false);\n  const [softWalletCopied, setSoftWalletCopied] = useState(false);\n  const [softWalletMode, setSoftWalletMode] = useState<\"create\" | \"import\">(\"create\");\n  const [softWalletImportSeed, setSoftWalletImportSeed] = useState(\"\");\n  const [softWalletNewPin, setSoftWalletNewPin] = useState(\"\");\n  const [softWalletConfirmPin, setSoftWalletConfirmPin] = useState(\"\");\n  const [softWalletError, setSoftWalletError] = useState(\"\");\n  const [isSoftWalletLoading, setIsSoftWalletLoading] = useState(false);\n  \n  // Pico setup dialog - multi-step wizard state\n  const [picoStep, setPicoStep] = useState<\"choose\" | \"display\" | \"confirm\" | \"pin\">(\"choose\");\n  const [picoWordCount, setPicoWordCount] = useState<12 | 24>(24);\n  const [picoGeneratedSeed, setPicoGeneratedSeed] = useState(\"\");\n  const [picoSeedConfirmed, setPicoSeedConfirmed] = useState(false);\n  const [picoCopied, setPicoCopied] = useState(false);\n  const [picoMode, setPicoMode] = useState<\"create\" | \"import\">(\"create\");\n  const [picoImportSeed, setPicoImportSeed] = useState(\"\");\n  const [picoNewPin, setPicoNewPin] = useState(\"\");\n  const [picoConfirmPin, setPicoConfirmPin] = useState(\"\");\n  const [picoSetupError, setPicoSetupError] = useState(\"\");\n  const [isPicoSetupLoading, setIsPicoSetupLoading] = useState(false);\n\n  const handleAction = () => {\n    if (!isConnected) {\n      setShowSetupDialog(true);\n    } else if (!isUnlocked) {\n      setPinAction(\"unlock\");\n      setShowPinModal(true);\n    }\n  };\n\n  const handleConnectLedger = async () => {\n    const success = await connectLedger();\n    if (success) {\n      setShowSetupDialog(false);\n      toast({\n        title: \"Ledger Connected\",\n        description: \"Your Ledger device is now connected. Please enter your PIN to unlock.\",\n      });\n      setPinAction(\"unlock\");\n      setShowPinModal(true);\n    } else if (hardwareState.error) {\n      toast({\n        title: \"Connection Failed\",\n        description: hardwareState.error,\n        variant: \"destructive\",\n      });\n    }\n  };\n\n  const handleConnectRaspberryPi = async () => {\n    console.log(\"[HardwareStatusCard] handleConnectRaspberryPi() called\");\n    const result = await connectRaspberryPi();\n    console.log(\"[HardwareStatusCard] connectRaspberryPi result:\", result);\n    \n    if (result.success) {\n      setShowSetupDialog(false);\n      \n      if (!result.hasWallet) {\n        console.log(\"[HardwareStatusCard] NEW DEVICE DETECTED - showing wallet setup dialog\");\n        toast({\n          title: \"Hard Wallet Connected\",\n          description: \"This is a new device. Please set up your wallet.\",\n        });\n        // Reset all Pico wizard state\n        setPicoStep(\"choose\");\n        setPicoMode(\"create\");\n        setPicoWordCount(24);\n        setPicoGeneratedSeed(\"\");\n        setPicoSeedConfirmed(false);\n        setPicoCopied(false);\n        setPicoImportSeed(\"\");\n        setPicoNewPin(\"\");\n        setPicoConfirmPin(\"\");\n        setPicoSetupError(\"\");\n        setShowPicoSetupDialog(true);\n      } else {\n        console.log(\"[HardwareStatusCard] EXISTING WALLET DETECTED - showing PIN unlock\");\n        toast({\n          title: \"Hard Wallet Connected\",\n          description: \"Your hardware wallet is now connected. Please enter your PIN to unlock.\",\n        });\n        setPinAction(\"unlock\");\n        setShowPinModal(true);\n      }\n    } else {\n      console.log(\"[HardwareStatusCard] Connection failed:\", result.error);\n      toast({\n        title: \"Connection Failed\",\n        description: result.error || \"Failed to connect to hardware wallet\",\n        variant: \"destructive\",\n      });\n    }\n  };\n\n  const handleGenerateSeed = () => {\n    try {\n      let phrase: string;\n      if (picoWordCount === 12) {\n        const entropy = ethers.randomBytes(16);\n        phrase = ethers.Mnemonic.entropyToPhrase(entropy);\n      } else {\n        const entropy = ethers.randomBytes(32);\n        phrase = ethers.Mnemonic.entropyToPhrase(entropy);\n      }\n      setPicoGeneratedSeed(phrase);\n      setPicoStep(\"display\");\n    } catch (error: any) {\n      setPicoSetupError(\"Failed to generate seed phrase\");\n    }\n  };\n\n  const handleSoftWalletGenerateSeed = () => {\n    try {\n      let phrase: string;\n      if (softWalletWordCount === 12) {\n        const entropy = ethers.randomBytes(16);\n        phrase = ethers.Mnemonic.entropyToPhrase(entropy);\n      } else {\n        const entropy = ethers.randomBytes(32);\n        phrase = ethers.Mnemonic.entropyToPhrase(entropy);\n      }\n      setSoftWalletGeneratedSeed(phrase);\n      setSoftWalletStep(\"display\");\n    } catch (error: any) {\n      setSoftWalletError(\"Failed to generate seed phrase\");\n    }\n  };\n\n  const handleSoftWalletCopySeed = async () => {\n    try {\n      await navigator.clipboard.writeText(softWalletGeneratedSeed);\n      setSoftWalletCopied(true);\n      setTimeout(() => setSoftWalletCopied(false), 2000);\n    } catch {\n      toast({ title: \"Copy failed\", description: \"Please manually select and copy\", variant: \"destructive\" });\n    }\n  };\n\n  const handleSetupSoftWallet = async () => {\n    console.log(\"[HardwareStatusCard] handleSetupSoftWallet() called\");\n    setSoftWalletError(\"\");\n    \n    const seedToUse = softWalletMode === \"create\" ? softWalletGeneratedSeed : softWalletImportSeed;\n    console.log(\"[HardwareStatusCard] Mode:\", softWalletMode, \"Seed length:\", seedToUse?.length || 0);\n    \n    if (!seedToUse || seedToUse.trim().length === 0) {\n      setSoftWalletError(\"No recovery phrase found. Please go back and generate one.\");\n      return;\n    }\n    \n    const words = seedToUse.trim().toLowerCase().split(/\\s+/);\n    console.log(\"[HardwareStatusCard] Word count:\", words.length);\n    \n    if (words.length !== 12 && words.length !== 24) {\n      setSoftWalletError(\"Recovery phrase must be 12 or 24 words.\");\n      return;\n    }\n    \n    if (softWalletNewPin.length !== 5) {\n      setSoftWalletError(\"PIN must be 5 digits.\");\n      return;\n    }\n    \n    if (!/^\\d+$/.test(softWalletNewPin)) {\n      setSoftWalletError(\"PIN must contain only numbers.\");\n      return;\n    }\n    \n    if (softWalletNewPin !== softWalletConfirmPin) {\n      setSoftWalletError(\"PINs do not match.\");\n      return;\n    }\n    \n    setIsSoftWalletLoading(true);\n    try {\n      console.log(\"[HardwareStatusCard] Calling softWallet.setup()\");\n      // Use softWallet.setup() to encrypt and store seed with PIN\n      const success = await softWallet.setup(words.join(\" \"), softWalletNewPin);\n      console.log(\"[HardwareStatusCard] softWallet.setup() result:\", success);\n      \n      if (success) {\n        console.log(\"[HardwareStatusCard] Creating wallets for selected chains:\", Array.from(softWalletSelectedChains));\n        // softWallet.setup() already unlocks the wallet\n        // Only create wallets for the selected chains\n        await deriveWallets(Array.from(softWalletSelectedChains));\n        console.log(\"[HardwareStatusCard] deriveWallets() completed\");\n        \n        setShowSetupDialog(false);\n        // Reset soft wallet wizard state\n        setSoftWalletStep(\"select-chains\");\n        setSoftWalletGeneratedSeed(\"\");\n        setSoftWalletImportSeed(\"\");\n        setSoftWalletNewPin(\"\");\n        setSoftWalletConfirmPin(\"\");\n        setSoftWalletSeedConfirmed(false);\n        \n        toast({\n          title: \"Wallet Created\",\n          description: \"Your soft wallet has been set up successfully.\",\n        });\n      } else {\n        const errorMsg = softWallet.getState().error;\n        console.log(\"[HardwareStatusCard] Setup failed:\", errorMsg);\n        setSoftWalletError(errorMsg || \"Failed to set up wallet.\");\n      }\n    } catch (error: any) {\n      console.error(\"[HardwareStatusCard] Exception:\", error);\n      setSoftWalletError(error.message || \"Failed to create wallet.\");\n    } finally {\n      setIsSoftWalletLoading(false);\n    }\n  };\n\n  const handleCopySeed = async () => {\n    try {\n      await navigator.clipboard.writeText(picoGeneratedSeed);\n      setPicoCopied(true);\n      setTimeout(() => setPicoCopied(false), 2000);\n    } catch {\n      toast({ title: \"Copy failed\", description: \"Please manually select and copy\", variant: \"destructive\" });\n    }\n  };\n\n  const handleCreateSimulated = async () => {\n    setRecoverError(\"\");\n    \n    const words = seedPhraseInput.trim().toLowerCase().split(/\\s+/);\n    if (words.length !== 12 && words.length !== 24) {\n      setRecoverError(\"Recovery phrase must be 12 or 24 words.\");\n      return;\n    }\n    \n    if (newPin.length < 4 || newPin.length > 6) {\n      setRecoverError(\"PIN must be 4-6 digits.\");\n      return;\n    }\n    \n    if (!/^\\d+$/.test(newPin)) {\n      setRecoverError(\"PIN must contain only numbers.\");\n      return;\n    }\n    \n    if (newPin !== confirmPin) {\n      setRecoverError(\"PINs do not match.\");\n      return;\n    }\n    \n    setIsRecovering(true);\n    try {\n      await hardwareWallet.setPin(newPin);\n      const success = await connectSimulated(words.join(\" \"));\n      \n      if (success) {\n        const unlocked = await unlockWallet(newPin);\n        \n        if (unlocked) {\n          await deriveWallets();\n          \n          setShowSetupDialog(false);\n          setSeedPhraseInput(\"\");\n          setNewPin(\"\");\n          setConfirmPin(\"\");\n          \n          toast({\n            title: \"Wallet Created\",\n            description: \"Your simulated wallet has been set up successfully.\",\n          });\n        }\n      } else if (hardwareState.error) {\n        setRecoverError(hardwareState.error);\n      }\n    } catch (error: any) {\n      setRecoverError(error.message || \"Failed to create wallet.\");\n    } finally {\n      setIsRecovering(false);\n    }\n  };\n\n  const handleRecover = async () => {\n    setRecoverError(\"\");\n    console.log(\"[handleRecover] Starting recovery, walletMode:\", walletMode);\n    \n    const words = seedPhraseInput.trim().toLowerCase().split(/\\s+/);\n    if (words.length !== 12 && words.length !== 24) {\n      setRecoverError(\"Recovery phrase must be 12 or 24 words.\");\n      return;\n    }\n    \n    // Soft wallet requires exactly 5-digit PIN\n    if (walletMode === \"soft_wallet\") {\n      if (newPin.length !== 5) {\n        setRecoverError(\"PIN must be exactly 5 digits for soft wallet.\");\n        return;\n      }\n    } else {\n      if (newPin.length < 4 || newPin.length > 6) {\n        setRecoverError(\"PIN must be 4-6 digits.\");\n        return;\n      }\n    }\n    \n    if (!/^\\d+$/.test(newPin)) {\n      setRecoverError(\"PIN must contain only numbers.\");\n      return;\n    }\n    \n    if (newPin !== confirmPin) {\n      setRecoverError(\"PINs do not match.\");\n      return;\n    }\n    \n    setIsRecovering(true);\n    try {\n      if (walletMode === \"soft_wallet\") {\n        console.log(\"[handleRecover] Using soft wallet import\");\n        // For soft wallet, use softWallet.setup which handles both seed and PIN\n        const success = await softWallet.setup(words.join(\" \"), newPin);\n        console.log(\"[handleRecover] Soft wallet setup result:\", success);\n        \n        if (success) {\n          const unlocked = await unlockWallet(newPin);\n          console.log(\"[handleRecover] Soft wallet unlock result:\", unlocked);\n          \n          if (unlocked) {\n            await deriveWallets();\n            \n            setShowRecoverDialog(false);\n            setSeedPhraseInput(\"\");\n            setNewPin(\"\");\n            setConfirmPin(\"\");\n            \n            toast({\n              title: \"Wallet Recovered\",\n              description: \"Your wallet has been successfully restored from the recovery phrase.\",\n            });\n          }\n        } else {\n          const state = softWallet.getState();\n          setRecoverError(state.error || \"Failed to import wallet.\");\n        }\n      } else {\n        console.log(\"[handleRecover] Using hardware wallet import\");\n        await hardwareWallet.setPin(newPin);\n        const success = await connectSimulated(words.join(\" \"));\n        console.log(\"[handleRecover] Hardware wallet connect result:\", success);\n        \n        if (success) {\n          const unlocked = await unlockWallet(newPin);\n          console.log(\"[handleRecover] Hardware wallet unlock result:\", unlocked);\n          \n          if (unlocked) {\n            await deriveWallets();\n            \n            setShowRecoverDialog(false);\n            setSeedPhraseInput(\"\");\n            setNewPin(\"\");\n            setConfirmPin(\"\");\n            \n            toast({\n              title: \"Wallet Recovered\",\n              description: \"Your wallet has been successfully restored from the recovery phrase.\",\n            });\n          }\n        } else if (hardwareState.error) {\n          setRecoverError(hardwareState.error);\n        }\n      }\n    } catch (error: any) {\n      console.error(\"[handleRecover] Error:\", error);\n      setRecoverError(error.message || \"Failed to recover wallet.\");\n    } finally {\n      setIsRecovering(false);\n    }\n  };\n\n  const handleSetupPicoWallet = async () => {\n    setPicoSetupError(\"\");\n    \n    const seedToUse = picoMode === \"create\" ? picoGeneratedSeed : picoImportSeed;\n    const words = seedToUse.trim().toLowerCase().split(/\\s+/);\n    if (words.length !== 12 && words.length !== 24) {\n      setPicoSetupError(\"Recovery phrase must be 12 or 24 words.\");\n      return;\n    }\n    \n    if (picoNewPin.length < 4 || picoNewPin.length > 6) {\n      setPicoSetupError(\"PIN must be 4-6 digits.\");\n      return;\n    }\n    \n    if (!/^\\d+$/.test(picoNewPin)) {\n      setPicoSetupError(\"PIN must contain only numbers.\");\n      return;\n    }\n    \n    if (picoNewPin !== picoConfirmPin) {\n      setPicoSetupError(\"PINs do not match.\");\n      return;\n    }\n    \n    setIsPicoSetupLoading(true);\n    try {\n      // Use hardwareWallet.setupWallet which routes correctly for mobile vs desktop\n      const success = await hardwareWallet.setupWallet(picoNewPin, words.join(\" \"));\n      \n      if (success) {\n        hardwareWallet.setHasWalletOnDevice(true);\n        const unlocked = await unlockWallet(picoNewPin);\n        \n        if (unlocked) {\n          // Derive wallets for default chains (ETH, BTC, BNB, TRX)\n          const defaultChainIds: string[] = [];\n          DEFAULT_CHAINS.forEach((chain, index) => {\n            if (['ETH', 'BTC', 'BNB', 'TRX'].includes(chain.symbol)) {\n              defaultChainIds.push(`chain-${index}`);\n            }\n          });\n          await deriveWallets(defaultChainIds);\n          \n          setShowPicoSetupDialog(false);\n          setPicoGeneratedSeed(\"\");\n          setPicoImportSeed(\"\");\n          setPicoNewPin(\"\");\n          setPicoConfirmPin(\"\");\n          \n          toast({\n            title: \"Wallet Created\",\n            description: \"Your Raspberry Pi wallet has been set up successfully.\",\n          });\n        }\n      } else {\n        setPicoSetupError(\"Failed to set up wallet on device.\");\n      }\n    } catch (error: any) {\n      setPicoSetupError(error.message || \"Failed to create wallet.\");\n    } finally {\n      setIsPicoSetupLoading(false);\n    }\n  };\n\n  const isWebHIDSupported = hardwareWallet.isWebHIDSupported();\n\n  return (\n    <>\n      <div className=\"flex flex-col items-center justify-center rounded-xl border border-dashed border-muted-foreground/30 bg-muted/20 p-8 text-center\">\n        {walletMode === \"hard_wallet\" ? (\n          <div className=\"mb-4 relative h-52 w-40 flex flex-col items-center\">\n            <div className=\"relative w-24 h-40 rounded-3xl border-2 border-muted-foreground/30 bg-muted/20\">\n              <div className=\"absolute top-2 left-1/2 -translate-x-1/2 w-8 h-1.5 rounded-full bg-muted-foreground/20\" />\n              <div className=\"absolute inset-2 top-5 bottom-6 rounded-2xl bg-background flex flex-col items-center justify-center p-3 border border-border/50\">\n                <motion.div\n                  className=\"text-center flex flex-col items-center\"\n                  animate={{ opacity: [0, 1, 1, 0] }}\n                  transition={{\n                    duration: 7,\n                    repeat: Infinity,\n                    ease: \"easeInOut\",\n                    times: [0.10, 0.14, 0.86, 0.90],\n                  }}\n                >\n                  <div className=\"w-6 h-6 rounded-full bg-primary/10 flex items-center justify-center mb-1.5\">\n                    <Shield className=\"w-3.5 h-3.5 text-primary\" />\n                  </div>\n                  <p className=\"text-[10px] font-bold text-foreground leading-none tracking-tight\">VaultKey</p>\n                  <div className=\"flex items-center gap-1 mt-1.5 px-2 py-0.5 rounded-full bg-green-500/10 border border-green-500/20\">\n                    <div className=\"w-1.5 h-1.5 rounded-full bg-green-500 animate-pulse\" />\n                    <p className=\"text-[7px] font-semibold text-green-600 dark:text-green-400 leading-none\">Connected</p>\n                  </div>\n                </motion.div>\n              </div>\n              <div className=\"absolute bottom-1.5 left-1/2 -translate-x-1/2 w-6 h-1.5 rounded-full bg-muted-foreground/15\" />\n            </div>\n            <motion.div\n              className=\"-mt-1\"\n              animate={{ y: [10, -2, -2, 10] }}\n              transition={{\n                duration: 7,\n                repeat: Infinity,\n                ease: \"easeInOut\",\n                times: [0, 0.10, 0.90, 1],\n              }}\n            >\n              <div className=\"flex flex-col items-center\">\n                <div className=\"w-3 h-1.5 bg-muted-foreground/40 rounded-t-sm\" />\n                <div className=\"w-8 h-12 bg-primary rounded-lg border-2 border-primary flex flex-col items-center justify-center gap-0.5 shadow-md\">\n                  <div className=\"w-4 h-0.5 bg-background/50 rounded-full\" />\n                  <div className=\"w-4 h-0.5 bg-background/50 rounded-full\" />\n                  <Usb className=\"h-4 w-4 text-background/80 mt-0.5\" />\n                </div>\n              </div>\n            </motion.div>\n          </div>\n        ) : (\n          <div className=\"mb-4 flex h-20 w-20 items-center justify-center rounded-full bg-primary/10\">\n            <Shield className=\"h-10 w-10 text-primary\" />\n          </div>\n        )}\n        \n        {!isConnected ? (\n          <>\n            {walletMode === \"soft_wallet\" && (\n              <>\n                <h3 className=\"mb-2 text-lg font-semibold\">Set Up Your Soft Wallet</h3>\n                <p className=\"mb-6 max-w-sm text-sm text-muted-foreground\">\n                  Generate a new recovery phrase to secure your wallet.\n                </p>\n              </>\n            )}\n            <div className=\"flex flex-wrap gap-2 justify-center\">\n              <Button onClick={handleAction} data-testid=\"button-setup-wallet\">\n                {walletMode === \"soft_wallet\" \n                  ? <Laptop className=\"mr-2 h-4 w-4\" />\n                  : <Usb className=\"mr-2 h-4 w-4\" />}\n                {walletMode === \"soft_wallet\" ? \"Create Wallet\" : \"Connect Wallet\"}\n              </Button>\n              {walletMode === \"soft_wallet\" && (\n                <Button variant=\"outline\" onClick={() => setShowRecoverDialog(true)} data-testid=\"button-recover-wallet\">\n                  <RotateCcw className=\"mr-2 h-4 w-4\" />\n                  Recover Wallet\n                </Button>\n              )}\n            </div>\n          </>\n        ) : !isUnlocked ? (\n          <>\n            <h3 className=\"mb-2 text-lg font-semibold\">Wallet Locked</h3>\n            <p className=\"mb-6 max-w-sm text-sm text-muted-foreground\">\n              Enter your PIN to unlock and access your wallet.\n            </p>\n            <Button onClick={handleAction} data-testid=\"button-unlock-wallet-card\">\n              <Unlock className=\"mr-2 h-4 w-4\" />\n              Unlock Wallet\n            </Button>\n          </>\n        ) : null}\n      </div>\n\n      <Dialog open={showSetupDialog} onOpenChange={setShowSetupDialog}>\n        <DialogContent className=\"max-w-md\">\n          <DialogHeader>\n            <DialogTitle>{walletMode === \"soft_wallet\" ? \"Set Up Soft Wallet\" : \"Connect Your Wallet\"}</DialogTitle>\n            <DialogDescription>\n              {walletMode === \"soft_wallet\" \n                ? \"Generate a new recovery phrase to secure your wallet.\"\n                : \"Connect your hardware wallet device via USB.\"}\n            </DialogDescription>\n          </DialogHeader>\n          \n          {/* Hard Wallet Mode - Show connection flow */}\n          {walletMode === \"hard_wallet\" && (\n            <div className=\"space-y-4 mt-4\">\n              <p className=\"text-sm text-muted-foreground\">\n                Connect your hardware wallet device via USB.\n              </p>\n              <ol className=\"text-sm text-muted-foreground list-decimal list-inside space-y-1\">\n                <li>Connect your hardware wallet via USB</li>\n                <li>Ensure the wallet software is running</li>\n                <li>Click \"Connect Hard Wallet\" below</li>\n              </ol>\n              <Button \n                className=\"w-full\" \n                onClick={handleConnectRaspberryPi}\n                disabled={isLoading}\n                data-testid=\"button-connect-hard-wallet\"\n              >\n                {isLoading ? \"Connecting...\" : \"Connect Hard Wallet\"}\n              </Button>\n            </div>\n          )}\n          \n          {/* Soft Wallet Mode - Direct wizard flow */}\n          {walletMode === \"soft_wallet\" && (\n            <>\n              {/* Step 0: Select Chains */}\n              {softWalletStep === \"select-chains\" && (\n                <div className=\"space-y-4 mt-4\">\n                  <p className=\"text-sm text-muted-foreground\">Select which blockchain networks you want to use:</p>\n                  <ScrollArea className=\"h-[300px] pr-4\">\n                    <div className=\"space-y-2\">\n                      {DEFAULT_CHAINS.map((chain, index) => {\n                        const chainId = `chain-${index}`;\n                        const isSelected = softWalletSelectedChains.has(chainId);\n                        return (\n                          <div\n                            key={chainId}\n                            className={`flex items-center gap-3 p-3 rounded-lg border cursor-pointer transition-colors ${\n                              isSelected ? \"border-primary bg-primary/5\" : \"border-border hover-elevate\"\n                            }`}\n                            onClick={() => {\n                              const newSelected = new Set(softWalletSelectedChains);\n                              if (isSelected) {\n                                newSelected.delete(chainId);\n                              } else {\n                                newSelected.add(chainId);\n                              }\n                              setSoftWalletSelectedChains(newSelected);\n                            }}\n                            data-testid={`chain-select-${chain.symbol}`}\n                          >\n                            <Checkbox\n                              checked={isSelected}\n                              onCheckedChange={(checked) => {\n                                const newSelected = new Set(softWalletSelectedChains);\n                                if (checked) {\n                                  newSelected.add(chainId);\n                                } else {\n                                  newSelected.delete(chainId);\n                                }\n                                setSoftWalletSelectedChains(newSelected);\n                              }}\n                            />\n                            <div className=\"flex items-center gap-2 flex-1\">\n                              {getChainIcon(chain.symbol)}\n                              <div>\n                                <div className=\"font-medium\">{chain.name}</div>\n                                <div className=\"text-xs text-muted-foreground\">{chain.symbol}</div>\n                              </div>\n                            </div>\n                          </div>\n                        );\n                      })}\n                    </div>\n                  </ScrollArea>\n                  <div className=\"flex justify-between items-center pt-2 border-t\">\n                    <span className=\"text-sm text-muted-foreground\">\n                      {softWalletSelectedChains.size} chain{softWalletSelectedChains.size !== 1 ? \"s\" : \"\"} selected\n                    </span>\n                    <Button\n                      onClick={() => setSoftWalletStep(\"choose\")}\n                      disabled={softWalletSelectedChains.size === 0}\n                      data-testid=\"button-continue-to-phrase\"\n                    >\n                      Continue\n                    </Button>\n                  </div>\n                </div>\n              )}\n\n              {/* Step 1: Choose word count */}\n              {softWalletStep === \"choose\" && (\n                <div className=\"space-y-4 mt-4\">\n                  <p className=\"text-sm text-muted-foreground\">Choose the number of words for your recovery phrase:</p>\n                  <div className=\"flex gap-2\">\n                    <Button\n                      variant={softWalletWordCount === 12 ? \"default\" : \"outline\"}\n                      onClick={() => setSoftWalletWordCount(12)}\n                      className=\"flex-1\"\n                      data-testid=\"button-card-12-words\"\n                    >\n                      12 Words\n                    </Button>\n                    <Button\n                      variant={softWalletWordCount === 24 ? \"default\" : \"outline\"}\n                      onClick={() => setSoftWalletWordCount(24)}\n                      className=\"flex-1\"\n                      data-testid=\"button-card-24-words\"\n                    >\n                      24 Words (Recommended)\n                    </Button>\n                  </div>\n                  <Button className=\"w-full\" onClick={handleSoftWalletGenerateSeed} data-testid=\"button-card-generate-seed\">\n                    <Shield className=\"mr-2 h-4 w-4\" />Generate Recovery Phrase\n                  </Button>\n                </div>\n              )}\n\n              {/* Step 2: Display Seed */}\n              {softWalletStep === \"display\" && (\n                <div className=\"space-y-4\">\n                  <Alert><AlertTriangle className=\"h-4 w-4\" /><AlertDescription>Write these words down on paper. Never store them digitally or share with anyone.</AlertDescription></Alert>\n                  <div className=\"grid grid-cols-3 gap-2 p-4 bg-muted rounded-md\">\n                    {softWalletGeneratedSeed.split(\" \").map((word, idx) => (\n                      <div key={idx} className=\"flex items-center gap-2 text-sm\">\n                        <span className=\"text-muted-foreground w-5 text-right\">{idx + 1}.</span>\n                        <span className=\"font-mono\" data-testid={`card-word-${idx + 1}`}>{word}</span>\n                      </div>\n                    ))}\n                  </div>\n                  <Button variant=\"outline\" className=\"w-full\" onClick={handleSoftWalletCopySeed} data-testid=\"button-card-copy-seed\">\n                    {softWalletCopied ? <><Check className=\"mr-2 h-4 w-4\" />Copied!</> : <><Copy className=\"mr-2 h-4 w-4\" />Copy to Clipboard</>}\n                  </Button>\n                  <div className=\"flex items-center space-x-2\">\n                    <Checkbox\n                      id=\"card-seed-confirmed\"\n                      checked={softWalletSeedConfirmed}\n                      onCheckedChange={(checked) => setSoftWalletSeedConfirmed(checked === true)}\n                      data-testid=\"checkbox-card-seed-confirmed\"\n                    />\n                    <label htmlFor=\"card-seed-confirmed\" className=\"text-sm cursor-pointer\">\n                      I have written down my recovery phrase and stored it safely\n                    </label>\n                  </div>\n                  <Button\n                    className=\"w-full\"\n                    onClick={() => setSoftWalletStep(\"confirm\")}\n                    disabled={!softWalletSeedConfirmed}\n                    data-testid=\"button-card-continue-to-confirm\"\n                  >\n                    Continue\n                  </Button>\n                </div>\n              )}\n\n              {/* Step 3: Confirm */}\n              {softWalletStep === \"confirm\" && (\n                <div className=\"space-y-4\">\n                  <Alert variant=\"destructive\">\n                    <AlertTriangle className=\"h-4 w-4\" />\n                    <AlertDescription>\n                      <strong>Important:</strong> Your recovery phrase is the ONLY way to recover your wallet if you lose access. \n                      If you lose it, your funds will be lost forever. Make sure you have stored it safely before continuing.\n                    </AlertDescription>\n                  </Alert>\n                  <div className=\"flex gap-2\">\n                    <Button variant=\"outline\" onClick={() => setSoftWalletStep(\"display\")} className=\"flex-1\" data-testid=\"button-card-go-back\">\n                      Go Back\n                    </Button>\n                    <Button onClick={() => setSoftWalletStep(\"pin\")} className=\"flex-1\" data-testid=\"button-card-continue-to-pin\">\n                      I Understand, Continue\n                    </Button>\n                  </div>\n                </div>\n              )}\n\n              {/* Step 4: PIN */}\n              {softWalletStep === \"pin\" && (\n                <div className=\"space-y-4\">\n                  <p className=\"text-sm text-muted-foreground\">Create a PIN (5 digits) to protect your wallet. You will need this PIN every time you want to unlock your wallet.</p>\n                  <div className=\"space-y-2\">\n                    <Label>New PIN (5 digits)</Label>\n                    <Input\n                      type=\"password\"\n                      inputMode=\"numeric\"\n                      maxLength={5}\n                      placeholder=\"Enter PIN\"\n                      value={softWalletNewPin}\n                      onChange={(e) => { setSoftWalletNewPin(e.target.value.replace(/\\D/g, \"\")); setSoftWalletError(\"\"); }}\n                      data-testid=\"input-card-wallet-pin\"\n                    />\n                  </div>\n                  <div className=\"space-y-2\">\n                    <Label>Confirm PIN</Label>\n                    <Input\n                      type=\"password\"\n                      inputMode=\"numeric\"\n                      maxLength={5}\n                      placeholder=\"Confirm PIN\"\n                      value={softWalletConfirmPin}\n                      onChange={(e) => { setSoftWalletConfirmPin(e.target.value.replace(/\\D/g, \"\")); setSoftWalletError(\"\"); }}\n                      data-testid=\"input-card-wallet-confirm-pin\"\n                    />\n                  </div>\n                  {softWalletError && <Alert variant=\"destructive\"><AlertTriangle className=\"h-4 w-4\" /><AlertDescription>{softWalletError}</AlertDescription></Alert>}\n                  <div className=\"flex gap-2\">\n                    <Button\n                      variant=\"outline\"\n                      onClick={() => setSoftWalletStep(softWalletMode === \"create\" ? \"confirm\" : \"choose\")}\n                      className=\"flex-1\"\n                      data-testid=\"button-card-back\"\n                    >\n                      Back\n                    </Button>\n                    <Button\n                      onClick={handleSetupSoftWallet}\n                      disabled={!softWalletNewPin || !softWalletConfirmPin || isSoftWalletLoading}\n                      className=\"flex-1\"\n                      data-testid=\"button-card-wallet-create\"\n                    >\n                      {isSoftWalletLoading ? \"Creating...\" : \"Create Wallet\"}\n                    </Button>\n                  </div>\n                </div>\n              )}\n            </>\n          )}\n        </DialogContent>\n      </Dialog>\n\n      <Dialog open={showRecoverDialog} onOpenChange={setShowRecoverDialog}>\n        <DialogContent className=\"max-w-md\">\n          <DialogHeader>\n            <DialogTitle>Recover Your Wallet</DialogTitle>\n            <DialogDescription>\n              Enter your 12 or 24 word recovery phrase to restore your wallet.\n            </DialogDescription>\n          </DialogHeader>\n          <div className=\"space-y-4\">\n            <Alert>\n              <AlertTriangle className=\"h-4 w-4\" />\n              <AlertDescription>\n                Only enter your recovery phrase on trusted devices. Never share it with anyone.\n              </AlertDescription>\n            </Alert>\n            \n            <div className=\"space-y-2\">\n              <Label htmlFor=\"seed-phrase\">Recovery Phrase</Label>\n              <textarea\n                id=\"seed-phrase\"\n                className=\"flex min-h-[100px] w-full rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2\"\n                placeholder=\"Enter your 12 or 24 word recovery phrase, separated by spaces\"\n                value={seedPhraseInput}\n                onChange={(e) => {\n                  setSeedPhraseInput(e.target.value);\n                  setRecoverError(\"\");\n                }}\n                data-testid=\"input-recovery-phrase\"\n              />\n            </div>\n            \n            <div className=\"space-y-2\">\n              <Label htmlFor=\"new-pin\">New PIN (5 digits)</Label>\n              <Input\n                id=\"new-pin\"\n                type=\"password\"\n                inputMode=\"numeric\"\n                maxLength={5}\n                placeholder=\"Enter new PIN\"\n                value={newPin}\n                onChange={(e) => {\n                  const val = e.target.value.replace(/\\D/g, \"\");\n                  setNewPin(val);\n                  setRecoverError(\"\");\n                }}\n                data-testid=\"input-new-pin\"\n              />\n            </div>\n            \n            <div className=\"space-y-2\">\n              <Label htmlFor=\"confirm-pin\">Confirm PIN</Label>\n              <Input\n                id=\"confirm-pin\"\n                type=\"password\"\n                inputMode=\"numeric\"\n                maxLength={5}\n                placeholder=\"Confirm new PIN\"\n                value={confirmPin}\n                onChange={(e) => {\n                  const val = e.target.value.replace(/\\D/g, \"\");\n                  setConfirmPin(val);\n                  setRecoverError(\"\");\n                }}\n                data-testid=\"input-confirm-pin\"\n              />\n            </div>\n            \n            {recoverError && (\n              <Alert variant=\"destructive\">\n                <AlertTriangle className=\"h-4 w-4\" />\n                <AlertDescription>{recoverError}</AlertDescription>\n              </Alert>\n            )}\n          </div>\n          <DialogFooter>\n            <Button variant=\"outline\" onClick={() => setShowRecoverDialog(false)}>\n              Cancel\n            </Button>\n            <Button \n              onClick={handleRecover}\n              disabled={!seedPhraseInput.trim() || !newPin || !confirmPin || isRecovering}\n              data-testid=\"button-confirm-recover\"\n            >\n              {isRecovering ? \"Recovering...\" : \"Recover Wallet\"}\n            </Button>\n          </DialogFooter>\n        </DialogContent>\n      </Dialog>\n\n      {/* Pico Wallet Setup Dialog - Multi-step Wizard */}\n      <Dialog open={showPicoSetupDialog} onOpenChange={setShowPicoSetupDialog}>\n        <DialogContent className=\"max-w-lg\">\n          <DialogHeader>\n            <DialogTitle>\n              {picoStep === \"choose\" && \"Set Up New Wallet\"}\n              {picoStep === \"display\" && \"Your Recovery Phrase\"}\n              {picoStep === \"confirm\" && \"Confirm Backup\"}\n              {picoStep === \"pin\" && \"Create Your PIN\"}\n            </DialogTitle>\n            <DialogDescription>\n              {picoStep === \"choose\" && \"Create a new wallet or import an existing one\"}\n              {picoStep === \"display\" && \"Write down these words in order and store them safely\"}\n              {picoStep === \"confirm\" && \"Confirm that you have saved your recovery phrase\"}\n              {picoStep === \"pin\" && \"Set a PIN to protect your wallet\"}\n            </DialogDescription>\n          </DialogHeader>\n\n          {picoStep === \"choose\" && (\n            <div className=\"space-y-4\">\n              <Tabs value={picoMode} onValueChange={(v) => setPicoMode(v as \"create\" | \"import\")}>\n                <TabsList className=\"grid w-full grid-cols-2\">\n                  <TabsTrigger value=\"create\" data-testid=\"card-tab-create-new\">\n                    <Plus className=\"mr-2 h-4 w-4\" />Create New\n                  </TabsTrigger>\n                  <TabsTrigger value=\"import\" data-testid=\"card-tab-import-existing\">\n                    <Download className=\"mr-2 h-4 w-4\" />Import Existing\n                  </TabsTrigger>\n                </TabsList>\n\n                <TabsContent value=\"create\" className=\"space-y-4 mt-4\">\n                  <p className=\"text-sm text-muted-foreground\">Generate a new recovery phrase for your wallet. Choose the number of words:</p>\n                  <div className=\"flex gap-2\">\n                    <Button variant={picoWordCount === 12 ? \"default\" : \"outline\"} onClick={() => setPicoWordCount(12)} className=\"flex-1\" data-testid=\"card-button-12-words\">12 Words</Button>\n                    <Button variant={picoWordCount === 24 ? \"default\" : \"outline\"} onClick={() => setPicoWordCount(24)} className=\"flex-1\" data-testid=\"card-button-24-words\">24 Words (Recommended)</Button>\n                  </div>\n                  <Button className=\"w-full\" onClick={handleGenerateSeed} data-testid=\"card-button-generate-seed\">\n                    <Shield className=\"mr-2 h-4 w-4\" />Generate Recovery Phrase\n                  </Button>\n                </TabsContent>\n\n                <TabsContent value=\"import\" className=\"space-y-4 mt-4\">\n                  <Alert><AlertTriangle className=\"h-4 w-4\" /><AlertDescription>Only import a phrase you trust. Never share it with anyone.</AlertDescription></Alert>\n                  <div className=\"space-y-2\">\n                    <Label>Recovery Phrase (12 or 24 words)</Label>\n                    <textarea className=\"flex min-h-[100px] w-full rounded-md border border-input bg-background px-3 py-2 text-sm\" placeholder=\"Enter your recovery phrase, separated by spaces\" value={picoImportSeed} onChange={(e) => { setPicoImportSeed(e.target.value); setPicoSetupError(\"\"); }} data-testid=\"card-input-import-seed\" />\n                  </div>\n                  {picoSetupError && <Alert variant=\"destructive\"><AlertTriangle className=\"h-4 w-4\" /><AlertDescription>{picoSetupError}</AlertDescription></Alert>}\n                  <Button className=\"w-full\" onClick={() => { const words = picoImportSeed.trim().toLowerCase().split(/\\s+/); if (words.length !== 12 && words.length !== 24) { setPicoSetupError(\"Recovery phrase must be 12 or 24 words.\"); return; } setPicoStep(\"pin\"); }} disabled={!picoImportSeed.trim()} data-testid=\"card-button-continue-import\">Continue to PIN Setup</Button>\n                </TabsContent>\n              </Tabs>\n            </div>\n          )}\n\n          {picoStep === \"display\" && (\n            <div className=\"space-y-4\">\n              <Alert><AlertTriangle className=\"h-4 w-4\" /><AlertDescription>Write these words down on paper. Never store them digitally or share with anyone.</AlertDescription></Alert>\n              <div className=\"grid grid-cols-3 gap-2 p-4 bg-muted rounded-md\">\n                {picoGeneratedSeed.split(\" \").map((word, idx) => (\n                  <div key={idx} className=\"flex items-center gap-2 text-sm\">\n                    <span className=\"text-muted-foreground w-5 text-right\">{idx + 1}.</span>\n                    <span className=\"font-mono\" data-testid={`card-word-${idx + 1}`}>{word}</span>\n                  </div>\n                ))}\n              </div>\n              <Button variant=\"outline\" className=\"w-full\" onClick={handleCopySeed} data-testid=\"card-button-copy-seed\">\n                {picoCopied ? <><Check className=\"mr-2 h-4 w-4\" />Copied!</> : <><Copy className=\"mr-2 h-4 w-4\" />Copy to Clipboard</>}\n              </Button>\n              <div className=\"flex items-center space-x-2\">\n                <Checkbox id=\"card-seed-confirmed\" checked={picoSeedConfirmed} onCheckedChange={(checked) => setPicoSeedConfirmed(checked === true)} data-testid=\"card-checkbox-seed-confirmed\" />\n                <label htmlFor=\"card-seed-confirmed\" className=\"text-sm cursor-pointer\">I have written down my recovery phrase and stored it safely</label>\n              </div>\n              <Button className=\"w-full\" onClick={() => setPicoStep(\"confirm\")} disabled={!picoSeedConfirmed} data-testid=\"card-button-continue-to-confirm\">Continue</Button>\n            </div>\n          )}\n\n          {picoStep === \"confirm\" && (\n            <div className=\"space-y-4\">\n              <Alert variant=\"destructive\"><AlertTriangle className=\"h-4 w-4\" /><AlertDescription><strong>Important:</strong> Your recovery phrase is the ONLY way to recover your wallet if you lose access. If you lose it, your funds will be lost forever.</AlertDescription></Alert>\n              <div className=\"flex gap-2\">\n                <Button variant=\"outline\" onClick={() => setPicoStep(\"display\")} className=\"flex-1\">Go Back</Button>\n                <Button onClick={() => setPicoStep(\"pin\")} className=\"flex-1\" data-testid=\"card-button-continue-to-pin\">I Understand, Continue</Button>\n              </div>\n            </div>\n          )}\n\n          {picoStep === \"pin\" && (\n            <div className=\"space-y-4\">\n              <p className=\"text-sm text-muted-foreground\">Create a PIN (4-6 digits) to protect your wallet.</p>\n              <div className=\"space-y-2\">\n                <Label>New PIN (4-6 digits)</Label>\n                <Input type=\"password\" inputMode=\"numeric\" maxLength={6} placeholder=\"Enter PIN\" value={picoNewPin} onChange={(e) => { setPicoNewPin(e.target.value.replace(/\\D/g, \"\")); setPicoSetupError(\"\"); }} data-testid=\"card-input-pico-new-pin\" />\n              </div>\n              <div className=\"space-y-2\">\n                <Label>Confirm PIN</Label>\n                <Input type=\"password\" inputMode=\"numeric\" maxLength={6} placeholder=\"Confirm PIN\" value={picoConfirmPin} onChange={(e) => { setPicoConfirmPin(e.target.value.replace(/\\D/g, \"\")); setPicoSetupError(\"\"); }} data-testid=\"card-input-pico-confirm-pin\" />\n              </div>\n              {picoSetupError && <Alert variant=\"destructive\"><AlertTriangle className=\"h-4 w-4\" /><AlertDescription>{picoSetupError}</AlertDescription></Alert>}\n              <div className=\"flex gap-2\">\n                <Button variant=\"outline\" onClick={() => setPicoStep(picoMode === \"create\" ? \"confirm\" : \"choose\")} className=\"flex-1\">Back</Button>\n                <Button onClick={handleSetupPicoWallet} disabled={!picoNewPin || !picoConfirmPin || isPicoSetupLoading} className=\"flex-1\" data-testid=\"button-setup-pico-wallet\">{isPicoSetupLoading ? \"Setting up...\" : \"Create Wallet\"}</Button>\n              </div>\n            </div>\n          )}\n\n          <DialogFooter><Button variant=\"ghost\" onClick={() => setShowPicoSetupDialog(false)}>Cancel</Button></DialogFooter>\n        </DialogContent>\n      </Dialog>\n    </>\n  );\n}\n\nexport function WalletModeSelector() {\n  const { \n    isConnected, \n    isUnlocked, \n    hardwareState,\n    disconnectDevice,\n    setShowPinModal,\n    setPinAction,\n    connectRaspberryPi,\n    connectSimulated,\n    unlockWallet,\n    deriveWallets,\n    isLoading,\n    hasSoftWalletSetup,\n    walletMode,\n    setWalletMode,\n  } = useWallet();\n  const { toast } = useToast();\n  \n  const [showModeSwitchDialog, setShowModeSwitchDialog] = useState(false);\n  const [targetMode, setTargetMode] = useState<\"hard_wallet\" | \"soft_wallet\">(\"soft_wallet\");\n  const [showPicoSetupDialog, setShowPicoSetupDialog] = useState(false);\n  \n  const [seedPhrase, setSeedPhrase] = useState(\"\");\n  const [newPin, setNewPin] = useState(\"\");\n  const [confirmPin, setConfirmPin] = useState(\"\");\n  const [setupError, setSetupError] = useState(\"\");\n  const [isSettingUp, setIsSettingUp] = useState(false);\n  \n  const handleModeSwitch = async (mode: \"hard_wallet\" | \"soft_wallet\") => {\n    if (mode === walletMode) return;\n    setTargetMode(mode);\n    setShowModeSwitchDialog(true);\n  };\n  \n  const confirmSwitch = async () => {\n    setShowModeSwitchDialog(false);\n    await disconnectDevice();\n    \n    if (targetMode === \"hard_wallet\") {\n      const result = await connectRaspberryPi();\n      if (result.success) {\n        if (!result.hasWallet) {\n          setShowPicoSetupDialog(true);\n        } else {\n          setPinAction(\"unlock\");\n          setShowPinModal(true);\n        }\n      } else {\n        toast({ title: \"Connection Failed\", description: result.error || \"Could not connect to hardware wallet\", variant: \"destructive\" });\n      }\n    } else {\n      // Switching to soft wallet mode\n      setWalletMode(\"soft_wallet\");\n      \n      if (hasSoftWalletSetup) {\n        // Soft wallet already exists - show unlock modal\n        setPinAction(\"unlock\");\n        setShowPinModal(true);\n      } else {\n        // No soft wallet set up - show setup dialog\n        setSeedPhrase(\"\");\n        setNewPin(\"\");\n        setConfirmPin(\"\");\n        setSetupError(\"\");\n        setShowPicoSetupDialog(true);\n      }\n    }\n  };\n  \n  const handleCreateSoftWallet = async () => {\n    setSetupError(\"\");\n    const words = seedPhrase.trim().toLowerCase().split(/\\s+/);\n    if (words.length !== 12 && words.length !== 24) {\n      setSetupError(\"Recovery phrase must be 12 or 24 words.\");\n      return;\n    }\n    if (newPin.length < 4 || newPin.length > 6 || !/^\\d+$/.test(newPin)) {\n      setSetupError(\"PIN must be 4-6 digits.\");\n      return;\n    }\n    if (newPin !== confirmPin) {\n      setSetupError(\"PINs do not match.\");\n      return;\n    }\n    \n    setIsSettingUp(true);\n    try {\n      const { hardwareWallet } = await import(\"@/lib/hardware-wallet\");\n      await hardwareWallet.setPin(newPin);\n      const success = await connectSimulated(words.join(\" \"));\n      if (success) {\n        const unlocked = await unlockWallet(newPin);\n        if (unlocked) {\n          await deriveWallets();\n          setShowPicoSetupDialog(false);\n          toast({ title: \"Wallet Created\", description: \"Your soft wallet is ready.\" });\n        }\n      }\n    } catch (error: any) {\n      setSetupError(error.message || \"Failed to create wallet.\");\n    } finally {\n      setIsSettingUp(false);\n    }\n  };\n\n  if (!isConnected || !isUnlocked) return null;\n\n  return (\n    <>\n      <div className=\"flex items-center gap-2 p-1 rounded-lg bg-muted/50\">\n        <Button\n          size=\"sm\"\n          variant={walletMode === \"hard_wallet\" ? \"default\" : \"ghost\"}\n          onClick={() => handleModeSwitch(\"hard_wallet\")}\n          className=\"gap-1.5\"\n          disabled={isLoading}\n          data-testid=\"button-mode-hard-wallet\"\n        >\n          <Cpu className=\"h-4 w-4\" />\n          <span className=\"hidden sm:inline\">Hard Wallet</span>\n        </Button>\n        <Button\n          size=\"sm\"\n          variant={walletMode === \"soft_wallet\" ? \"default\" : \"ghost\"}\n          onClick={() => handleModeSwitch(\"soft_wallet\")}\n          className=\"gap-1.5\"\n          disabled={isLoading}\n          data-testid=\"button-mode-soft-wallet\"\n        >\n          <Laptop className=\"h-4 w-4\" />\n          <span className=\"hidden sm:inline\">Soft Wallet</span>\n        </Button>\n      </div>\n      \n      <Dialog open={showModeSwitchDialog} onOpenChange={setShowModeSwitchDialog}>\n        <DialogContent className=\"max-w-sm\">\n          <DialogHeader>\n            <DialogTitle>Switch Wallet Mode</DialogTitle>\n            <DialogDescription>\n              Switching to {targetMode === \"hard_wallet\" ? \"Hard Wallet\" : \"Soft Wallet\"} will disconnect your current wallet. You'll need to set up or unlock the new wallet.\n            </DialogDescription>\n          </DialogHeader>\n          <DialogFooter className=\"gap-2\">\n            <Button variant=\"outline\" onClick={() => setShowModeSwitchDialog(false)}>Cancel</Button>\n            <Button onClick={confirmSwitch} data-testid=\"button-confirm-switch\">Switch</Button>\n          </DialogFooter>\n        </DialogContent>\n      </Dialog>\n      \n      <Dialog open={showPicoSetupDialog && targetMode === \"soft_wallet\"} onOpenChange={setShowPicoSetupDialog}>\n        <DialogContent className=\"max-w-md\">\n          <DialogHeader>\n            <DialogTitle>Set Up Soft Wallet</DialogTitle>\n            <DialogDescription>Enter a seed phrase to create your soft wallet.</DialogDescription>\n          </DialogHeader>\n          <div className=\"space-y-4\">\n            <Alert><Shield className=\"h-4 w-4\" /><AlertDescription>For testing only. Enter a seed phrase to simulate a hardware wallet.</AlertDescription></Alert>\n            <div className=\"space-y-2\">\n              <Label>Seed Phrase (12 or 24 words)</Label>\n              <textarea className=\"flex min-h-[80px] w-full rounded-md border border-input bg-background px-3 py-2 text-sm\" placeholder=\"Enter your seed phrase separated by spaces\" value={seedPhrase} onChange={(e) => { setSeedPhrase(e.target.value); setSetupError(\"\"); }} data-testid=\"input-mode-seed-phrase\" />\n            </div>\n            <div className=\"space-y-2\">\n              <Label>New PIN (5 digits)</Label>\n              <Input type=\"password\" inputMode=\"numeric\" maxLength={5} placeholder=\"Enter PIN\" value={newPin} onChange={(e) => { setNewPin(e.target.value.replace(/\\D/g, \"\")); setSetupError(\"\"); }} data-testid=\"input-mode-new-pin\" />\n            </div>\n            <div className=\"space-y-2\">\n              <Label>Confirm PIN</Label>\n              <Input type=\"password\" inputMode=\"numeric\" maxLength={5} placeholder=\"Confirm PIN\" value={confirmPin} onChange={(e) => { setConfirmPin(e.target.value.replace(/\\D/g, \"\")); setSetupError(\"\"); }} data-testid=\"input-mode-confirm-pin\" />\n            </div>\n            {setupError && <Alert variant=\"destructive\"><AlertTriangle className=\"h-4 w-4\" /><AlertDescription>{setupError}</AlertDescription></Alert>}\n          </div>\n          <DialogFooter className=\"gap-2\">\n            <Button variant=\"ghost\" onClick={() => setShowPicoSetupDialog(false)}>Cancel</Button>\n            <Button onClick={handleCreateSoftWallet} disabled={!seedPhrase.trim() || !newPin || !confirmPin || isSettingUp} data-testid=\"button-create-soft-wallet\">\n              {isSettingUp ? \"Creating...\" : \"Create Wallet\"}\n            </Button>\n          </DialogFooter>\n        </DialogContent>\n      </Dialog>\n    </>\n  );\n}\n","path":null,"size_bytes":94883,"size_tokens":null},"client/src/pages/token-detail.tsx":{"content":"import { useState, useEffect } from \"react\";\nimport { useParams, Link, useLocation } from \"wouter\";\nimport {\n  ArrowUpRight,\n  ArrowDownLeft,\n  ArrowLeft,\n  Copy,\n  RefreshCw,\n  ExternalLink,\n  TrendingUp,\n  TrendingDown,\n  Loader2,\n  CheckCircle2,\n  XCircle,\n} from \"lucide-react\";\nimport { Button } from \"@/components/ui/button\";\nimport { Card, CardContent } from \"@/components/ui/card\";\nimport { Badge } from \"@/components/ui/badge\";\nimport { Progress } from \"@/components/ui/progress\";\nimport { useWallet } from \"@/lib/wallet-context\";\nimport { useToast } from \"@/hooks/use-toast\";\nimport { ChainIcon } from \"@/components/chain-icon\";\nimport { fetchPrices, formatUSD, formatCryptoBalance, type PriceData } from \"@/lib/price-service\";\nimport { fetchAllTransactions, type ParsedTransaction } from \"@/lib/explorer-service\";\nimport { TOKEN_PARENT_CHAIN } from \"@/lib/chain-mappings\";\nimport { pendingTxTracker, type PendingTransaction } from \"@/lib/pending-tx-tracker\";\n\nconst COINGECKO_ID_BY_SYMBOL: Record<string, string> = {\n  'BTC': 'bitcoin',\n  'ETH': 'ethereum',\n  'BNB': 'binancecoin',\n  'SOL': 'solana',\n  'TRX': 'tron',\n  'MATIC': 'matic-network',\n  'AVAX': 'avalanche-2',\n  'ARB': 'arbitrum',\n};\n\nconst JSDELIVR_CDN = 'https://cdn.jsdelivr.net/npm/cryptocurrency-icons@0.16.1/128/color';\nconst COINGECKO_CDN = 'https://assets.coingecko.com/coins/images';\n\nconst CRYPTO_ICONS: Record<string, string> = {\n  'bitcoin': `${JSDELIVR_CDN}/btc.png`,\n  'ethereum': `${JSDELIVR_CDN}/eth.png`,\n  'tether': `${JSDELIVR_CDN}/usdt.png`,\n  'binancecoin': `${JSDELIVR_CDN}/bnb.png`,\n  'solana': `${COINGECKO_CDN}/4128/small/solana.png`,\n  'usd-coin': `${JSDELIVR_CDN}/usdc.png`,\n  'tron': `${JSDELIVR_CDN}/trx.png`,\n  'staked-ether': `${COINGECKO_CDN}/13442/small/steth_logo.png`,\n};\n\nconst TOKEN_BASE_ID: Record<string, string> = {\n  'tether-bsc': 'tether',\n  'tether-tron': 'tether',\n  'tether-ethereum': 'tether',\n  'usd-coin-bsc': 'usd-coin',\n  'usd-coin-ethereum': 'usd-coin',\n  'usd-coin-solana': 'usd-coin',\n  'staked-ether-ethereum': 'staked-ether',\n};\n\nfunction getTokenIcon(tokenId: string, tokenImage?: string): string | undefined {\n  if (tokenImage) return tokenImage;\n  if (CRYPTO_ICONS[tokenId]) return CRYPTO_ICONS[tokenId];\n  const baseId = TOKEN_BASE_ID[tokenId];\n  if (baseId && CRYPTO_ICONS[baseId]) return CRYPTO_ICONS[baseId];\n  return undefined;\n}\n\nconst formatBalance = formatCryptoBalance;\n\nfunction formatDate(timestamp: string): string {\n  return new Date(timestamp).toLocaleDateString(undefined, {\n    month: 'short',\n    day: 'numeric',\n    hour: '2-digit',\n    minute: '2-digit',\n  });\n}\n\nfunction shortenAddress(address: string): string {\n  if (!address) return \"\";\n  return `${address.slice(0, 6)}...${address.slice(-4)}`;\n}\n\nexport default function TokenDetail() {\n  const params = useParams<{ chainId: string; tokenId: string }>();\n  const { chainId, tokenId } = params;\n  const { toast } = useToast();\n  const [, navigate] = useLocation();\n  const { chains, visibleWallets, customTokens, topAssets, refreshWalletBalance, tokenBalances, customTokenBalances } = useWallet();\n  \n  const [prices, setPrices] = useState<PriceData>({});\n  const [isRefreshing, setIsRefreshing] = useState(false);\n  const [transactions, setTransactions] = useState<ParsedTransaction[]>([]);\n  const [isLoadingTransactions, setIsLoadingTransactions] = useState(false);\n  const [pendingTransactions, setPendingTransactions] = useState<PendingTransaction[]>([]);\n\n  const chain = chains.find(c => c.id === chainId);\n  const wallet = visibleWallets.find(w => w.chainId === chainId);\n  \n  const isNativeToken = tokenId === \"native\" || tokenId === chain?.symbol;\n  \n  // Check if it's a standard token from topAssets (like USDT, USDC)\n  const standardToken = !isNativeToken ? topAssets.find(a => a.id === tokenId) : null;\n  const isStandardToken = !!standardToken && !!TOKEN_PARENT_CHAIN[standardToken.id];\n  \n  const customToken = !isNativeToken && !isStandardToken ? customTokens.find(t => \n    t.id === tokenId || t.contractAddress.toLowerCase() === tokenId?.toLowerCase()\n  ) : null;\n\n  const tokenSymbol = isNativeToken ? chain?.symbol : (standardToken?.symbol?.toUpperCase() || customToken?.symbol);\n  const tokenName = isNativeToken ? chain?.name : (standardToken?.name || customToken?.name);\n  \n  // Get token balance from context - native tokens use wallet balance, standard tokens use tokenBalances, custom tokens use customTokenBalances\n  const tokenBalance = isNativeToken \n    ? wallet?.balance || \"0\" \n    : isStandardToken && tokenId\n      ? tokenBalances[tokenId] || \"0\"\n      : customToken \n        ? customTokenBalances[customToken.id] || \"0\"\n        : \"0\";\n  const tokenContractAddress = customToken?.contractAddress;\n\n  const coingeckoId = tokenSymbol ? COINGECKO_ID_BY_SYMBOL[tokenSymbol] : undefined;\n  const topAsset = standardToken || (coingeckoId ? topAssets.find(a => a.id === coingeckoId) : undefined);\n  const price = topAsset?.currentPrice || (tokenSymbol ? prices[tokenSymbol] : 0) || 0;\n  const priceChange24h = topAsset?.priceChangePercentage24h || 0;\n  const usdValue = parseFloat(tokenBalance) * price;\n\n  useEffect(() => {\n    fetchPrices().then(setPrices).catch(console.error);\n  }, [tokenSymbol]);\n\n  // Fetch transactions for this wallet and filter for this specific token\n  useEffect(() => {\n    if (!wallet || !chain) return;\n\n    const loadTransactions = async () => {\n      setIsLoadingTransactions(true);\n      try {\n        const walletData = [{\n          id: wallet.id,\n          address: wallet.address,\n          chainId: chain.id,\n          numericChainId: chain.chainId,\n          chainSymbol: chain.symbol,\n          blockExplorerUrl: chain.blockExplorer,\n        }];\n\n        const allTxs = await fetchAllTransactions(walletData);\n        \n        // Filter transactions for this specific token\n        const walletAddressLower = wallet.address.toLowerCase();\n        const filteredTxs = allTxs.filter(tx => {\n          // First, verify transaction involves our wallet correctly:\n          // - Send transactions must be FROM our wallet\n          // - Receive transactions must be TO our wallet\n          const isValidSend = tx.type === 'send' && tx.fromAddress?.toLowerCase() === walletAddressLower;\n          const isValidReceive = tx.type === 'receive' && tx.toAddress?.toLowerCase() === walletAddressLower;\n          \n          if (!isValidSend && !isValidReceive) {\n            return false;\n          }\n\n          // Then filter by token type\n          if (isNativeToken) {\n            // For native tokens, show transactions without token transfers\n            return !tx.isTokenTransfer;\n          } else if (customToken) {\n            // For custom tokens, match by contract address\n            return tx.isTokenTransfer && \n              tx.contractAddress?.toLowerCase() === customToken.contractAddress.toLowerCase();\n          } else if (standardToken) {\n            // For standard tokens, match by token symbol\n            return tx.isTokenTransfer && \n              tx.tokenSymbol?.toUpperCase() === tokenSymbol?.toUpperCase();\n          }\n          return false;\n        });\n\n        setTransactions(filteredTxs);\n      } catch (err) {\n        console.error(\"Failed to fetch transactions:\", err);\n      } finally {\n        setIsLoadingTransactions(false);\n      }\n    };\n\n    loadTransactions();\n  }, [wallet?.id, chain?.id, tokenId, isNativeToken, customToken, standardToken, tokenSymbol]);\n\n  useEffect(() => {\n    if (!chainId) return;\n    \n    const unsubscribe = pendingTxTracker.subscribe((allPendingTxs) => {\n      const chainPendingTxs = allPendingTxs.filter(tx => {\n        if (tx.chainId !== chainId) return false;\n        if (isNativeToken) {\n          return tx.tokenSymbol === chain?.symbol;\n        }\n        return tx.tokenSymbol?.toUpperCase() === tokenSymbol?.toUpperCase();\n      });\n      setPendingTransactions(chainPendingTxs);\n    });\n    \n    return () => unsubscribe();\n  }, [chainId, chain?.symbol, isNativeToken, tokenSymbol]);\n\n  const handleRefresh = async () => {\n    if (!wallet) return;\n    setIsRefreshing(true);\n    try {\n      await refreshWalletBalance(wallet.id);\n      const newPrices = await fetchPrices();\n      setPrices(newPrices);\n      toast({ title: \"Refreshed\", description: \"Balance updated successfully\" });\n    } catch {\n      toast({ title: \"Error\", description: \"Failed to refresh\", variant: \"destructive\" });\n    } finally {\n      setIsRefreshing(false);\n    }\n  };\n\n  const copyToClipboard = (text: string, label: string) => {\n    navigator.clipboard.writeText(text);\n    toast({ title: \"Copied\", description: `${label} copied to clipboard` });\n  };\n\n  if (!chain || !wallet) {\n    return (\n      <div className=\"p-4\">\n        <Link href=\"/\">\n          <Button variant=\"ghost\" size=\"sm\">\n            <ArrowLeft className=\"h-4 w-4 mr-2\" />\n            Back\n          </Button>\n        </Link>\n        <p className=\"text-center text-muted-foreground mt-8\">Token not found</p>\n      </div>\n    );\n  }\n\n  return (\n    <div className=\"min-h-screen bg-background\">\n      <div className=\"sticky top-0 z-50 bg-background border-b\">\n        <div className=\"flex items-center justify-between px-4 py-3\">\n          <div className=\"flex items-center gap-2\">\n            <Button \n              variant=\"ghost\" \n              size=\"icon\" \n              onClick={() => navigate(`/?chain=${chainId}&wallet=${wallet?.id || ''}`)}\n              data-testid=\"button-back\"\n            >\n              <ArrowLeft className=\"h-5 w-5\" />\n            </Button>\n            <div className=\"flex items-center gap-2\">\n              {isNativeToken ? (\n                <ChainIcon symbol={tokenSymbol || \"\"} size=\"md\" />\n              ) : getTokenIcon(tokenId || '', standardToken?.image) ? (\n                <img \n                  src={getTokenIcon(tokenId || '', standardToken?.image)} \n                  alt={tokenName || ''} \n                  className=\"h-8 w-8 rounded-full bg-muted\"\n                />\n              ) : (\n                <div className=\"h-8 w-8 rounded-full bg-primary flex items-center justify-center text-primary-foreground text-sm font-bold\">\n                  {(tokenSymbol || '').slice(0, 2)}\n                </div>\n              )}\n              <div>\n                <h1 className=\"text-lg font-semibold\">{tokenName}</h1>\n                <p className=\"text-xs text-muted-foreground\">{tokenSymbol}</p>\n              </div>\n            </div>\n          </div>\n          <Button\n            size=\"icon\"\n            variant=\"ghost\"\n            onClick={handleRefresh}\n            disabled={isRefreshing}\n            data-testid=\"button-refresh\"\n          >\n            <RefreshCw className={`h-4 w-4 ${isRefreshing ? \"animate-spin\" : \"\"}`} />\n          </Button>\n        </div>\n      </div>\n\n      <div className=\"p-4 space-y-6\">\n        <div className=\"text-center py-4\">\n          <div className=\"flex justify-center mb-4\">\n            {isNativeToken ? (\n              <ChainIcon symbol={tokenSymbol || \"\"} size=\"lg\" />\n            ) : getTokenIcon(tokenId || '', standardToken?.image) ? (\n              <img \n                src={getTokenIcon(tokenId || '', standardToken?.image)} \n                alt={tokenName || ''} \n                className=\"h-16 w-16 rounded-full bg-muted\"\n              />\n            ) : (\n              <div className=\"h-16 w-16 rounded-full bg-primary flex items-center justify-center text-primary-foreground text-2xl font-bold\">\n                {(tokenSymbol || '').slice(0, 2)}\n              </div>\n            )}\n          </div>\n          <h2 className=\"text-3xl font-bold\" data-testid=\"text-token-balance\">\n            {formatBalance(tokenBalance)} {tokenSymbol}\n          </h2>\n          <p className=\"text-xl text-muted-foreground\" data-testid=\"text-token-value\">\n            {formatUSD(usdValue)}\n          </p>\n          {price > 0 && (\n            <div className=\"flex items-center justify-center gap-2 mt-2\">\n              <span className=\"text-sm text-muted-foreground\">\n                {formatUSD(price)}\n              </span>\n              <Badge \n                variant={priceChange24h >= 0 ? \"default\" : \"destructive\"}\n                className=\"text-xs\"\n              >\n                {priceChange24h >= 0 ? (\n                  <TrendingUp className=\"h-3 w-3 mr-1\" />\n                ) : (\n                  <TrendingDown className=\"h-3 w-3 mr-1\" />\n                )}\n                {priceChange24h >= 0 ? \"+\" : \"\"}{priceChange24h.toFixed(2)}%\n              </Badge>\n            </div>\n          )}\n        </div>\n\n        <div className=\"grid grid-cols-2 gap-3\">\n          <Link href={`/transfer?type=send&chain=${chainId}&token=${isNativeToken ? 'native' : customToken?.id || tokenId}`}>\n            <Button className=\"w-full h-12 rounded-xl\" data-testid=\"button-send-token\">\n              <ArrowUpRight className=\"h-5 w-5 mr-2\" />\n              Send\n            </Button>\n          </Link>\n          <Link href={`/transfer?type=receive&chain=${chainId}`}>\n            <Button className=\"w-full h-12 rounded-xl\" variant=\"outline\" data-testid=\"button-receive-token\">\n              <ArrowDownLeft className=\"h-5 w-5 mr-2\" />\n              Receive\n            </Button>\n          </Link>\n        </div>\n\n        <Card>\n          <CardContent className=\"p-4 space-y-3\">\n            <h3 className=\"font-semibold\">Token Info</h3>\n            \n            <div className=\"flex items-center justify-between py-2 border-b\">\n              <span className=\"text-muted-foreground\">Network</span>\n              <div className=\"flex items-center gap-2\">\n                <ChainIcon symbol={chain.symbol} size=\"sm\" />\n                <span>{chain.name}</span>\n              </div>\n            </div>\n\n            {tokenContractAddress && (\n              <div className=\"flex items-center justify-between py-2 border-b\">\n                <span className=\"text-muted-foreground\">Contract</span>\n                <div className=\"flex items-center gap-2\">\n                  <span className=\"font-mono text-sm\">{shortenAddress(tokenContractAddress)}</span>\n                  <Button\n                    size=\"icon\"\n                    variant=\"ghost\"\n                    className=\"h-6 w-6\"\n                    onClick={() => copyToClipboard(tokenContractAddress, \"Contract address\")}\n                  >\n                    <Copy className=\"h-3 w-3\" />\n                  </Button>\n                </div>\n              </div>\n            )}\n\n            {wallet.address && (\n              <div className=\"flex items-center justify-between py-2 border-b\">\n                <span className=\"text-muted-foreground\">Your Address</span>\n                <div className=\"flex items-center gap-2\">\n                  <span className=\"font-mono text-sm\">{shortenAddress(wallet.address)}</span>\n                  <Button\n                    size=\"icon\"\n                    variant=\"ghost\"\n                    className=\"h-6 w-6\"\n                    onClick={() => copyToClipboard(wallet.address, \"Address\")}\n                  >\n                    <Copy className=\"h-3 w-3\" />\n                  </Button>\n                </div>\n              </div>\n            )}\n\n            {customToken && (\n              <div className=\"flex items-center justify-between py-2\">\n                <span className=\"text-muted-foreground\">Decimals</span>\n                <span>{customToken.decimals}</span>\n              </div>\n            )}\n          </CardContent>\n        </Card>\n\n        <div>\n          <h3 className=\"font-semibold mb-3\">Recent Activity</h3>\n          <Card>\n            <CardContent className=\"p-4\">\n              {pendingTransactions.length > 0 && (\n                <div className=\"space-y-3 mb-4\">\n                  {pendingTransactions.map((tx) => {\n                    const progress = tx.requiredConfirmations > 0 \n                      ? Math.min((tx.currentConfirmations / tx.requiredConfirmations) * 100, 100)\n                      : 0;\n                    \n                    return (\n                      <div key={tx.id} className=\"p-3 rounded-md bg-muted/50 border\">\n                        <div className=\"flex items-center justify-between mb-2\">\n                          <div className=\"flex items-center gap-3\">\n                            <div className=\"h-8 w-8 rounded-full flex items-center justify-center bg-amber-100 dark:bg-amber-900\">\n                              {tx.status === \"confirmed\" ? (\n                                <CheckCircle2 className=\"h-4 w-4 text-green-600 dark:text-green-400\" />\n                              ) : tx.status === \"failed\" ? (\n                                <XCircle className=\"h-4 w-4 text-red-600 dark:text-red-400\" />\n                              ) : (\n                                <Loader2 className=\"h-4 w-4 text-amber-600 dark:text-amber-400 animate-spin\" />\n                              )}\n                            </div>\n                            <div>\n                              <p className=\"font-medium\">\n                                {tx.status === \"pending\" ? \"Broadcasting...\" : \n                                 tx.status === \"confirming\" ? \"Confirming...\" :\n                                 tx.status === \"confirmed\" ? \"Confirmed\" : \"Failed\"}\n                              </p>\n                              <p className=\"text-xs text-muted-foreground\">\n                                {tx.txHash?.slice(0, 10)}...\n                              </p>\n                            </div>\n                          </div>\n                          <div className=\"text-right\">\n                            <p className=\"font-medium\">\n                              -{formatBalance(tx.amount)} {tx.tokenSymbol}\n                            </p>\n                            <p className=\"text-xs text-muted-foreground\">\n                              {tx.status === \"confirmed\" ? \"Complete\" : \n                               `${tx.currentConfirmations}/${tx.requiredConfirmations} confirmations`}\n                            </p>\n                          </div>\n                        </div>\n                        {tx.status !== \"confirmed\" && tx.status !== \"failed\" && (\n                          <Progress value={progress} className=\"h-2\" />\n                        )}\n                      </div>\n                    );\n                  })}\n                </div>\n              )}\n              \n              {isLoadingTransactions ? (\n                <p className=\"text-center text-muted-foreground py-6\">\n                  Loading transactions...\n                </p>\n              ) : transactions.length === 0 && pendingTransactions.length === 0 ? (\n                <p className=\"text-center text-muted-foreground py-6\">\n                  No transactions yet\n                </p>\n              ) : transactions.length > 0 ? (\n                <div className=\"space-y-3\">\n                  {transactions.slice(0, 5).map((tx) => (\n                    <div \n                      key={tx.txHash} \n                      className=\"flex items-center justify-between py-2 border-b last:border-0 cursor-pointer hover-elevate rounded-md px-2 -mx-2\"\n                      onClick={() => {\n                        const params = new URLSearchParams({\n                          hash: tx.txHash,\n                          chain: chainId || '',\n                          type: tx.type,\n                          amount: tx.amount,\n                          token: tx.tokenSymbol,\n                          from: tx.fromAddress,\n                          to: tx.toAddress,\n                          time: tx.timestamp,\n                          status: tx.status,\n                        });\n                        navigate(`/transaction?${params.toString()}`);\n                      }}\n                      data-testid={`transaction-${tx.txHash?.slice(0, 8)}`}\n                    >\n                      <div className=\"flex items-center gap-3\">\n                        <div className={`h-8 w-8 rounded-full flex items-center justify-center ${\n                          tx.type === 'receive' ? 'bg-green-100 dark:bg-green-900' : 'bg-red-100 dark:bg-red-900'\n                        }`}>\n                          {tx.type === 'receive' ? (\n                            <ArrowDownLeft className=\"h-4 w-4 text-green-600 dark:text-green-400\" />\n                          ) : (\n                            <ArrowUpRight className=\"h-4 w-4 text-red-600 dark:text-red-400\" />\n                          )}\n                        </div>\n                        <div>\n                          <p className=\"font-medium capitalize\">{tx.type}</p>\n                          <p className=\"text-xs text-muted-foreground\">\n                            {formatDate(tx.timestamp)}\n                          </p>\n                        </div>\n                      </div>\n                      <div className=\"text-right\">\n                        <p className={`font-medium ${tx.type === 'receive' ? 'text-green-600' : ''}`}>\n                          {tx.type === 'receive' ? '+' : '-'}{formatBalance(tx.amount)} {tx.tokenSymbol}\n                        </p>\n                      </div>\n                    </div>\n                  ))}\n                </div>\n              ) : null}\n            </CardContent>\n          </Card>\n        </div>\n      </div>\n    </div>\n  );\n}\n","path":null,"size_bytes":21385,"size_tokens":null},"client/src/components/ui/popover.tsx":{"content":"import * as React from \"react\"\nimport * as PopoverPrimitive from \"@radix-ui/react-popover\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst Popover = PopoverPrimitive.Root\n\nconst PopoverTrigger = PopoverPrimitive.Trigger\n\nconst PopoverContent = React.forwardRef<\n  React.ElementRef<typeof PopoverPrimitive.Content>,\n  React.ComponentPropsWithoutRef<typeof PopoverPrimitive.Content>\n>(({ className, align = \"center\", sideOffset = 4, ...props }, ref) => (\n  <PopoverPrimitive.Portal>\n    <PopoverPrimitive.Content\n      ref={ref}\n      align={align}\n      sideOffset={sideOffset}\n      className={cn(\n        \"z-50 w-72 rounded-md border bg-popover p-4 text-popover-foreground shadow-md outline-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 origin-[--radix-popover-content-transform-origin]\",\n        className\n      )}\n      {...props}\n    />\n  </PopoverPrimitive.Portal>\n))\nPopoverContent.displayName = PopoverPrimitive.Content.displayName\n\nexport { Popover, PopoverTrigger, PopoverContent }\n","path":null,"size_bytes":1280,"size_tokens":null},"client/src/components/app-sidebar.tsx":{"content":"import { Link, useLocation } from \"wouter\";\nimport { \n  LayoutDashboard, \n  ArrowLeftRight, \n  Layers, \n  Settings, \n  Shield,\n  Lock,\n  Unlock,\n  BookOpen,\n  Coins,\n  Link2,\n  Cpu,\n  Laptop,\n  Smartphone,\n} from \"lucide-react\";\nimport {\n  Sidebar,\n  SidebarContent,\n  SidebarGroup,\n  SidebarGroupContent,\n  SidebarGroupLabel,\n  SidebarHeader,\n  SidebarMenu,\n  SidebarMenuButton,\n  SidebarMenuItem,\n  SidebarFooter,\n} from \"@/components/ui/sidebar\";\nimport { Badge } from \"@/components/ui/badge\";\nimport { Button } from \"@/components/ui/button\";\nimport { useWallet } from \"@/lib/wallet-context\";\n\nconst menuItems = [\n  {\n    title: \"Dashboard\",\n    url: \"/\",\n    icon: LayoutDashboard,\n  },\n  {\n    title: \"Send / Receive\",\n    url: \"/transfer\",\n    icon: ArrowLeftRight,\n  },\n  {\n    title: \"Chains & Tokens\",\n    url: \"/chains\",\n    icon: Layers,\n    softWalletOnly: true,\n  },\n  {\n    title: \"Manage Crypto\",\n    url: \"/manage-crypto\",\n    icon: Coins,\n  },\n  {\n    title: \"DApps\",\n    url: \"/dapps\",\n    icon: Link2,\n    softWalletOnly: true,\n  },\n  {\n    title: \"Settings\",\n    url: \"/settings\",\n    icon: Settings,\n  },\n  {\n    title: \"Setup Guide\",\n    url: \"/setup\",\n    icon: BookOpen,\n  },\n  {\n    title: \"Mobile Bridge\",\n    url: \"/bridge\",\n    icon: Smartphone,\n  },\n];\n\nexport function AppSidebar() {\n  const [location] = useLocation();\n  const { isConnected, isUnlocked, hardwareState, wallets, setShowPinModal, setPinAction, lockWallet, walletMode, setWalletMode, currentModeHasWallet } = useWallet();\n  const hasWallet = currentModeHasWallet;\n\n  const handleUnlock = () => {\n    if (!hasWallet) {\n      setPinAction(\"setup\");\n    } else {\n      setPinAction(\"unlock\");\n    }\n    setShowPinModal(true);\n  };\n\n  return (\n    <Sidebar>\n      <SidebarHeader className=\"border-b border-sidebar-border p-4\">\n        <div className=\"flex items-center gap-3\">\n          <div className=\"flex h-10 w-10 items-center justify-center rounded-lg bg-primary\">\n            <Shield className=\"h-6 w-6 text-primary-foreground\" />\n          </div>\n          <div className=\"flex flex-col\">\n            <span className=\"text-lg font-semibold\">VaultKey</span>\n            <span className=\"text-xs text-muted-foreground\">Crypto Wallet</span>\n          </div>\n        </div>\n\n        {/* Wallet Mode Toggle */}\n        <div className=\"mt-3 flex rounded-md border border-border overflow-hidden\">\n          <button\n            onClick={() => setWalletMode(\"hard_wallet\")}\n            className={`flex-1 flex items-center justify-center gap-1.5 py-1.5 px-3 text-xs font-medium transition-colors ${\n              walletMode === \"hard_wallet\" \n                ? \"bg-primary text-primary-foreground\" \n                : \"bg-background text-muted-foreground hover:bg-muted\"\n            }`}\n            data-testid=\"button-mode-hard-wallet\"\n          >\n            <Cpu className=\"h-3.5 w-3.5\" />\n            Hard Wallet\n          </button>\n          <button\n            onClick={() => setWalletMode(\"soft_wallet\")}\n            className={`flex-1 flex items-center justify-center gap-1.5 py-1.5 px-3 text-xs font-medium transition-colors ${\n              walletMode === \"soft_wallet\" \n                ? \"bg-primary text-primary-foreground\" \n                : \"bg-background text-muted-foreground hover:bg-muted\"\n            }`}\n            data-testid=\"button-mode-soft-wallet\"\n          >\n            <Laptop className=\"h-3.5 w-3.5\" />\n            Soft Wallet\n          </button>\n        </div>\n\n        {/* Status Display - Only show device status for hard wallet mode */}\n        <div className=\"mt-3 flex items-center justify-between rounded-lg bg-sidebar-accent/50 p-3\">\n          <div className=\"flex items-center gap-2\">\n            {walletMode === \"soft_wallet\" ? (\n              hasWallet ? (\n                isUnlocked ? (\n                  <>\n                    <div className=\"h-2 w-2 rounded-full bg-green-500 animate-pulse\" />\n                    <span className=\"text-sm font-medium\">Active</span>\n                  </>\n                ) : (\n                  <>\n                    <Lock className=\"h-4 w-4 text-muted-foreground\" />\n                    <span className=\"text-sm text-muted-foreground\">Locked</span>\n                  </>\n                )\n              ) : (\n                <>\n                  <Laptop className=\"h-4 w-4 text-muted-foreground\" />\n                  <span className=\"text-sm text-muted-foreground\">Not Set Up</span>\n                </>\n              )\n            ) : (\n              hasWallet ? (\n                isUnlocked ? (\n                  <>\n                    <div className=\"h-2 w-2 rounded-full bg-green-500 animate-pulse\" />\n                    <span className=\"text-sm font-medium\">Connected</span>\n                  </>\n                ) : (\n                  <>\n                    <Lock className=\"h-4 w-4 text-muted-foreground\" />\n                    <span className=\"text-sm text-muted-foreground\">Locked</span>\n                  </>\n                )\n              ) : (\n                <>\n                  <div className=\"h-2 w-2 rounded-full bg-muted-foreground/50\" />\n                  <span className=\"text-sm text-muted-foreground\">No Device</span>\n                </>\n              )\n            )}\n          </div>\n          {hasWallet && !isUnlocked && (\n            <Button size=\"sm\" variant=\"ghost\" onClick={handleUnlock} data-testid=\"button-sidebar-unlock\">\n              <Unlock className=\"h-4 w-4\" />\n            </Button>\n          )}\n          {hasWallet && isUnlocked && (\n            <Button size=\"sm\" variant=\"ghost\" onClick={lockWallet} data-testid=\"button-sidebar-lock\">\n              <Lock className=\"h-4 w-4\" />\n            </Button>\n          )}\n        </div>\n      </SidebarHeader>\n\n      <SidebarContent>\n        <SidebarGroup>\n          <SidebarGroupContent>\n            <SidebarMenu>\n              {menuItems\n                .filter((item) => {\n                  // Hide soft wallet only items in hard wallet mode\n                  if (item.softWalletOnly && walletMode === \"hard_wallet\") return false;\n                  return true;\n                })\n                .map((item) => {\n                const isActive = location === item.url || \n                  (item.url !== \"/\" && location.startsWith(item.url));\n                \n                return (\n                  <SidebarMenuItem key={item.title}>\n                    <SidebarMenuButton \n                      asChild \n                      isActive={isActive}\n                      className={isActive ? \"bg-sidebar-accent\" : \"\"}\n                    >\n                      <Link href={item.url} data-testid={`link-${item.title.toLowerCase().replace(/\\s+/g, \"-\")}`}>\n                        <item.icon className=\"h-5 w-5\" />\n                        <span>{item.title}</span>\n                      </Link>\n                    </SidebarMenuButton>\n                  </SidebarMenuItem>\n                );\n              })}\n            </SidebarMenu>\n          </SidebarGroupContent>\n        </SidebarGroup>\n      </SidebarContent>\n\n      <SidebarFooter className=\"border-t border-sidebar-border p-4\">\n        <div className=\"flex items-center gap-2 text-xs text-muted-foreground\">\n          <Shield className=\"h-3 w-3\" />\n          <span>Secured by hardware encryption</span>\n        </div>\n      </SidebarFooter>\n    </Sidebar>\n  );\n}\n","path":null,"size_bytes":7380,"size_tokens":null},"client/src/pages/wallet.tsx":{"content":"import { useState } from \"react\";\nimport { Card, CardContent, CardHeader, CardTitle } from \"@/components/ui/card\";\nimport { Button } from \"@/components/ui/button\";\nimport { Badge } from \"@/components/ui/badge\";\nimport { useToast } from \"@/hooks/use-toast\";\nimport { getWalletAddresses, formatAddress, copyToClipboard } from \"@/lib/crypto-utils\";\nimport { Copy, Check, ArrowLeft, Wallet } from \"lucide-react\";\nimport { Link } from \"wouter\";\nimport { SiBitcoin, SiEthereum, SiLitecoin, SiDogecoin } from \"react-icons/si\";\n\nfunction getCryptoIcon(iconName: string, color: string) {\n  const iconProps = { className: \"w-6 h-6\", style: { color } };\n  \n  switch (iconName) {\n    case \"bitcoin\":\n      return <SiBitcoin {...iconProps} />;\n    case \"ethereum\":\n      return <SiEthereum {...iconProps} />;\n    case \"litecoin\":\n      return <SiLitecoin {...iconProps} />;\n    case \"dogecoin\":\n      return <SiDogecoin {...iconProps} />;\n    case \"bitcoincash\":\n      return <SiBitcoin {...iconProps} />;\n    case \"xrp\":\n      return <Wallet {...iconProps} />;\n    default:\n      return <Wallet {...iconProps} />;\n  }\n}\n\nexport default function WalletPage() {\n  const { toast } = useToast();\n  const [copiedAddress, setCopiedAddress] = useState<string | null>(null);\n  const addresses = getWalletAddresses();\n\n  const handleCopy = async (address: string, chainName: string) => {\n    const success = await copyToClipboard(address);\n    if (success) {\n      setCopiedAddress(address);\n      toast({\n        title: \"Address Copied\",\n        description: `${chainName} address copied to clipboard`,\n      });\n      setTimeout(() => setCopiedAddress(null), 2000);\n    }\n  };\n\n  return (\n    <div className=\"min-h-screen bg-background p-4 sm:p-6 md:p-8\">\n      <div className=\"max-w-2xl mx-auto\">\n        <div className=\"flex items-center gap-4 mb-8\">\n          <Link href=\"/\">\n            <Button variant=\"ghost\" size=\"icon\" data-testid=\"button-back\">\n              <ArrowLeft className=\"w-5 h-5\" />\n            </Button>\n          </Link>\n          <div>\n            <h1 className=\"text-2xl sm:text-3xl font-bold text-foreground\" data-testid=\"text-page-title\">\n              Your Addresses\n            </h1>\n            <p className=\"text-muted-foreground text-sm mt-1\">\n              Native addresses for all enabled coins\n            </p>\n          </div>\n        </div>\n\n        <div className=\"space-y-4\">\n          {addresses.map((walletAddress) => (\n            <Card \n              key={walletAddress.chainId} \n              className=\"overflow-visible\"\n              data-testid={`card-address-${walletAddress.chainId}`}\n            >\n              <CardHeader className=\"flex flex-row items-center justify-between gap-4 pb-2\">\n                <div className=\"flex items-center gap-3\">\n                  {getCryptoIcon(walletAddress.chain.icon, walletAddress.chain.color)}\n                  <div>\n                    <CardTitle className=\"text-base font-semibold\">\n                      {walletAddress.chain.name}\n                    </CardTitle>\n                    <Badge variant=\"secondary\" className=\"mt-1\">\n                      {walletAddress.chain.symbol}\n                    </Badge>\n                  </div>\n                </div>\n                <Button\n                  variant=\"outline\"\n                  size=\"icon\"\n                  onClick={() => handleCopy(walletAddress.address, walletAddress.chain.name)}\n                  data-testid={`button-copy-${walletAddress.chainId}`}\n                >\n                  {copiedAddress === walletAddress.address ? (\n                    <Check className=\"w-4 h-4 text-green-500\" />\n                  ) : (\n                    <Copy className=\"w-4 h-4\" />\n                  )}\n                </Button>\n              </CardHeader>\n              <CardContent>\n                <div \n                  className=\"font-mono text-sm text-muted-foreground bg-muted/50 rounded-md p-3 break-all\"\n                  data-testid={`text-address-${walletAddress.chainId}`}\n                >\n                  {walletAddress.address}\n                </div>\n                <p \n                  className=\"text-xs text-muted-foreground mt-2 sm:hidden\"\n                  data-testid={`text-address-short-${walletAddress.chainId}`}\n                >\n                  {formatAddress(walletAddress.address, 12, 8)}\n                </p>\n              </CardContent>\n            </Card>\n          ))}\n        </div>\n\n        {addresses.length === 0 && (\n          <Card className=\"text-center py-12\">\n            <CardContent>\n              <Wallet className=\"w-12 h-12 mx-auto text-muted-foreground mb-4\" />\n              <p className=\"text-muted-foreground\">No coins enabled</p>\n            </CardContent>\n          </Card>\n        )}\n      </div>\n    </div>\n  );\n}\n","path":null,"size_bytes":4799,"size_tokens":null},"client/src/components/ui/toaster.tsx":{"content":"import { useToast } from \"@/hooks/use-toast\"\nimport {\n  Toast,\n  ToastClose,\n  ToastDescription,\n  ToastProvider,\n  ToastTitle,\n  ToastViewport,\n} from \"@/components/ui/toast\"\n\nexport function Toaster() {\n  const { toasts } = useToast()\n\n  return (\n    <ToastProvider>\n      {toasts.map(function ({ id, title, description, action, ...props }) {\n        return (\n          <Toast key={id} {...props}>\n            <div className=\"grid gap-1\">\n              {title && <ToastTitle>{title}</ToastTitle>}\n              {description && (\n                <ToastDescription>{description}</ToastDescription>\n              )}\n            </div>\n            {action}\n            <ToastClose />\n          </Toast>\n        )\n      })}\n      <ToastViewport />\n    </ToastProvider>\n  )\n}\n","path":null,"size_bytes":772,"size_tokens":null},"client/src/lib/theme-context.tsx":{"content":"import { createContext, useContext, useEffect, useState } from \"react\";\n\ntype Theme = \"light\" | \"dark\";\n\ninterface ThemeContextType {\n  theme: Theme;\n  toggleTheme: () => void;\n  setTheme: (theme: Theme) => void;\n}\n\nconst ThemeContext = createContext<ThemeContextType | undefined>(undefined);\n\nexport function ThemeProvider({ children }: { children: React.ReactNode }) {\n  const [theme, setThemeState] = useState<Theme>(() => {\n    if (typeof window !== \"undefined\") {\n      const saved = localStorage.getItem(\"theme\") as Theme;\n      if (saved) return saved;\n    }\n    return \"light\";\n  });\n\n  useEffect(() => {\n    const root = document.documentElement;\n    if (theme === \"dark\") {\n      root.classList.add(\"dark\");\n    } else {\n      root.classList.remove(\"dark\");\n    }\n    localStorage.setItem(\"theme\", theme);\n  }, [theme]);\n\n  const toggleTheme = () => {\n    setThemeState((prev) => (prev === \"light\" ? \"dark\" : \"light\"));\n  };\n\n  const setTheme = (newTheme: Theme) => {\n    setThemeState(newTheme);\n  };\n\n  return (\n    <ThemeContext.Provider value={{ theme, toggleTheme, setTheme }}>\n      {children}\n    </ThemeContext.Provider>\n  );\n}\n\nexport function useTheme() {\n  const context = useContext(ThemeContext);\n  if (!context) {\n    throw new Error(\"useTheme must be used within ThemeProvider\");\n  }\n  return context;\n}\n","path":null,"size_bytes":1329,"size_tokens":null},"client/src/App.tsx":{"content":"import { Switch, Route } from \"wouter\";\nimport { queryClient } from \"./lib/queryClient\";\nimport { QueryClientProvider } from \"@tanstack/react-query\";\nimport { Toaster } from \"@/components/ui/toaster\";\nimport { TooltipProvider } from \"@/components/ui/tooltip\";\nimport { SidebarProvider } from \"@/components/ui/sidebar\";\nimport { Shield } from \"lucide-react\";\nimport { ThemeProvider } from \"@/lib/theme-context\";\nimport { WalletProvider } from \"@/lib/wallet-context\";\nimport { AppSidebar } from \"@/components/app-sidebar\";\nimport { HardwareStatus } from \"@/components/hardware-status\";\nimport { PinModal } from \"@/components/pin-modal\";\nimport { MobileFooter } from \"@/components/mobile-footer\";\n\nimport Dashboard from \"@/pages/dashboard\";\nimport Transfer from \"@/pages/transfer\";\nimport Chains from \"@/pages/chains\";\nimport Settings from \"@/pages/settings\";\nimport SetupGuide from \"@/pages/setup-guide\";\nimport ManageCrypto from \"@/pages/manage-crypto\";\nimport DApps from \"@/pages/dapps\";\nimport DAppBrowser from \"@/pages/dapp-browser\";\nimport TokenDetail from \"@/pages/token-detail\";\nimport TransactionDetail from \"@/pages/transaction-detail\";\nimport Bridge from \"@/pages/bridge\";\nimport NotFound from \"@/pages/not-found\";\n\nfunction Router() {\n  return (\n    <Switch>\n      <Route path=\"/\" component={Dashboard} />\n      <Route path=\"/wallet/:chainId/token/:tokenId\" component={TokenDetail} />\n      <Route path=\"/transaction\" component={TransactionDetail} />\n      <Route path=\"/transfer\" component={Transfer} />\n      <Route path=\"/chains\" component={Chains} />\n      <Route path=\"/settings\" component={Settings} />\n      <Route path=\"/setup\" component={SetupGuide} />\n      <Route path=\"/manage-crypto\" component={ManageCrypto} />\n      <Route path=\"/dapps\" component={DApps} />\n      <Route path=\"/dapp-browser\" component={DAppBrowser} />\n      <Route path=\"/bridge\" component={Bridge} />\n      <Route component={NotFound} />\n    </Switch>\n  );\n}\n\nfunction App() {\n  const style = {\n    \"--sidebar-width\": \"16rem\",\n    \"--sidebar-width-icon\": \"3.5rem\",\n  };\n\n  return (\n    <QueryClientProvider client={queryClient}>\n      <ThemeProvider>\n        <WalletProvider>\n          <TooltipProvider>\n            <SidebarProvider style={style as React.CSSProperties}>\n              <div className=\"flex h-screen w-full\">\n                <AppSidebar />\n                <div className=\"flex flex-1 flex-col overflow-hidden\">\n                  <header className=\"flex h-14 items-center justify-between gap-4 border-b border-border px-4\">\n                    <div className=\"flex items-center gap-2\">\n                      <Shield className=\"h-5 w-5 text-primary\" />\n                      <span className=\"font-semibold text-lg\">VaultKey</span>\n                    </div>\n                    <HardwareStatus />\n                  </header>\n                  <main className=\"flex-1 overflow-auto pb-28 md:pb-0\">\n                    <Router />\n                  </main>\n                </div>\n              </div>\n              <MobileFooter />\n            </SidebarProvider>\n            <PinModal />\n            <Toaster />\n          </TooltipProvider>\n        </WalletProvider>\n      </ThemeProvider>\n    </QueryClientProvider>\n  );\n}\n\nexport default App;\n","path":null,"size_bytes":3247,"size_tokens":null},"client/src/components/ui/tooltip.tsx":{"content":"\"use client\"\n\nimport * as React from \"react\"\nimport * as TooltipPrimitive from \"@radix-ui/react-tooltip\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst TooltipProvider = TooltipPrimitive.Provider\n\nconst Tooltip = TooltipPrimitive.Root\n\nconst TooltipTrigger = TooltipPrimitive.Trigger\n\nconst TooltipContent = React.forwardRef<\n  React.ElementRef<typeof TooltipPrimitive.Content>,\n  React.ComponentPropsWithoutRef<typeof TooltipPrimitive.Content>\n>(({ className, sideOffset = 4, ...props }, ref) => (\n  <TooltipPrimitive.Content\n    ref={ref}\n    sideOffset={sideOffset}\n    className={cn(\n      \"z-50 overflow-hidden rounded-md border bg-popover px-3 py-1.5 text-sm text-popover-foreground shadow-md animate-in fade-in-0 zoom-in-95 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 origin-[--radix-tooltip-content-transform-origin]\",\n      className\n    )}\n    {...props}\n  />\n))\nTooltipContent.displayName = TooltipPrimitive.Content.displayName\n\nexport { Tooltip, TooltipTrigger, TooltipContent, TooltipProvider }\n","path":null,"size_bytes":1209,"size_tokens":null},"client/src/components/ui/pagination.tsx":{"content":"import * as React from \"react\"\nimport { ChevronLeft, ChevronRight, MoreHorizontal } from \"lucide-react\"\n\nimport { cn } from \"@/lib/utils\"\nimport { ButtonProps, buttonVariants } from \"@/components/ui/button\"\n\nconst Pagination = ({ className, ...props }: React.ComponentProps<\"nav\">) => (\n  <nav\n    role=\"navigation\"\n    aria-label=\"pagination\"\n    className={cn(\"mx-auto flex w-full justify-center\", className)}\n    {...props}\n  />\n)\nPagination.displayName = \"Pagination\"\n\nconst PaginationContent = React.forwardRef<\n  HTMLUListElement,\n  React.ComponentProps<\"ul\">\n>(({ className, ...props }, ref) => (\n  <ul\n    ref={ref}\n    className={cn(\"flex flex-row items-center gap-1\", className)}\n    {...props}\n  />\n))\nPaginationContent.displayName = \"PaginationContent\"\n\nconst PaginationItem = React.forwardRef<\n  HTMLLIElement,\n  React.ComponentProps<\"li\">\n>(({ className, ...props }, ref) => (\n  <li ref={ref} className={cn(\"\", className)} {...props} />\n))\nPaginationItem.displayName = \"PaginationItem\"\n\ntype PaginationLinkProps = {\n  isActive?: boolean\n} & Pick<ButtonProps, \"size\"> &\n  React.ComponentProps<\"a\">\n\nconst PaginationLink = ({\n  className,\n  isActive,\n  size = \"icon\",\n  ...props\n}: PaginationLinkProps) => (\n  <a\n    aria-current={isActive ? \"page\" : undefined}\n    className={cn(\n      buttonVariants({\n        variant: isActive ? \"outline\" : \"ghost\",\n        size,\n      }),\n      className\n    )}\n    {...props}\n  />\n)\nPaginationLink.displayName = \"PaginationLink\"\n\nconst PaginationPrevious = ({\n  className,\n  ...props\n}: React.ComponentProps<typeof PaginationLink>) => (\n  <PaginationLink\n    aria-label=\"Go to previous page\"\n    size=\"default\"\n    className={cn(\"gap-1 pl-2.5\", className)}\n    {...props}\n  >\n    <ChevronLeft className=\"h-4 w-4\" />\n    <span>Previous</span>\n  </PaginationLink>\n)\nPaginationPrevious.displayName = \"PaginationPrevious\"\n\nconst PaginationNext = ({\n  className,\n  ...props\n}: React.ComponentProps<typeof PaginationLink>) => (\n  <PaginationLink\n    aria-label=\"Go to next page\"\n    size=\"default\"\n    className={cn(\"gap-1 pr-2.5\", className)}\n    {...props}\n  >\n    <span>Next</span>\n    <ChevronRight className=\"h-4 w-4\" />\n  </PaginationLink>\n)\nPaginationNext.displayName = \"PaginationNext\"\n\nconst PaginationEllipsis = ({\n  className,\n  ...props\n}: React.ComponentProps<\"span\">) => (\n  <span\n    aria-hidden\n    className={cn(\"flex h-9 w-9 items-center justify-center\", className)}\n    {...props}\n  >\n    <MoreHorizontal className=\"h-4 w-4\" />\n    <span className=\"sr-only\">More pages</span>\n  </span>\n)\nPaginationEllipsis.displayName = \"PaginationEllipsis\"\n\nexport {\n  Pagination,\n  PaginationContent,\n  PaginationEllipsis,\n  PaginationItem,\n  PaginationLink,\n  PaginationNext,\n  PaginationPrevious,\n}\n","path":null,"size_bytes":2751,"size_tokens":null},"client/src/components/pin-modal.tsx":{"content":"import { useState, useEffect, useCallback } from \"react\";\nimport { useLocation } from \"wouter\";\nimport { Dialog, DialogContent, DialogHeader, DialogTitle, DialogDescription } from \"@/components/ui/dialog\";\nimport { AlertDialog, AlertDialogAction, AlertDialogCancel, AlertDialogContent, AlertDialogDescription, AlertDialogFooter, AlertDialogHeader, AlertDialogTitle } from \"@/components/ui/alert-dialog\";\nimport { Alert, AlertDescription } from \"@/components/ui/alert\";\nimport { Button } from \"@/components/ui/button\";\nimport { Shield, Lock, ArrowRight, Delete, X, AlertTriangle, RotateCcw } from \"lucide-react\";\nimport { useWallet } from \"@/lib/wallet-context\";\nimport { useToast } from \"@/hooks/use-toast\";\nimport { hardwareWallet } from \"@/lib/hardware-wallet\";\nimport { softWallet } from \"@/lib/soft-wallet\";\nimport { piWallet } from \"@/lib/pi-wallet\";\nimport { clientStorage, type StoredTransaction } from \"@/lib/client-storage\";\nimport { \n  buildTransaction, \n  broadcastTransaction, \n  getChainSymbol, \n  isChainSupported,\n  getTokenContract,\n  getChainInfo,\n  type TransactionParams \n} from \"@/lib/transaction-service\";\nimport { \n  broadcastNonEvmTransaction,\n  type NonEvmTransactionParams \n} from \"@/lib/non-evm-chains\";\nimport { clearExplorerCache } from \"@/lib/explorer-service\";\nimport { pendingTxTracker } from \"@/lib/pending-tx-tracker\";\n\nexport function PinModal() {\n  const { \n    showPinModal, \n    setShowPinModal, \n    pinAction, \n    setPinAction,\n    hardwareState,\n    walletMode,\n    unlockWallet,\n    deriveWallets,\n    pendingTransaction,\n    setPendingTransaction,\n    disconnectDevice,\n    refreshBalances,\n  } = useWallet();\n  const { toast } = useToast();\n  const [, setLocation] = useLocation();\n  \n  const [pin, setPin] = useState(\"\");\n  const [confirmPin, setConfirmPin] = useState(\"\");\n  const [step, setStep] = useState<\"enter\" | \"confirm\">(\"enter\");\n  const [pinLength, setPinLength] = useState(walletMode === \"soft_wallet\" ? 5 : 6);\n  const [isLoading, setIsLoading] = useState(false);\n  const [error, setError] = useState(\"\");\n  const [showResetConfirm, setShowResetConfirm] = useState(false);\n  const [isResetting, setIsResetting] = useState(false);\n\n  const maxLength = pinLength;\n\n  useEffect(() => {\n    if (showPinModal) {\n      setPin(\"\");\n      setConfirmPin(\"\");\n      setStep(\"enter\");\n      setError(\"\");\n      setIsLoading(false);\n    }\n  }, [showPinModal]);\n\n  useEffect(() => {\n    if (!showPinModal) {\n      setPin(\"\");\n      setConfirmPin(\"\");\n      setError(\"\");\n      setIsLoading(false);\n    }\n  }, [showPinModal]);\n\n  const handleNumberClick = useCallback((num: string) => {\n    setError(\"\");\n    if (step === \"enter\" && pin.length < maxLength) {\n      setPin((prev) => prev + num);\n    } else if (step === \"confirm\" && confirmPin.length < maxLength) {\n      setConfirmPin((prev) => prev + num);\n    }\n  }, [step, pin.length, confirmPin.length, maxLength]);\n\n  const handleDelete = useCallback(() => {\n    if (step === \"enter\") {\n      setPin((prev) => prev.slice(0, -1));\n    } else {\n      setConfirmPin((prev) => prev.slice(0, -1));\n    }\n    setError(\"\");\n  }, [step]);\n\n  const handleClear = useCallback(() => {\n    if (step === \"enter\") {\n      setPin(\"\");\n    } else {\n      setConfirmPin(\"\");\n    }\n    setError(\"\");\n  }, [step]);\n\n  const handleSubmit = useCallback(async () => {\n    if (pinAction === \"unlock\" || pinAction === \"sign\") {\n      if (pin.length < 4) {\n        setError(\"PIN must be at least 4 digits\");\n        return;\n      }\n\n      setIsLoading(true);\n      try {\n        const success = await unlockWallet(pin);\n        \n        if (success) {\n          await deriveWallets();\n          \n          if (pinAction === \"sign\" && pendingTransaction) {\n            const chainSupport = isChainSupported(pendingTransaction.chainId);\n            \n            if (!chainSupport.supported) {\n              toast({\n                title: \"Chain Not Supported\",\n                description: chainSupport.reason || \"This chain is not yet supported for transactions\",\n                variant: \"destructive\",\n              });\n              setPendingTransaction(null);\n              setShowPinModal(false);\n              setPinAction(null);\n              setIsLoading(false);\n              return;\n            }\n\n            const evmChainIdForAddress = chainSupport.evmChainId || 1;\n            const walletAddress = walletMode === \"soft_wallet\" \n              ? await softWallet.getAddress(evmChainIdForAddress)\n              : await hardwareWallet.getAddress(evmChainIdForAddress);\n            \n            if (!walletAddress) {\n              toast({\n                title: \"Wallet Error\",\n                description: \"Could not get wallet address\",\n                variant: \"destructive\",\n              });\n              setPendingTransaction(null);\n              setShowPinModal(false);\n              setPinAction(null);\n              setIsLoading(false);\n              return;\n            }\n\n            const chainSymbol = getChainSymbol(pendingTransaction.chainId);\n            const isNonEvmChain = chainSupport.type === \"bitcoin\" || chainSupport.type === \"solana\" || chainSupport.type === \"tron\";\n            \n            if (isNonEvmChain) {\n              const nonEvmParams: NonEvmTransactionParams = {\n                chainType: chainSupport.type as \"bitcoin\" | \"solana\" | \"tron\",\n                from: walletAddress,\n                to: pendingTransaction.toAddress,\n                amount: pendingTransaction.amount,\n                isNativeToken: pendingTransaction.isNativeToken ?? true,\n              };\n\n              const signedResult = walletMode === \"soft_wallet\"\n                ? await softWallet.signNonEvmTransaction(nonEvmParams)\n                : await hardwareWallet.signNonEvmTransaction(nonEvmParams);\n              \n              if (!signedResult) {\n                toast({\n                  title: \"Signing Failed\",\n                  description: walletMode === \"soft_wallet\" \n                    ? \"Could not sign the transaction\" \n                    : \"Non-EVM signing is only supported in simulated hardware wallet mode\",\n                  variant: \"destructive\",\n                });\n                setPendingTransaction(null);\n                setShowPinModal(false);\n                setPinAction(null);\n                setIsLoading(false);\n                return;\n              }\n\n              const broadcastResult = await broadcastNonEvmTransaction(signedResult.chainType, signedResult.signedTx);\n              \n              if (broadcastResult.success) {\n                const txId = `tx-${Date.now()}-${Math.random().toString(36).slice(2, 8)}`;\n                const storedTx: StoredTransaction = {\n                  id: txId,\n                  walletId: pendingTransaction.chainId,\n                  chainId: pendingTransaction.chainId,\n                  type: \"send\",\n                  status: \"confirmed\",\n                  amount: pendingTransaction.amount,\n                  tokenSymbol: pendingTransaction.tokenSymbol || chainSymbol,\n                  toAddress: pendingTransaction.toAddress,\n                  fromAddress: walletAddress,\n                  txHash: broadcastResult.txHash || signedResult.txHash,\n                  timestamp: new Date().toISOString(),\n                };\n                await clientStorage.saveTransaction(storedTx);\n                \n                toast({\n                  title: \"Transaction Sent\",\n                  description: `Transaction broadcast successfully. Hash: ${(broadcastResult.txHash || signedResult.txHash)?.slice(0, 10)}...`,\n                });\n                \n                clearExplorerCache();\n                refreshBalances();\n                \n                const tokenId = pendingTransaction.isNativeToken ? \"native\" : (pendingTransaction.tokenSymbol || \"native\");\n                setLocation(`/wallet/${pendingTransaction.chainId}/token/${tokenId}`);\n              } else {\n                toast({\n                  title: \"Broadcast Failed\",\n                  description: broadcastResult.error || \"Failed to broadcast transaction\",\n                  variant: \"destructive\",\n                });\n                refreshBalances();\n              }\n            } else {\n              let tokenContract: { address: string; decimals: number } | null = null;\n              if (!pendingTransaction.isNativeToken && pendingTransaction.tokenSymbol) {\n                const contractInfo = getTokenContract(pendingTransaction.tokenSymbol, pendingTransaction.chainId);\n                if (contractInfo) {\n                  tokenContract = { address: contractInfo.address, decimals: contractInfo.decimals };\n                } else if (pendingTransaction.tokenContractAddress) {\n                  tokenContract = { address: pendingTransaction.tokenContractAddress, decimals: 18 };\n                }\n              }\n\n              const txParams: TransactionParams = {\n                chainId: pendingTransaction.chainId,\n                from: walletAddress,\n                to: pendingTransaction.toAddress,\n                amount: pendingTransaction.amount,\n                tokenSymbol: pendingTransaction.tokenSymbol,\n                tokenContractAddress: tokenContract?.address || pendingTransaction.tokenContractAddress,\n                isNativeToken: pendingTransaction.isNativeToken ?? true,\n                decimals: tokenContract?.decimals,\n              };\n\n              const txResult = await buildTransaction(txParams);\n              \n              if (!txResult) {\n                toast({\n                  title: \"Transaction Build Failed\",\n                  description: \"Could not build transaction. Please try again.\",\n                  variant: \"destructive\",\n                });\n                setPendingTransaction(null);\n                setShowPinModal(false);\n                setPinAction(null);\n                setIsLoading(false);\n                return;\n              }\n\n              if (!txResult.tx) {\n                toast({\n                  title: \"Transaction Error\",\n                  description: \"Could not build transaction data. Please try again.\",\n                  variant: \"destructive\",\n                });\n                setPendingTransaction(null);\n                setShowPinModal(false);\n                setPinAction(null);\n                setIsLoading(false);\n                return;\n              }\n\n              const signedTx = walletMode === \"soft_wallet\"\n                ? await softWallet.signTransaction(txResult.tx)\n                : await hardwareWallet.signTransaction(txResult.tx);\n              \n              if (signedTx) {\n                const result = await broadcastTransaction(signedTx, txResult.chainType, txResult.evmChainId);\n                \n                if (result.success) {\n                  const txId = `tx-${Date.now()}-${Math.random().toString(36).slice(2, 8)}`;\n                  const storedTx: StoredTransaction = {\n                    id: txId,\n                    walletId: pendingTransaction.chainId,\n                    chainId: pendingTransaction.chainId,\n                    type: \"send\",\n                    status: \"confirmed\",\n                    amount: pendingTransaction.amount,\n                    tokenSymbol: pendingTransaction.tokenSymbol || chainSymbol,\n                    toAddress: pendingTransaction.toAddress,\n                    fromAddress: walletAddress,\n                    txHash: result.txHash,\n                    timestamp: new Date().toISOString(),\n                  };\n                  await clientStorage.saveTransaction(storedTx);\n                  \n                  const chainInfo = getChainInfo(pendingTransaction.chainId);\n                  pendingTxTracker.addTransaction({\n                    id: txId,\n                    txHash: result.txHash || '',\n                    chainId: pendingTransaction.chainId,\n                    evmChainId: chainInfo?.evmChainId,\n                    tokenSymbol: pendingTransaction.tokenSymbol || chainSymbol,\n                    amount: pendingTransaction.amount,\n                    toAddress: pendingTransaction.toAddress,\n                    fromAddress: walletAddress,\n                    timestamp: new Date().toISOString(),\n                  });\n                  \n                  toast({\n                    title: \"Transaction Sent\",\n                    description: `Transaction broadcast successfully. Hash: ${result.txHash?.slice(0, 10)}...`,\n                  });\n                  \n                  clearExplorerCache();\n                  refreshBalances();\n                  \n                  const tokenId = pendingTransaction.isNativeToken ? \"native\" : (pendingTransaction.tokenSymbol || \"native\");\n                  setLocation(`/wallet/${pendingTransaction.chainId}/token/${tokenId}`);\n                } else {\n                  toast({\n                    title: \"Broadcast Failed\",\n                    description: result.error || \"Failed to broadcast transaction\",\n                    variant: \"destructive\",\n                  });\n                  refreshBalances();\n                }\n              } else {\n                toast({\n                  title: \"Signing Failed\",\n                  description: \"Could not sign the transaction\",\n                  variant: \"destructive\",\n                });\n                refreshBalances();\n              }\n            }\n            setPendingTransaction(null);\n          } else {\n            toast({\n              title: \"Wallet Unlocked\",\n              description: \"You can now access your wallet.\",\n              duration: 2000,\n            });\n          }\n          \n          setShowPinModal(false);\n          setPinAction(null);\n        } else {\n          setError(\"Incorrect PIN. Please try again.\");\n          setPin(\"\");\n        }\n      } catch (err: any) {\n        setError(err.message || \"Verification failed. Please try again.\");\n        setPin(\"\");\n      } finally {\n        setIsLoading(false);\n      }\n    }\n  }, [pinAction, pin, unlockWallet, deriveWallets, pendingTransaction, setPendingTransaction, setShowPinModal, setPinAction, toast, refreshBalances, walletMode]);\n\n  useEffect(() => {\n    if (showPinModal && (pinAction === \"unlock\" || pinAction === \"sign\") && pin.length === maxLength && !isLoading && pin !== \"\") {\n      const timer = setTimeout(() => {\n        if (pin.length === maxLength) {\n          handleSubmit();\n        }\n      }, 100);\n      return () => clearTimeout(timer);\n    }\n  }, [pin, maxLength, pinAction, handleSubmit, showPinModal, isLoading]);\n\n  const getTitle = () => {\n    if (pinAction === \"sign\") return \"Sign Transaction\";\n    return \"Enter Your PIN\";\n  };\n\n  const getDescription = () => {\n    if (pinAction === \"sign\") return \"Enter your PIN to authorize this transaction\";\n    return \"Enter your PIN to unlock your wallet\";\n  };\n\n  const handleResetDevice = async () => {\n    setIsResetting(true);\n    try {\n      const success = await piWallet.factoryReset();\n      if (success) {\n        await disconnectDevice();\n        setShowPinModal(false);\n        setPinAction(null);\n        toast({\n          title: \"Device Reset\",\n          description: \"Your device has been reset. Reconnect to set up a new wallet.\",\n        });\n      } else {\n        toast({\n          title: \"Reset Not Supported\",\n          description: \"Your device firmware doesn't support remote reset. Please reflash the firmware to reset.\",\n          variant: \"destructive\",\n        });\n      }\n    } catch (err: any) {\n      toast({\n        title: \"Reset Failed\",\n        description: \"Could not reset device. Please reflash the firmware manually.\",\n        variant: \"destructive\",\n      });\n    } finally {\n      setIsResetting(false);\n      setShowResetConfirm(false);\n    }\n  };\n\n  const currentPin = step === \"enter\" ? pin : confirmPin;\n\n  return (\n    <Dialog open={showPinModal} onOpenChange={(open) => {\n      if (!open && !isLoading) {\n        setPin(\"\");\n        setConfirmPin(\"\");\n        setStep(\"enter\");\n        setError(\"\");\n        setShowPinModal(false);\n        setPinAction(null);\n        setPendingTransaction(null);\n      }\n    }}>\n      <DialogContent className=\"sm:max-w-md\" data-testid=\"pin-modal\">\n        <DialogHeader className=\"text-center\">\n          <div className=\"mx-auto mb-4 flex h-16 w-16 items-center justify-center rounded-full bg-primary/10\">\n            {pinAction === \"sign\" ? (\n              <ArrowRight className=\"h-8 w-8 text-primary\" />\n            ) : (\n              <Lock className=\"h-8 w-8 text-primary\" />\n            )}\n          </div>\n          <DialogTitle className=\"text-xl font-semibold\">{getTitle()}</DialogTitle>\n          <DialogDescription className=\"text-muted-foreground\">\n            {getDescription()}\n          </DialogDescription>\n        </DialogHeader>\n\n        {walletMode === \"hard_wallet\" && hardwareState.deviceName && (\n          <div className=\"text-center text-sm text-muted-foreground\">\n            Device: {hardwareState.deviceName}\n          </div>\n        )}\n        {walletMode === \"soft_wallet\" && (\n          <div className=\"text-center text-sm text-muted-foreground\">\n            Soft Wallet\n          </div>\n        )}\n\n        {walletMode === \"hard_wallet\" && (\n          <div className=\"flex justify-center gap-2 py-2\">\n            {[4, 5, 6].map((len) => (\n              <Button\n                key={len}\n                variant={pinLength === len ? \"default\" : \"outline\"}\n                size=\"sm\"\n                onClick={() => {\n                  setPinLength(len);\n                  setPin(\"\");\n                }}\n                data-testid={`button-pin-length-${len}`}\n              >\n                {len} digits\n              </Button>\n            ))}\n          </div>\n        )}\n\n        <div className=\"flex justify-center gap-3 py-6\">\n          {Array.from({ length: maxLength }).map((_, i) => (\n            <div\n              key={i}\n              className={`flex h-12 w-12 items-center justify-center rounded-full border-2 transition-all ${\n                i < currentPin.length\n                  ? \"border-primary bg-primary\"\n                  : \"border-muted-foreground/30 bg-muted/30\"\n              }`}\n              data-testid={`pin-dot-${i}`}\n            >\n              {i < currentPin.length && (\n                <div className=\"h-3 w-3 rounded-full bg-primary-foreground\" />\n              )}\n            </div>\n          ))}\n        </div>\n\n        {error && (\n          <p className=\"text-center text-sm text-destructive\" data-testid=\"pin-error\">\n            {error}\n          </p>\n        )}\n\n        <div className=\"grid grid-cols-3 gap-3 px-4\">\n          {[1, 2, 3, 4, 5, 6, 7, 8, 9].map((num) => (\n            <Button\n              key={num}\n              variant=\"outline\"\n              className=\"h-14 text-xl font-semibold\"\n              onClick={() => handleNumberClick(num.toString())}\n              disabled={isLoading}\n              data-testid={`button-pin-${num}`}\n            >\n              {num}\n            </Button>\n          ))}\n          <Button\n            variant=\"ghost\"\n            className=\"h-14\"\n            onClick={handleClear}\n            disabled={isLoading}\n            data-testid=\"button-pin-clear\"\n          >\n            <X className=\"h-5 w-5\" />\n          </Button>\n          <Button\n            variant=\"outline\"\n            className=\"h-14 text-xl font-semibold\"\n            onClick={() => handleNumberClick(\"0\")}\n            disabled={isLoading}\n            data-testid=\"button-pin-0\"\n          >\n            0\n          </Button>\n          <Button\n            variant=\"ghost\"\n            className=\"h-14\"\n            onClick={handleDelete}\n            disabled={isLoading}\n            data-testid=\"button-pin-delete\"\n          >\n            <Delete className=\"h-5 w-5\" />\n          </Button>\n        </div>\n\n        <div className=\"mt-4 flex items-center justify-center gap-2 text-xs text-muted-foreground\">\n          <Shield className=\"h-3 w-3\" />\n          <span>Secured by hardware encryption</span>\n        </div>\n\n        {walletMode === \"hard_wallet\" && hardwareState.type === \"raspberry_pi\" && (\n          <div className=\"mt-2 text-center\">\n            <p className=\"text-xs text-muted-foreground mb-2\">\n              Existing wallet detected on device\n            </p>\n            <Button\n              variant=\"ghost\"\n              size=\"sm\"\n              onClick={() => setShowResetConfirm(true)}\n              disabled={isLoading || isResetting}\n              className=\"text-destructive\"\n              data-testid=\"button-reset-device\"\n            >\n              <RotateCcw className=\"h-3 w-3 mr-1\" />\n              Forgot PIN? Reset Device\n            </Button>\n          </div>\n        )}\n      </DialogContent>\n\n      <AlertDialog open={showResetConfirm} onOpenChange={setShowResetConfirm}>\n        <AlertDialogContent data-testid=\"reset-confirm-dialog\">\n          <AlertDialogHeader>\n            <AlertDialogTitle className=\"flex items-center gap-2\">\n              <AlertTriangle className=\"h-5 w-5 text-destructive\" />\n              Reset Device?\n            </AlertDialogTitle>\n            <AlertDialogDescription>\n              This will attempt to erase all wallet data from your device. Your funds will be lost forever unless you have backed up your recovery phrase. This action cannot be undone.\n            </AlertDialogDescription>\n          </AlertDialogHeader>\n          <AlertDialogFooter>\n            <AlertDialogCancel disabled={isResetting} data-testid=\"button-reset-cancel\">\n              Cancel\n            </AlertDialogCancel>\n            <AlertDialogAction\n              onClick={handleResetDevice}\n              disabled={isResetting}\n              className=\"bg-destructive text-destructive-foreground\"\n              data-testid=\"button-reset-confirm\"\n            >\n              {isResetting ? \"Resetting...\" : \"Yes, Reset Device\"}\n            </AlertDialogAction>\n          </AlertDialogFooter>\n        </AlertDialogContent>\n      </AlertDialog>\n    </Dialog>\n  );\n}\n","path":null,"size_bytes":22092,"size_tokens":null},"client/src/components/theme-toggle.tsx":{"content":"import { Moon, Sun } from \"lucide-react\";\nimport { Button } from \"@/components/ui/button\";\nimport { useTheme } from \"@/lib/theme-context\";\n\nexport function ThemeToggle() {\n  const { theme, toggleTheme } = useTheme();\n\n  return (\n    <Button\n      size=\"icon\"\n      variant=\"ghost\"\n      onClick={toggleTheme}\n      data-testid=\"button-theme-toggle\"\n      aria-label={`Switch to ${theme === \"light\" ? \"dark\" : \"light\"} mode`}\n    >\n      {theme === \"light\" ? (\n        <Moon className=\"h-5 w-5\" />\n      ) : (\n        <Sun className=\"h-5 w-5\" />\n      )}\n    </Button>\n  );\n}\n","path":null,"size_bytes":575,"size_tokens":null},"server/db.ts":{"content":"import { drizzle } from \"drizzle-orm/node-postgres\";\nimport pg from \"pg\";\nimport * as schema from \"@shared/schema\";\n\nconst { Pool } = pg;\n\nif (!process.env.DATABASE_URL) {\n  throw new Error(\n    \"DATABASE_URL must be set. Did you forget to provision a database?\",\n  );\n}\n\nexport const pool = new Pool({ connectionString: process.env.DATABASE_URL });\nexport const db = drizzle(pool, { schema });\n","path":null,"size_bytes":395,"size_tokens":null},"client/src/components/ui/resizable.tsx":{"content":"\"use client\"\n\nimport { GripVertical } from \"lucide-react\"\nimport * as ResizablePrimitive from \"react-resizable-panels\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst ResizablePanelGroup = ({\n  className,\n  ...props\n}: React.ComponentProps<typeof ResizablePrimitive.PanelGroup>) => (\n  <ResizablePrimitive.PanelGroup\n    className={cn(\n      \"flex h-full w-full data-[panel-group-direction=vertical]:flex-col\",\n      className\n    )}\n    {...props}\n  />\n)\n\nconst ResizablePanel = ResizablePrimitive.Panel\n\nconst ResizableHandle = ({\n  withHandle,\n  className,\n  ...props\n}: React.ComponentProps<typeof ResizablePrimitive.PanelResizeHandle> & {\n  withHandle?: boolean\n}) => (\n  <ResizablePrimitive.PanelResizeHandle\n    className={cn(\n      \"relative flex w-px items-center justify-center bg-border after:absolute after:inset-y-0 after:left-1/2 after:w-1 after:-translate-x-1/2 focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring focus-visible:ring-offset-1 data-[panel-group-direction=vertical]:h-px data-[panel-group-direction=vertical]:w-full data-[panel-group-direction=vertical]:after:left-0 data-[panel-group-direction=vertical]:after:h-1 data-[panel-group-direction=vertical]:after:w-full data-[panel-group-direction=vertical]:after:-translate-y-1/2 data-[panel-group-direction=vertical]:after:translate-x-0 [&[data-panel-group-direction=vertical]>div]:rotate-90\",\n      className\n    )}\n    {...props}\n  >\n    {withHandle && (\n      <div className=\"z-10 flex h-4 w-3 items-center justify-center rounded-sm border bg-border\">\n        <GripVertical className=\"h-2.5 w-2.5\" />\n      </div>\n    )}\n  </ResizablePrimitive.PanelResizeHandle>\n)\n\nexport { ResizablePanelGroup, ResizablePanel, ResizableHandle }\n","path":null,"size_bytes":1723,"size_tokens":null},"script/build.ts":{"content":"import { build as esbuild } from \"esbuild\";\nimport { build as viteBuild } from \"vite\";\nimport { rm, readFile } from \"fs/promises\";\n\n// server deps to bundle to reduce openat(2) syscalls\n// which helps cold start times\nconst allowlist = [\n  \"@google/generative-ai\",\n  \"axios\",\n  \"connect-pg-simple\",\n  \"cors\",\n  \"date-fns\",\n  \"drizzle-orm\",\n  \"drizzle-zod\",\n  \"express\",\n  \"express-rate-limit\",\n  \"express-session\",\n  \"jsonwebtoken\",\n  \"memorystore\",\n  \"multer\",\n  \"nanoid\",\n  \"nodemailer\",\n  \"openai\",\n  \"passport\",\n  \"passport-local\",\n  \"pg\",\n  \"stripe\",\n  \"uuid\",\n  \"ws\",\n  \"xlsx\",\n  \"zod\",\n  \"zod-validation-error\",\n];\n\nasync function buildAll() {\n  await rm(\"dist\", { recursive: true, force: true });\n\n  console.log(\"building client...\");\n  await viteBuild();\n\n  console.log(\"building server...\");\n  const pkg = JSON.parse(await readFile(\"package.json\", \"utf-8\"));\n  const allDeps = [\n    ...Object.keys(pkg.dependencies || {}),\n    ...Object.keys(pkg.devDependencies || {}),\n  ];\n  const externals = allDeps.filter((dep) => !allowlist.includes(dep));\n\n  await esbuild({\n    entryPoints: [\"server/index.ts\"],\n    platform: \"node\",\n    bundle: true,\n    format: \"cjs\",\n    outfile: \"dist/index.cjs\",\n    define: {\n      \"process.env.NODE_ENV\": '\"production\"',\n    },\n    minify: true,\n    external: externals,\n    logLevel: \"info\",\n  });\n}\n\nbuildAll().catch((err) => {\n  console.error(err);\n  process.exit(1);\n});\n","path":null,"size_bytes":1417,"size_tokens":null},"shared/routes.ts":{"content":"import { z } from 'zod';\nimport { insertLeadSchema, leads } from './schema';\n\nexport const errorSchemas = {\n  validation: z.object({\n    message: z.string(),\n    field: z.string().optional(),\n  }),\n  internal: z.object({\n    message: z.string(),\n  }),\n};\n\nexport const api = {\n  leads: {\n    create: {\n      method: 'POST' as const,\n      path: '/api/leads',\n      input: insertLeadSchema,\n      responses: {\n        201: z.custom<typeof leads.$inferSelect>(),\n        400: errorSchemas.validation,\n      },\n    },\n  },\n};\n\nexport function buildUrl(path: string, params?: Record<string, string | number>): string {\n  let url = path;\n  if (params) {\n    Object.entries(params).forEach(([key, value]) => {\n      if (url.includes(`:${key}`)) {\n        url = url.replace(`:${key}`, String(value));\n      }\n    });\n  }\n  return url;\n}\n","path":null,"size_bytes":830,"size_tokens":null},"client/src/main.tsx":{"content":"import { createRoot } from \"react-dom/client\";\nimport App from \"./App\";\nimport \"./index.css\";\n\ncreateRoot(document.getElementById(\"root\")!).render(<App />);\n","path":null,"size_bytes":157,"size_tokens":null},"client/src/lib/mobile-usb-serial.ts":{"content":"import { Capacitor, registerPlugin } from \"@capacitor/core\";\n\ninterface UsbDevice {\n  deviceId: number;\n  vendorId: number;\n  productId: number;\n  deviceName: string;\n  productName?: string;\n  manufacturerName?: string;\n}\n\ninterface UsbSerialPlugin {\n  getDevices(): Promise<{ success: boolean; devices: Record<string, UsbDevice>; count: number }>;\n  connect(options: { vendorId?: number; productId?: number }): Promise<{ success: boolean; deviceName?: string; error?: string }>;\n  disconnect(): Promise<{ success: boolean }>;\n  write(options: { data: string }): Promise<{ success: boolean; bytesWritten?: number; error?: string }>;\n  read(options?: { timeout?: number }): Promise<{ success: boolean; data?: string; bytesRead?: number; error?: string }>;\n  isConnected(): Promise<{ connected: boolean }>;\n  addListener(event: \"usbData\", callback: (data: { data: string }) => void): Promise<{ remove: () => void }>;\n  addListener(event: \"usbDisconnected\", callback: () => void): Promise<{ remove: () => void }>;\n}\n\nconst UsbSerial = registerPlugin<UsbSerialPlugin>(\"UsbSerial\");\n\nexport function isMobileWithUsbSupport(): boolean {\n  return Capacitor.isNativePlatform() && Capacitor.getPlatform() === \"android\";\n}\n\nexport class MobileUsbSerialService {\n  private connected = false;\n  private readBuffer = \"\";\n  private responseResolver: ((value: any) => void) | null = null;\n  private responseTimeout: ReturnType<typeof setTimeout> | null = null;\n  private dataListener: { remove: () => void } | null = null;\n  private cachedSeed: string | null = null;\n  private currentPin: string | null = null;\n\n  async isAvailable(): Promise<boolean> {\n    if (!isMobileWithUsbSupport()) {\n      return false;\n    }\n    try {\n      const result = await UsbSerial.getDevices();\n      return result.success && result.count > 0;\n    } catch {\n      return false;\n    }\n  }\n\n  async connect(): Promise<boolean> {\n    if (!isMobileWithUsbSupport()) {\n      throw new Error(\"Mobile USB serial not available on this platform\");\n    }\n\n    try {\n      const result = await UsbSerial.connect({ vendorId: 11914 });\n      \n      if (!result.success) {\n        throw new Error(result.error || \"Failed to connect\");\n      }\n\n      this.connected = true;\n      \n      this.dataListener = await UsbSerial.addListener(\"usbData\", (event) => {\n        this.handleData(event.data);\n      });\n\n      return true;\n    } catch (error: any) {\n      this.connected = false;\n      throw error;\n    }\n  }\n\n  private handleData(data: string) {\n    this.readBuffer += data;\n    \n    let newlineIndex;\n    while ((newlineIndex = this.readBuffer.indexOf(\"\\n\")) !== -1) {\n      const line = this.readBuffer.slice(0, newlineIndex).trim();\n      this.readBuffer = this.readBuffer.slice(newlineIndex + 1);\n      \n      if (line && line.startsWith(\"{\") && this.responseResolver) {\n        try {\n          const response = JSON.parse(line);\n          if (this.responseTimeout) {\n            clearTimeout(this.responseTimeout);\n            this.responseTimeout = null;\n          }\n          this.responseResolver(response);\n          this.responseResolver = null;\n        } catch {}\n      }\n    }\n  }\n\n  async disconnect(): Promise<void> {\n    if (this.dataListener) {\n      this.dataListener.remove();\n      this.dataListener = null;\n    }\n    \n    try {\n      await UsbSerial.disconnect();\n    } catch {}\n    \n    this.connected = false;\n    this.cachedSeed = null;\n    this.readBuffer = \"\";\n  }\n\n  async sendCommand(action: string, params?: Record<string, any>): Promise<any> {\n    if (!this.connected) {\n      throw new Error(\"Not connected to Pico wallet\");\n    }\n\n    const message = JSON.stringify({ action, ...params }) + \"\\r\\n\";\n    \n    const writeResult = await UsbSerial.write({ data: message });\n    if (!writeResult.success) {\n      throw new Error(writeResult.error || \"Write failed\");\n    }\n\n    return new Promise((resolve, reject) => {\n      this.responseResolver = resolve;\n      this.responseTimeout = setTimeout(() => {\n        this.responseResolver = null;\n        reject(new Error(\"Command timed out\"));\n      }, 10000);\n    });\n  }\n\n  async ping(): Promise<boolean> {\n    try {\n      const response = await this.sendCommand(\"ping\");\n      return response.pong === true;\n    } catch {\n      return false;\n    }\n  }\n\n  async getStatus(): Promise<{ initialized: boolean; locked: boolean; has_seed: boolean; device_name: string } | null> {\n    try {\n      const response = await this.sendCommand(\"status\");\n      return {\n        initialized: response.has_wallet === true,\n        locked: response.unlocked !== true,\n        has_seed: response.has_wallet === true,\n        device_name: \"Pico Hardware Wallet (USB)\",\n      };\n    } catch {\n      return null;\n    }\n  }\n\n  async unlock(pin: string): Promise<boolean> {\n    const response = await this.sendCommand(\"unlock\", { pin });\n    if (response.error) {\n      throw new Error(response.error);\n    }\n    \n    if (response.success === true || response.unlocked === true) {\n      this.currentPin = pin;\n      // Cache the seed for non-EVM signing\n      if (!this.cachedSeed) {\n        try {\n          const seedResponse = await this.sendCommand(\"get_seed\", { pin });\n          if (seedResponse.seed) {\n            this.cachedSeed = seedResponse.seed;\n          }\n        } catch (e) {\n          console.warn(\"[MobileUsbSerial] Failed to cache seed:\", e);\n        }\n      }\n      return true;\n    }\n    return false;\n  }\n  \n  getSeedPhrase(): string | null {\n    return this.cachedSeed;\n  }\n  \n  async ensureSeedCached(): Promise<string | null> {\n    if (this.cachedSeed) {\n      return this.cachedSeed;\n    }\n    \n    // Use stored PIN from unlock\n    if (!this.currentPin) {\n      console.warn(\"[MobileUsbSerial] Cannot fetch seed: no PIN available (wallet not unlocked?)\");\n      return null;\n    }\n    \n    try {\n      const response = await this.sendCommand(\"get_seed\", { pin: this.currentPin });\n      if (response.seed) {\n        this.cachedSeed = response.seed;\n        return this.cachedSeed;\n      }\n    } catch (e) {\n      console.warn(\"[MobileUsbSerial] Failed to retrieve seed:\", e);\n    }\n    return null;\n  }\n\n  async setupWallet(pin: string, seedPhrase: string): Promise<boolean> {\n    const response = await this.sendCommand(\"setup\", { pin, seed: seedPhrase });\n    if (response.error) {\n      throw new Error(response.error);\n    }\n    return response.success === true;\n  }\n\n  async getAddress(chainId: number): Promise<string | null> {\n    try {\n      const response = await this.sendCommand(\"get_address\", { chain_id: chainId });\n      if (response.error) {\n        throw new Error(response.error);\n      }\n      return response.address || null;\n    } catch {\n      return null;\n    }\n  }\n\n  async getAddresses(chainIds: number[]): Promise<{ path: string; address: string; chainId: number }[]> {\n    try {\n      const response = await this.sendCommand(\"get_addresses\", { chain_ids: chainIds });\n      if (response.error) {\n        throw new Error(response.error);\n      }\n      return response.addresses || [];\n    } catch {\n      return [];\n    }\n  }\n\n  async signTransaction(tx: {\n    to: string;\n    value: string;\n    data?: string;\n    nonce: number;\n    gasLimit: string;\n    gasPrice?: string;\n    maxFeePerGas?: string;\n    maxPriorityFeePerGas?: string;\n    chainId: number;\n  }): Promise<string | null> {\n    try {\n      const response = await this.sendCommand(\"sign_transaction\", { tx });\n      if (response.error) {\n        throw new Error(response.error);\n      }\n      return response.signed_tx || null;\n    } catch {\n      return null;\n    }\n  }\n\n  async signMessage(message: string): Promise<string | null> {\n    try {\n      const response = await this.sendCommand(\"sign_message\", { message });\n      if (response.error) {\n        throw new Error(response.error);\n      }\n      return response.signature || null;\n    } catch {\n      return null;\n    }\n  }\n\n  async lock(): Promise<boolean> {\n    try {\n      const response = await this.sendCommand(\"lock\");\n      // Clear cached seed and PIN on lock for security\n      this.cachedSeed = null;\n      this.currentPin = null;\n      return response.success === true || response.locked === true;\n    } catch {\n      this.cachedSeed = null;\n      this.currentPin = null;\n      return false;\n    }\n  }\n\n  async saveChains(chains: any[]): Promise<boolean> {\n    try {\n      const response = await this.sendCommand(\"save_chains\", { chains });\n      return response.success === true;\n    } catch {\n      return false;\n    }\n  }\n\n  async getChains(): Promise<any[]> {\n    try {\n      const response = await this.sendCommand(\"get_chains\");\n      return response.chains || [];\n    } catch {\n      return [];\n    }\n  }\n\n  isConnectedSync(): boolean {\n    return this.connected;\n  }\n}\n\nexport const mobileUsbSerial = new MobileUsbSerialService();\n","path":null,"size_bytes":8836,"size_tokens":null},"client/src/lib/crypto-utils.ts":{"content":"import { SUPPORTED_CHAINS, type WalletAddress, type Chain } from \"@shared/schema\";\n\n// Generate a deterministic demo address for each chain\n// In a real hardware wallet, these would come from the device\nfunction generateDemoAddress(chainId: string): string {\n  const addresses: Record<string, string> = {\n    btc: \"bc1qxy2kgdygjrsqtzq2n0yrf2493p83kkfjhx0wlh\",\n    eth: \"0x71C7656EC7ab88b098defB751B7401B5f6d8976F\",\n    ltc: \"ltc1qhfj5yq8czgxu9pmfv5v7qz5fxfze5j5qx5zxxv\",\n    bch: \"bitcoincash:qpm2qsznhks23z7629mms6s4cwef74vcwvy22gdx6a\",\n    doge: \"D7Y55FbDpxWxmKhz5j6rNQHXgvWGcwFPGk\",\n    xrp: \"rN7n3476E3y6Jxm5TYjBqCzVLtqDf5Nmea\",\n  };\n  \n  return addresses[chainId] || \"Address not available\";\n}\n\n// Get all enabled chains\nexport function getEnabledChains(): Chain[] {\n  return SUPPORTED_CHAINS.filter(chain => chain.enabled);\n}\n\n// Get wallet addresses for all enabled chains\nexport function getWalletAddresses(): WalletAddress[] {\n  const enabledChains = getEnabledChains();\n  \n  return enabledChains.map(chain => ({\n    chainId: chain.id,\n    address: generateDemoAddress(chain.id),\n    chain: chain,\n  }));\n}\n\n// Format address for display (truncate middle)\nexport function formatAddress(address: string, startChars = 8, endChars = 6): string {\n  if (address.length <= startChars + endChars) {\n    return address;\n  }\n  return `${address.slice(0, startChars)}...${address.slice(-endChars)}`;\n}\n\n// Copy address to clipboard\nexport async function copyToClipboard(text: string): Promise<boolean> {\n  try {\n    await navigator.clipboard.writeText(text);\n    return true;\n  } catch {\n    return false;\n  }\n}\n","path":null,"size_bytes":1611,"size_tokens":null},"client/src/lib/soft-wallet.ts":{"content":"import { clientStorage } from \"./client-storage\";\nimport { deriveAllAddresses, type DerivedAddress } from \"./multi-chain-address\";\nimport { Mnemonic, HDNodeWallet, type TransactionRequest } from \"ethers\";\nimport { \n  signNonEvmTransaction, \n  type NonEvmTransactionParams,\n  type SignedTransaction \n} from \"./non-evm-chains\";\n\nexport type SoftWalletStatus = \"disconnected\" | \"locked\" | \"unlocked\";\n\nexport interface SoftWalletState {\n  status: SoftWalletStatus;\n  error: string | null;\n  hasWallet: boolean;\n}\n\ntype StateListener = (state: SoftWalletState) => void;\n\n// Crypto constants\nconst PBKDF2_ITERATIONS = 100000;\nconst SALT_LENGTH = 16;\nconst IV_LENGTH = 12;\n\nclass SoftWallet {\n  private state: SoftWalletState = {\n    status: \"disconnected\",\n    error: null,\n    hasWallet: false,\n  };\n  \n  private listeners: Set<StateListener> = new Set();\n  private decryptedSeed: string | null = null;\n  private sessionTimeout: ReturnType<typeof setTimeout> | null = null;\n  private readonly SESSION_TIMEOUT_MS = 5 * 60 * 1000; // 5 minutes\n\n  getState(): SoftWalletState {\n    return { ...this.state };\n  }\n\n  subscribe(listener: StateListener): () => void {\n    this.listeners.add(listener);\n    return () => this.listeners.delete(listener);\n  }\n\n  private notifyListeners(): void {\n    const currentState = this.getState();\n    this.listeners.forEach(listener => listener(currentState));\n  }\n\n  private setState(updates: Partial<SoftWalletState>): void {\n    this.state = { ...this.state, ...updates };\n    this.notifyListeners();\n  }\n\n  // Derive an AES-GCM key from PIN using PBKDF2\n  private async deriveKey(pin: string, salt: Uint8Array): Promise<CryptoKey> {\n    const encoder = new TextEncoder();\n    const pinBytes = encoder.encode(pin);\n    \n    // Import PIN as key material\n    const keyMaterial = await crypto.subtle.importKey(\n      \"raw\",\n      pinBytes,\n      \"PBKDF2\",\n      false,\n      [\"deriveKey\"]\n    );\n    \n    // Derive AES-GCM key using PBKDF2\n    return await crypto.subtle.deriveKey(\n      {\n        name: \"PBKDF2\",\n        salt: salt,\n        iterations: PBKDF2_ITERATIONS,\n        hash: \"SHA-256\",\n      },\n      keyMaterial,\n      { name: \"AES-GCM\", length: 256 },\n      false,\n      [\"encrypt\", \"decrypt\"]\n    );\n  }\n\n  // Encrypt seed phrase with PIN using AES-GCM\n  private async encryptSeed(seed: string, pin: string): Promise<string> {\n    const encoder = new TextEncoder();\n    const seedBytes = encoder.encode(seed);\n    \n    // Generate random salt and IV\n    const salt = crypto.getRandomValues(new Uint8Array(SALT_LENGTH));\n    const iv = crypto.getRandomValues(new Uint8Array(IV_LENGTH));\n    \n    // Derive key\n    const key = await this.deriveKey(pin, salt);\n    \n    // Encrypt\n    const ciphertext = await crypto.subtle.encrypt(\n      { name: \"AES-GCM\", iv: iv },\n      key,\n      seedBytes\n    );\n    \n    // Combine salt + iv + ciphertext and encode as base64\n    const combined = new Uint8Array(salt.length + iv.length + ciphertext.byteLength);\n    combined.set(salt, 0);\n    combined.set(iv, salt.length);\n    combined.set(new Uint8Array(ciphertext), salt.length + iv.length);\n    \n    return btoa(String.fromCharCode(...combined));\n  }\n\n  // Decrypt seed phrase with PIN using AES-GCM\n  private async decryptSeed(encryptedData: string, pin: string): Promise<string> {\n    // Decode base64\n    const combined = Uint8Array.from(atob(encryptedData), c => c.charCodeAt(0));\n    \n    // Extract salt, iv, ciphertext\n    const salt = combined.slice(0, SALT_LENGTH);\n    const iv = combined.slice(SALT_LENGTH, SALT_LENGTH + IV_LENGTH);\n    const ciphertext = combined.slice(SALT_LENGTH + IV_LENGTH);\n    \n    // Derive key\n    const key = await this.deriveKey(pin, salt);\n    \n    // Decrypt\n    const decrypted = await crypto.subtle.decrypt(\n      { name: \"AES-GCM\", iv: iv },\n      key,\n      ciphertext\n    );\n    \n    const decoder = new TextDecoder();\n    return decoder.decode(decrypted);\n  }\n\n  // Create a salted hash of the PIN for verification using PBKDF2\n  private async hashPin(pin: string, salt?: Uint8Array): Promise<{ hash: string; salt: string }> {\n    const pinSalt = salt || crypto.getRandomValues(new Uint8Array(SALT_LENGTH));\n    const encoder = new TextEncoder();\n    const pinBytes = encoder.encode(pin);\n    \n    // Import PIN as key material\n    const keyMaterial = await crypto.subtle.importKey(\n      \"raw\",\n      pinBytes,\n      \"PBKDF2\",\n      false,\n      [\"deriveBits\"]\n    );\n    \n    // Derive bits for hash\n    const hashBits = await crypto.subtle.deriveBits(\n      {\n        name: \"PBKDF2\",\n        salt: pinSalt,\n        iterations: PBKDF2_ITERATIONS,\n        hash: \"SHA-256\",\n      },\n      keyMaterial,\n      256\n    );\n    \n    const hashArray = new Uint8Array(hashBits);\n    return {\n      hash: btoa(String.fromCharCode(...hashArray)),\n      salt: btoa(String.fromCharCode(...pinSalt)),\n    };\n  }\n\n  // Verify PIN against stored hash\n  private async verifyPin(pin: string, storedHash: string, storedSalt: string): Promise<boolean> {\n    const salt = Uint8Array.from(atob(storedSalt), c => c.charCodeAt(0));\n    const { hash } = await this.hashPin(pin, salt);\n    return hash === storedHash;\n  }\n\n  // Check if wallet is set up (has encrypted seed in storage)\n  async checkWalletExists(): Promise<boolean> {\n    const hasWallet = await clientStorage.hasEncryptedSeed();\n    this.setState({ hasWallet });\n    return hasWallet;\n  }\n\n  // Set up a new soft wallet with seed phrase and PIN\n  async setup(seedPhrase: string, pin: string): Promise<boolean> {\n    try {\n      const words = seedPhrase.trim().toLowerCase().split(/\\s+/);\n      if (words.length !== 12 && words.length !== 24) {\n        this.setState({ error: \"Seed phrase must be 12 or 24 words\" });\n        return false;\n      }\n\n      // Encrypt seed with proper AES-GCM\n      const normalizedSeed = words.join(\" \");\n      const encryptedSeed = await this.encryptSeed(normalizedSeed, pin);\n      \n      // Create salted PIN hash for verification\n      const { hash: pinHash, salt: pinSalt } = await this.hashPin(pin);\n      \n      // Store with salt\n      await clientStorage.saveEncryptedSeed(encryptedSeed, pinHash, pinSalt);\n      await clientStorage.setSoftWalletSetup(true);\n      \n      // Keep decrypted seed in memory for this session\n      this.decryptedSeed = normalizedSeed;\n      \n      this.setState({ \n        status: \"unlocked\", \n        hasWallet: true, \n        error: null \n      });\n      \n      this.startSessionTimeout();\n      return true;\n    } catch (err: any) {\n      this.setState({ error: err.message || \"Failed to set up wallet\" });\n      return false;\n    }\n  }\n\n  // Unlock wallet with PIN\n  async unlock(pin: string): Promise<boolean> {\n    try {\n      const storedPinHash = await clientStorage.getPinHash();\n      const storedPinSalt = await clientStorage.getPinSalt();\n      const encryptedSeed = await clientStorage.getEncryptedSeed();\n      \n      if (!storedPinHash || !storedPinSalt || !encryptedSeed) {\n        this.setState({ error: \"No wallet found. Please set up first.\" });\n        return false;\n      }\n\n      // Verify PIN using salted hash\n      const isValid = await this.verifyPin(pin, storedPinHash, storedPinSalt);\n      if (!isValid) {\n        this.setState({ error: \"Incorrect PIN\" });\n        return false;\n      }\n\n      // Decrypt seed using AES-GCM\n      try {\n        this.decryptedSeed = await this.decryptSeed(encryptedSeed, pin);\n      } catch {\n        this.setState({ error: \"Failed to decrypt wallet. Incorrect PIN or corrupted data.\" });\n        return false;\n      }\n      \n      this.setState({ status: \"unlocked\", error: null });\n      this.startSessionTimeout();\n      return true;\n    } catch (err: any) {\n      this.setState({ error: err.message || \"Failed to unlock wallet\" });\n      return false;\n    }\n  }\n\n  // Lock wallet\n  lock(): void {\n    this.decryptedSeed = null;\n    this.clearSessionTimeout();\n    this.setState({ status: \"locked\", error: null });\n  }\n\n  // Get decrypted seed phrase (only available when unlocked)\n  getSeedPhrase(): string | null {\n    if (this.state.status !== \"unlocked\") {\n      return null;\n    }\n    return this.decryptedSeed;\n  }\n\n  // Derive addresses for all chains\n  async deriveAddresses(chainSymbols: string[], accountIndex: number = 0): Promise<DerivedAddress[]> {\n    if (this.state.status !== \"unlocked\" || !this.decryptedSeed) {\n      throw new Error(\"Wallet must be unlocked to derive addresses\");\n    }\n    \n    return await deriveAllAddresses(this.decryptedSeed, chainSymbols, accountIndex);\n  }\n\n  // Reset/disconnect - clears all stored data\n  async reset(): Promise<void> {\n    this.decryptedSeed = null;\n    this.clearSessionTimeout();\n    await clientStorage.clearEncryptedSeed();\n    await clientStorage.clearSoftWallet();\n    this.setState({ \n      status: \"disconnected\", \n      hasWallet: false, \n      error: null \n    });\n  }\n\n  // Session timeout management\n  private startSessionTimeout(): void {\n    this.clearSessionTimeout();\n    this.sessionTimeout = setTimeout(() => {\n      this.lock();\n    }, this.SESSION_TIMEOUT_MS);\n  }\n\n  private clearSessionTimeout(): void {\n    if (this.sessionTimeout) {\n      clearTimeout(this.sessionTimeout);\n      this.sessionTimeout = null;\n    }\n  }\n\n  resetSessionTimeout(): void {\n    if (this.state.status === \"unlocked\") {\n      this.startSessionTimeout();\n    }\n  }\n\n  isUnlocked(): boolean {\n    return this.state.status === \"unlocked\";\n  }\n\n  // Verify a seed phrase matches the stored wallet's seed\n  async verifySeedPhrase(inputSeedPhrase: string): Promise<boolean> {\n    if (this.state.status !== \"unlocked\" || !this.decryptedSeed) {\n      return false;\n    }\n    \n    // Normalize the input: trim, lowercase, collapse whitespace\n    const inputWords = inputSeedPhrase.trim().toLowerCase().split(/\\s+/);\n    const storedWords = this.decryptedSeed.split(\" \");\n    \n    // Must have same number of words\n    if (inputWords.length !== storedWords.length) {\n      return false;\n    }\n    \n    // Compare each word\n    for (let i = 0; i < inputWords.length; i++) {\n      if (inputWords[i] !== storedWords[i]) {\n        return false;\n      }\n    }\n    \n    return true;\n  }\n\n  // Get the word count of the stored seed (12 or 24)\n  getSeedWordCount(): number | null {\n    if (this.state.status !== \"unlocked\" || !this.decryptedSeed) {\n      return null;\n    }\n    return this.decryptedSeed.split(\" \").length;\n  }\n\n  async signTransaction(unsignedTx: TransactionRequest): Promise<string | null> {\n    if (this.state.status !== \"unlocked\" || !this.decryptedSeed) {\n      this.setState({ error: \"Wallet must be unlocked to sign transactions\" });\n      return null;\n    }\n\n    try {\n      const mnemonic = Mnemonic.fromPhrase(this.decryptedSeed);\n      const hdNode = HDNodeWallet.fromMnemonic(mnemonic, \"m/44'/60'/0'/0/0\");\n      const signedTx = await hdNode.signTransaction(unsignedTx);\n      return signedTx;\n    } catch (error: any) {\n      this.setState({ error: error.message || \"Failed to sign transaction\" });\n      return null;\n    }\n  }\n\n  async signNonEvmTransaction(params: NonEvmTransactionParams): Promise<SignedTransaction | null> {\n    if (this.state.status !== \"unlocked\" || !this.decryptedSeed) {\n      this.setState({ error: \"Wallet must be unlocked to sign transactions\" });\n      return null;\n    }\n\n    try {\n      const result = await signNonEvmTransaction(params, this.decryptedSeed);\n      if (!result) {\n        this.setState({ error: \"Failed to sign non-EVM transaction\" });\n        return null;\n      }\n      return result;\n    } catch (error: any) {\n      this.setState({ error: error.message || \"Failed to sign non-EVM transaction\" });\n      return null;\n    }\n  }\n\n  async getAddress(chainId?: number): Promise<string | null> {\n    if (this.state.status !== \"unlocked\" || !this.decryptedSeed) {\n      return null;\n    }\n\n    try {\n      const mnemonic = Mnemonic.fromPhrase(this.decryptedSeed);\n      const hdNode = HDNodeWallet.fromMnemonic(mnemonic, \"m/44'/60'/0'/0/0\");\n      return hdNode.address;\n    } catch {\n      return null;\n    }\n  }\n\n  // Encrypt a seed phrase for a new wallet group (independent seed)\n  async encryptSeedForWalletGroup(\n    seedPhrase: string,\n    pin: string,\n    walletGroupId: string\n  ): Promise<{ encryptedSeed: string; pinHash: string; pinSalt: string }> {\n    const words = seedPhrase.trim().toLowerCase().split(/\\s+/);\n    if (words.length !== 12 && words.length !== 24) {\n      throw new Error(\"Seed phrase must be 12 or 24 words\");\n    }\n\n    const normalizedSeed = words.join(\" \");\n    const encryptedSeed = await this.encryptSeed(normalizedSeed, pin);\n    const { hash: pinHash, salt: pinSalt } = await this.hashPin(pin);\n\n    return { encryptedSeed, pinHash, pinSalt };\n  }\n\n  // Decrypt a seed for a specific wallet group\n  async decryptWalletGroupSeed(encryptedSeed: string, pin: string): Promise<string> {\n    return await this.decryptSeed(encryptedSeed, pin);\n  }\n\n  // Verify PIN for a wallet group\n  async verifyWalletGroupPin(pin: string, storedHash: string, storedSalt: string): Promise<boolean> {\n    return await this.verifyPin(pin, storedHash, storedSalt);\n  }\n\n  // Generate a new random seed phrase\n  generateNewSeedPhrase(): string {\n    const entropy = crypto.getRandomValues(new Uint8Array(16)); // 128 bits = 12 words\n    return Mnemonic.entropyToPhrase(entropy);\n  }\n}\n\nexport const softWallet = new SoftWallet();\n","path":null,"size_bytes":13416,"size_tokens":null},"client/src/components/ui/avatar.tsx":{"content":"\"use client\"\n\nimport * as React from \"react\"\nimport * as AvatarPrimitive from \"@radix-ui/react-avatar\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst Avatar = React.forwardRef<\n  React.ElementRef<typeof AvatarPrimitive.Root>,\n  React.ComponentPropsWithoutRef<typeof AvatarPrimitive.Root>\n>(({ className, ...props }, ref) => (\n  <AvatarPrimitive.Root\n    ref={ref}\n    className={cn(`\n      after:content-[''] after:block after:absolute after:inset-0 after:rounded-full after:pointer-events-none after:border after:border-black/10 dark:after:border-white/10\n      relative flex h-10 w-10 shrink-0 overflow-hidden rounded-full`,\n      className\n    )}\n    {...props}\n  />\n))\nAvatar.displayName = AvatarPrimitive.Root.displayName\n\nconst AvatarImage = React.forwardRef<\n  React.ElementRef<typeof AvatarPrimitive.Image>,\n  React.ComponentPropsWithoutRef<typeof AvatarPrimitive.Image>\n>(({ className, ...props }, ref) => (\n  <AvatarPrimitive.Image\n    ref={ref}\n    className={cn(\"aspect-square h-full w-full\", className)}\n    {...props}\n  />\n))\nAvatarImage.displayName = AvatarPrimitive.Image.displayName\n\nconst AvatarFallback = React.forwardRef<\n  React.ElementRef<typeof AvatarPrimitive.Fallback>,\n  React.ComponentPropsWithoutRef<typeof AvatarPrimitive.Fallback>\n>(({ className, ...props }, ref) => (\n  <AvatarPrimitive.Fallback\n    ref={ref}\n    className={cn(\n      \"flex h-full w-full items-center justify-center rounded-full bg-muted\",\n      className\n    )}\n    {...props}\n  />\n))\nAvatarFallback.displayName = AvatarPrimitive.Fallback.displayName\n\nexport { Avatar, AvatarImage, AvatarFallback }\n","path":null,"size_bytes":1592,"size_tokens":null},"client/src/components/ui/toggle-group.tsx":{"content":"\"use client\"\n\nimport * as React from \"react\"\nimport * as ToggleGroupPrimitive from \"@radix-ui/react-toggle-group\"\nimport { type VariantProps } from \"class-variance-authority\"\n\nimport { cn } from \"@/lib/utils\"\nimport { toggleVariants } from \"@/components/ui/toggle\"\n\nconst ToggleGroupContext = React.createContext<\n  VariantProps<typeof toggleVariants>\n>({\n  size: \"default\",\n  variant: \"default\",\n})\n\nconst ToggleGroup = React.forwardRef<\n  React.ElementRef<typeof ToggleGroupPrimitive.Root>,\n  React.ComponentPropsWithoutRef<typeof ToggleGroupPrimitive.Root> &\n    VariantProps<typeof toggleVariants>\n>(({ className, variant, size, children, ...props }, ref) => (\n  <ToggleGroupPrimitive.Root\n    ref={ref}\n    className={cn(\"flex items-center justify-center gap-1\", className)}\n    {...props}\n  >\n    <ToggleGroupContext.Provider value={{ variant, size }}>\n      {children}\n    </ToggleGroupContext.Provider>\n  </ToggleGroupPrimitive.Root>\n))\n\nToggleGroup.displayName = ToggleGroupPrimitive.Root.displayName\n\nconst ToggleGroupItem = React.forwardRef<\n  React.ElementRef<typeof ToggleGroupPrimitive.Item>,\n  React.ComponentPropsWithoutRef<typeof ToggleGroupPrimitive.Item> &\n    VariantProps<typeof toggleVariants>\n>(({ className, children, variant, size, ...props }, ref) => {\n  const context = React.useContext(ToggleGroupContext)\n\n  return (\n    <ToggleGroupPrimitive.Item\n      ref={ref}\n      className={cn(\n        toggleVariants({\n          variant: context.variant || variant,\n          size: context.size || size,\n        }),\n        className\n      )}\n      {...props}\n    >\n      {children}\n    </ToggleGroupPrimitive.Item>\n  )\n})\n\nToggleGroupItem.displayName = ToggleGroupPrimitive.Item.displayName\n\nexport { ToggleGroup, ToggleGroupItem }\n","path":null,"size_bytes":1753,"size_tokens":null},"client/src/components/ui/dialog.tsx":{"content":"\"use client\"\n\nimport * as React from \"react\"\nimport * as DialogPrimitive from \"@radix-ui/react-dialog\"\nimport { X } from \"lucide-react\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst Dialog = DialogPrimitive.Root\n\nconst DialogTrigger = DialogPrimitive.Trigger\n\nconst DialogPortal = DialogPrimitive.Portal\n\nconst DialogClose = DialogPrimitive.Close\n\nconst DialogOverlay = React.forwardRef<\n  React.ElementRef<typeof DialogPrimitive.Overlay>,\n  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Overlay>\n>(({ className, ...props }, ref) => (\n  <DialogPrimitive.Overlay\n    ref={ref}\n    className={cn(\n      \"fixed inset-0 z-50 bg-black/80 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0\",\n      className\n    )}\n    {...props}\n  />\n))\nDialogOverlay.displayName = DialogPrimitive.Overlay.displayName\n\nconst DialogContent = React.forwardRef<\n  React.ElementRef<typeof DialogPrimitive.Content>,\n  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Content>\n>(({ className, children, ...props }, ref) => (\n  <DialogPortal>\n    <DialogOverlay />\n    <DialogPrimitive.Content\n      ref={ref}\n      className={cn(\n        \"fixed left-[50%] top-[50%] z-50 grid w-full max-w-lg translate-x-[-50%] translate-y-[-50%] gap-4 border bg-background p-6 shadow-lg duration-200 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[state=closed]:slide-out-to-left-1/2 data-[state=closed]:slide-out-to-top-[48%] data-[state=open]:slide-in-from-left-1/2 data-[state=open]:slide-in-from-top-[48%] sm:rounded-lg\",\n        className\n      )}\n      {...props}\n    >\n      {children}\n      <DialogPrimitive.Close className=\"absolute right-4 top-4 rounded-sm opacity-70 ring-offset-background transition-opacity hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none data-[state=open]:bg-accent data-[state=open]:text-muted-foreground\">\n        <X className=\"h-4 w-4\" />\n        <span className=\"sr-only\">Close</span>\n      </DialogPrimitive.Close>\n    </DialogPrimitive.Content>\n  </DialogPortal>\n))\nDialogContent.displayName = DialogPrimitive.Content.displayName\n\nconst DialogHeader = ({\n  className,\n  ...props\n}: React.HTMLAttributes<HTMLDivElement>) => (\n  <div\n    className={cn(\n      \"flex flex-col space-y-1.5 text-center sm:text-left\",\n      className\n    )}\n    {...props}\n  />\n)\nDialogHeader.displayName = \"DialogHeader\"\n\nconst DialogFooter = ({\n  className,\n  ...props\n}: React.HTMLAttributes<HTMLDivElement>) => (\n  <div\n    className={cn(\n      \"flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2\",\n      className\n    )}\n    {...props}\n  />\n)\nDialogFooter.displayName = \"DialogFooter\"\n\nconst DialogTitle = React.forwardRef<\n  React.ElementRef<typeof DialogPrimitive.Title>,\n  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Title>\n>(({ className, ...props }, ref) => (\n  <DialogPrimitive.Title\n    ref={ref}\n    className={cn(\n      \"text-lg font-semibold leading-none tracking-tight\",\n      className\n    )}\n    {...props}\n  />\n))\nDialogTitle.displayName = DialogPrimitive.Title.displayName\n\nconst DialogDescription = React.forwardRef<\n  React.ElementRef<typeof DialogPrimitive.Description>,\n  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Description>\n>(({ className, ...props }, ref) => (\n  <DialogPrimitive.Description\n    ref={ref}\n    className={cn(\"text-sm text-muted-foreground\", className)}\n    {...props}\n  />\n))\nDialogDescription.displayName = DialogPrimitive.Description.displayName\n\nexport {\n  Dialog,\n  DialogPortal,\n  DialogOverlay,\n  DialogClose,\n  DialogTrigger,\n  DialogContent,\n  DialogHeader,\n  DialogFooter,\n  DialogTitle,\n  DialogDescription,\n}\n","path":null,"size_bytes":3848,"size_tokens":null},"client/src/lib/polyfills.ts":{"content":"import { Buffer } from \"buffer/\";\nimport process from \"process/browser\";\n\nif (typeof window !== \"undefined\") {\n  (window as any).Buffer = Buffer;\n  (window as any).global = window;\n  (window as any).process = process;\n  (globalThis as any).Buffer = Buffer;\n}\n\nexport { Buffer };\n","path":null,"size_bytes":279,"size_tokens":null},"client/src/components/ui/menubar.tsx":{"content":"\"use client\"\n\nimport * as React from \"react\"\nimport * as MenubarPrimitive from \"@radix-ui/react-menubar\"\nimport { Check, ChevronRight, Circle } from \"lucide-react\"\n\nimport { cn } from \"@/lib/utils\"\n\nfunction MenubarMenu({\n  ...props\n}: React.ComponentProps<typeof MenubarPrimitive.Menu>) {\n  return <MenubarPrimitive.Menu {...props} />\n}\n\nfunction MenubarGroup({\n  ...props\n}: React.ComponentProps<typeof MenubarPrimitive.Group>) {\n  return <MenubarPrimitive.Group {...props} />\n}\n\nfunction MenubarPortal({\n  ...props\n}: React.ComponentProps<typeof MenubarPrimitive.Portal>) {\n  return <MenubarPrimitive.Portal {...props} />\n}\n\nfunction MenubarRadioGroup({\n  ...props\n}: React.ComponentProps<typeof MenubarPrimitive.RadioGroup>) {\n  return <MenubarPrimitive.RadioGroup {...props} />\n}\n\nfunction MenubarSub({\n  ...props\n}: React.ComponentProps<typeof MenubarPrimitive.Sub>) {\n  return <MenubarPrimitive.Sub data-slot=\"menubar-sub\" {...props} />\n}\n\nconst Menubar = React.forwardRef<\n  React.ElementRef<typeof MenubarPrimitive.Root>,\n  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.Root>\n>(({ className, ...props }, ref) => (\n  <MenubarPrimitive.Root\n    ref={ref}\n    className={cn(\n      \"flex h-10 items-center space-x-1 rounded-md border bg-background p-1\",\n      className\n    )}\n    {...props}\n  />\n))\nMenubar.displayName = MenubarPrimitive.Root.displayName\n\nconst MenubarTrigger = React.forwardRef<\n  React.ElementRef<typeof MenubarPrimitive.Trigger>,\n  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.Trigger>\n>(({ className, ...props }, ref) => (\n  <MenubarPrimitive.Trigger\n    ref={ref}\n    className={cn(\n      \"flex cursor-default select-none items-center rounded-sm px-3 py-1.5 text-sm font-medium outline-none focus:bg-accent focus:text-accent-foreground data-[state=open]:bg-accent data-[state=open]:text-accent-foreground\",\n      className\n    )}\n    {...props}\n  />\n))\nMenubarTrigger.displayName = MenubarPrimitive.Trigger.displayName\n\nconst MenubarSubTrigger = React.forwardRef<\n  React.ElementRef<typeof MenubarPrimitive.SubTrigger>,\n  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.SubTrigger> & {\n    inset?: boolean\n  }\n>(({ className, inset, children, ...props }, ref) => (\n  <MenubarPrimitive.SubTrigger\n    ref={ref}\n    className={cn(\n      \"flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[state=open]:bg-accent data-[state=open]:text-accent-foreground\",\n      inset && \"pl-8\",\n      className\n    )}\n    {...props}\n  >\n    {children}\n    <ChevronRight className=\"ml-auto h-4 w-4\" />\n  </MenubarPrimitive.SubTrigger>\n))\nMenubarSubTrigger.displayName = MenubarPrimitive.SubTrigger.displayName\n\nconst MenubarSubContent = React.forwardRef<\n  React.ElementRef<typeof MenubarPrimitive.SubContent>,\n  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.SubContent>\n>(({ className, ...props }, ref) => (\n  <MenubarPrimitive.SubContent\n    ref={ref}\n    className={cn(\n      \"z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 origin-[--radix-menubar-content-transform-origin]\",\n      className\n    )}\n    {...props}\n  />\n))\nMenubarSubContent.displayName = MenubarPrimitive.SubContent.displayName\n\nconst MenubarContent = React.forwardRef<\n  React.ElementRef<typeof MenubarPrimitive.Content>,\n  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.Content>\n>(\n  (\n    { className, align = \"start\", alignOffset = -4, sideOffset = 8, ...props },\n    ref\n  ) => (\n    <MenubarPrimitive.Portal>\n      <MenubarPrimitive.Content\n        ref={ref}\n        align={align}\n        alignOffset={alignOffset}\n        sideOffset={sideOffset}\n        className={cn(\n          \"z-50 min-w-[12rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 origin-[--radix-menubar-content-transform-origin]\",\n          className\n        )}\n        {...props}\n      />\n    </MenubarPrimitive.Portal>\n  )\n)\nMenubarContent.displayName = MenubarPrimitive.Content.displayName\n\nconst MenubarItem = React.forwardRef<\n  React.ElementRef<typeof MenubarPrimitive.Item>,\n  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.Item> & {\n    inset?: boolean\n  }\n>(({ className, inset, ...props }, ref) => (\n  <MenubarPrimitive.Item\n    ref={ref}\n    className={cn(\n      \"relative flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50\",\n      inset && \"pl-8\",\n      className\n    )}\n    {...props}\n  />\n))\nMenubarItem.displayName = MenubarPrimitive.Item.displayName\n\nconst MenubarCheckboxItem = React.forwardRef<\n  React.ElementRef<typeof MenubarPrimitive.CheckboxItem>,\n  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.CheckboxItem>\n>(({ className, children, checked, ...props }, ref) => (\n  <MenubarPrimitive.CheckboxItem\n    ref={ref}\n    className={cn(\n      \"relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50\",\n      className\n    )}\n    checked={checked}\n    {...props}\n  >\n    <span className=\"absolute left-2 flex h-3.5 w-3.5 items-center justify-center\">\n      <MenubarPrimitive.ItemIndicator>\n        <Check className=\"h-4 w-4\" />\n      </MenubarPrimitive.ItemIndicator>\n    </span>\n    {children}\n  </MenubarPrimitive.CheckboxItem>\n))\nMenubarCheckboxItem.displayName = MenubarPrimitive.CheckboxItem.displayName\n\nconst MenubarRadioItem = React.forwardRef<\n  React.ElementRef<typeof MenubarPrimitive.RadioItem>,\n  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.RadioItem>\n>(({ className, children, ...props }, ref) => (\n  <MenubarPrimitive.RadioItem\n    ref={ref}\n    className={cn(\n      \"relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50\",\n      className\n    )}\n    {...props}\n  >\n    <span className=\"absolute left-2 flex h-3.5 w-3.5 items-center justify-center\">\n      <MenubarPrimitive.ItemIndicator>\n        <Circle className=\"h-2 w-2 fill-current\" />\n      </MenubarPrimitive.ItemIndicator>\n    </span>\n    {children}\n  </MenubarPrimitive.RadioItem>\n))\nMenubarRadioItem.displayName = MenubarPrimitive.RadioItem.displayName\n\nconst MenubarLabel = React.forwardRef<\n  React.ElementRef<typeof MenubarPrimitive.Label>,\n  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.Label> & {\n    inset?: boolean\n  }\n>(({ className, inset, ...props }, ref) => (\n  <MenubarPrimitive.Label\n    ref={ref}\n    className={cn(\n      \"px-2 py-1.5 text-sm font-semibold\",\n      inset && \"pl-8\",\n      className\n    )}\n    {...props}\n  />\n))\nMenubarLabel.displayName = MenubarPrimitive.Label.displayName\n\nconst MenubarSeparator = React.forwardRef<\n  React.ElementRef<typeof MenubarPrimitive.Separator>,\n  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.Separator>\n>(({ className, ...props }, ref) => (\n  <MenubarPrimitive.Separator\n    ref={ref}\n    className={cn(\"-mx-1 my-1 h-px bg-muted\", className)}\n    {...props}\n  />\n))\nMenubarSeparator.displayName = MenubarPrimitive.Separator.displayName\n\nconst MenubarShortcut = ({\n  className,\n  ...props\n}: React.HTMLAttributes<HTMLSpanElement>) => {\n  return (\n    <span\n      className={cn(\n        \"ml-auto text-xs tracking-widest text-muted-foreground\",\n        className\n      )}\n      {...props}\n    />\n  )\n}\nMenubarShortcut.displayname = \"MenubarShortcut\"\n\nexport {\n  Menubar,\n  MenubarMenu,\n  MenubarTrigger,\n  MenubarContent,\n  MenubarItem,\n  MenubarSeparator,\n  MenubarLabel,\n  MenubarCheckboxItem,\n  MenubarRadioGroup,\n  MenubarRadioItem,\n  MenubarPortal,\n  MenubarSubContent,\n  MenubarSubTrigger,\n  MenubarGroup,\n  MenubarSub,\n  MenubarShortcut,\n}\n","path":null,"size_bytes":8605,"size_tokens":null},"client/src/components/ui/sidebar.tsx":{"content":"\"use client\"\n\nimport * as React from \"react\"\nimport { Slot } from \"@radix-ui/react-slot\"\nimport { cva, VariantProps } from \"class-variance-authority\"\nimport { PanelLeftIcon } from \"lucide-react\"\n\nimport { useIsMobile } from \"@/hooks/use-mobile\"\nimport { cn } from \"@/lib/utils\"\nimport { Button } from \"@/components/ui/button\"\nimport { Input } from \"@/components/ui/input\"\nimport { Separator } from \"@/components/ui/separator\"\nimport {\n  Sheet,\n  SheetContent,\n  SheetDescription,\n  SheetHeader,\n  SheetTitle,\n} from \"@/components/ui/sheet\"\nimport { Skeleton } from \"@/components/ui/skeleton\"\nimport {\n  Tooltip,\n  TooltipContent,\n  TooltipProvider,\n  TooltipTrigger,\n} from \"@/components/ui/tooltip\"\n\nconst SIDEBAR_COOKIE_NAME = \"sidebar_state\"\nconst SIDEBAR_COOKIE_MAX_AGE = 60 * 60 * 24 * 7\nconst SIDEBAR_WIDTH = \"16rem\"\nconst SIDEBAR_WIDTH_MOBILE = \"18rem\"\nconst SIDEBAR_WIDTH_ICON = \"3rem\"\nconst SIDEBAR_KEYBOARD_SHORTCUT = \"b\"\n\ntype SidebarContextProps = {\n  state: \"expanded\" | \"collapsed\"\n  open: boolean\n  setOpen: (open: boolean) => void\n  openMobile: boolean\n  setOpenMobile: (open: boolean) => void\n  isMobile: boolean\n  toggleSidebar: () => void\n}\n\nconst SidebarContext = React.createContext<SidebarContextProps | null>(null)\n\nfunction useSidebar() {\n  const context = React.useContext(SidebarContext)\n  if (!context) {\n    throw new Error(\"useSidebar must be used within a SidebarProvider.\")\n  }\n\n  return context\n}\n\nfunction SidebarProvider({\n  defaultOpen = true,\n  open: openProp,\n  onOpenChange: setOpenProp,\n  className,\n  style,\n  children,\n  ...props\n}: React.ComponentProps<\"div\"> & {\n  defaultOpen?: boolean\n  open?: boolean\n  onOpenChange?: (open: boolean) => void\n}) {\n  const isMobile = useIsMobile()\n  const [openMobile, setOpenMobile] = React.useState(false)\n\n  // This is the internal state of the sidebar.\n  // We use openProp and setOpenProp for control from outside the component.\n  const [_open, _setOpen] = React.useState(defaultOpen)\n  const open = openProp ?? _open\n  const setOpen = React.useCallback(\n    (value: boolean | ((value: boolean) => boolean)) => {\n      const openState = typeof value === \"function\" ? value(open) : value\n      if (setOpenProp) {\n        setOpenProp(openState)\n      } else {\n        _setOpen(openState)\n      }\n\n      // This sets the cookie to keep the sidebar state.\n      document.cookie = `${SIDEBAR_COOKIE_NAME}=${openState}; path=/; max-age=${SIDEBAR_COOKIE_MAX_AGE}`\n    },\n    [setOpenProp, open]\n  )\n\n  // Helper to toggle the sidebar.\n  const toggleSidebar = React.useCallback(() => {\n    return isMobile ? setOpenMobile((open) => !open) : setOpen((open) => !open)\n  }, [isMobile, setOpen, setOpenMobile])\n\n  // Adds a keyboard shortcut to toggle the sidebar.\n  React.useEffect(() => {\n    const handleKeyDown = (event: KeyboardEvent) => {\n      if (\n        event.key === SIDEBAR_KEYBOARD_SHORTCUT &&\n        (event.metaKey || event.ctrlKey)\n      ) {\n        event.preventDefault()\n        toggleSidebar()\n      }\n    }\n\n    window.addEventListener(\"keydown\", handleKeyDown)\n    return () => window.removeEventListener(\"keydown\", handleKeyDown)\n  }, [toggleSidebar])\n\n  // We add a state so that we can do data-state=\"expanded\" or \"collapsed\".\n  // This makes it easier to style the sidebar with Tailwind classes.\n  const state = open ? \"expanded\" : \"collapsed\"\n\n  const contextValue = React.useMemo<SidebarContextProps>(\n    () => ({\n      state,\n      open,\n      setOpen,\n      isMobile,\n      openMobile,\n      setOpenMobile,\n      toggleSidebar,\n    }),\n    [state, open, setOpen, isMobile, openMobile, setOpenMobile, toggleSidebar]\n  )\n\n  return (\n    <SidebarContext.Provider value={contextValue}>\n      <TooltipProvider delayDuration={0}>\n        <div\n          data-slot=\"sidebar-wrapper\"\n          style={\n            {\n              \"--sidebar-width\": SIDEBAR_WIDTH,\n              \"--sidebar-width-icon\": SIDEBAR_WIDTH_ICON,\n              ...style,\n            } as React.CSSProperties\n          }\n          className={cn(\n            \"group/sidebar-wrapper has-data-[variant=inset]:bg-sidebar flex min-h-svh w-full\",\n            className\n          )}\n          {...props}\n        >\n          {children}\n        </div>\n      </TooltipProvider>\n    </SidebarContext.Provider>\n  )\n}\n\nfunction Sidebar({\n  side = \"left\",\n  variant = \"sidebar\",\n  collapsible = \"offcanvas\",\n  className,\n  children,\n  ...props\n}: React.ComponentProps<\"div\"> & {\n  side?: \"left\" | \"right\"\n  variant?: \"sidebar\" | \"floating\" | \"inset\"\n  collapsible?: \"offcanvas\" | \"icon\" | \"none\"\n}) {\n  const { isMobile, state, openMobile, setOpenMobile } = useSidebar()\n\n  if (collapsible === \"none\") {\n    return (\n      <div\n        data-slot=\"sidebar\"\n        className={cn(\n          \"bg-sidebar text-sidebar-foreground flex h-full w-[var(--sidebar-width)] flex-col\",\n          className\n        )}\n        {...props}\n      >\n        {children}\n      </div>\n    )\n  }\n\n  if (isMobile) {\n    return (\n      <Sheet open={openMobile} onOpenChange={setOpenMobile} {...props}>\n        <SheetContent\n          data-sidebar=\"sidebar\"\n          data-slot=\"sidebar\"\n          data-mobile=\"true\"\n          className=\"bg-sidebar text-sidebar-foreground w-[var(--sidebar-width)] p-0 [&>button]:hidden\"\n          style={\n            {\n              \"--sidebar-width\": SIDEBAR_WIDTH_MOBILE,\n            } as React.CSSProperties\n          }\n          side={side}\n        >\n          <SheetHeader className=\"sr-only\">\n            <SheetTitle>Sidebar</SheetTitle>\n            <SheetDescription>Displays the mobile sidebar.</SheetDescription>\n          </SheetHeader>\n          <div className=\"flex h-full w-full flex-col\">{children}</div>\n        </SheetContent>\n      </Sheet>\n    )\n  }\n\n  return (\n    <div\n      className=\"group peer text-sidebar-foreground hidden md:block\"\n      data-state={state}\n      data-collapsible={state === \"collapsed\" ? collapsible : \"\"}\n      data-variant={variant}\n      data-side={side}\n      data-slot=\"sidebar\"\n    >\n      {/* This is what handles the sidebar gap on desktop */}\n      <div\n        data-slot=\"sidebar-gap\"\n        className={cn(\n          \"relative w-[var(--sidebar-width)] bg-transparent transition-[width] duration-200 ease-linear\",\n          \"group-data-[collapsible=offcanvas]:w-0\",\n          \"group-data-[side=right]:rotate-180\",\n          variant === \"floating\" || variant === \"inset\"\n            ? \"group-data-[collapsible=icon]:w-[calc(var(--sidebar-width-icon)+var(--spacing-4))]\"\n            : \"group-data-[collapsible=icon]:w-[var(--sidebar-width-icon)]\"\n        )}\n      />\n      <div\n        data-slot=\"sidebar-container\"\n        className={cn(\n          \"fixed inset-y-0 z-10 hidden h-svh w-[var(--sidebar-width)] transition-[left,right,width] duration-200 ease-linear md:flex\",\n          side === \"left\"\n            ? \"left-0 group-data-[collapsible=offcanvas]:left-[calc(var(--sidebar-width)*-1)]\"\n            : \"right-0 group-data-[collapsible=offcanvas]:right-[calc(var(--sidebar-width)*-1)]\",\n          // Adjust the padding for floating and inset variants.\n          variant === \"floating\" || variant === \"inset\"\n            ? \"p-2 group-data-[collapsible=icon]:w-[calc(var(--sidebar-width-icon)+var(--spacing-4)+2px)]\"\n            : \"group-data-[collapsible=icon]:w-[var(--sidebar-width-icon)] group-data-[side=left]:border-r group-data-[side=right]:border-l\",\n          className\n        )}\n        {...props}\n      >\n        <div\n          data-sidebar=\"sidebar\"\n          data-slot=\"sidebar-inner\"\n          className=\"bg-sidebar group-data-[variant=floating]:border-sidebar-border flex h-full w-full flex-col group-data-[variant=floating]:rounded-lg group-data-[variant=floating]:border group-data-[variant=floating]:shadow-sm\"\n        >\n          {children}\n        </div>\n      </div>\n    </div>\n  )\n}\n\nfunction SidebarTrigger({\n  className,\n  onClick,\n  ...props\n}: React.ComponentProps<typeof Button>) {\n  const { toggleSidebar } = useSidebar()\n\n  return (\n    <Button\n      data-sidebar=\"trigger\"\n      data-slot=\"sidebar-trigger\"\n      variant=\"ghost\"\n      size=\"icon\"\n      className={cn(\"h-7 w-7\", className)}\n      onClick={(event) => {\n        onClick?.(event)\n        toggleSidebar()\n      }}\n      {...props}\n    >\n      <PanelLeftIcon />\n      <span className=\"sr-only\">Toggle Sidebar</span>\n    </Button>\n  )\n}\n\nfunction SidebarRail({ className, ...props }: React.ComponentProps<\"button\">) {\n  const { toggleSidebar } = useSidebar()\n\n  // Note: Tailwind v3.4 doesn't support \"in-\" selectors. So the rail won't work perfectly.\n  return (\n    <button\n      data-sidebar=\"rail\"\n      data-slot=\"sidebar-rail\"\n      aria-label=\"Toggle Sidebar\"\n      tabIndex={-1}\n      onClick={toggleSidebar}\n      title=\"Toggle Sidebar\"\n      className={cn(\n        \"hover:after:bg-sidebar-border absolute inset-y-0 z-20 hidden w-4 -translate-x-1/2 transition-all ease-linear group-data-[side=left]:-right-4 group-data-[side=right]:left-0 after:absolute after:inset-y-0 after:left-1/2 after:w-[2px] sm:flex\",\n        \"in-data-[side=left]:cursor-w-resize in-data-[side=right]:cursor-e-resize\",\n        \"[[data-side=left][data-state=collapsed]_&]:cursor-e-resize [[data-side=right][data-state=collapsed]_&]:cursor-w-resize\",\n        \"hover:group-data-[collapsible=offcanvas]:bg-sidebar group-data-[collapsible=offcanvas]:translate-x-0 group-data-[collapsible=offcanvas]:after:left-full\",\n        \"[[data-side=left][data-collapsible=offcanvas]_&]:-right-2\",\n        \"[[data-side=right][data-collapsible=offcanvas]_&]:-left-2\",\n        className\n      )}\n      {...props}\n    />\n  )\n}\n\nfunction SidebarInset({ className, ...props }: React.ComponentProps<\"main\">) {\n  return (\n    <main\n      data-slot=\"sidebar-inset\"\n      className={cn(\n        \"bg-background relative flex w-full flex-1 flex-col\",\n        \"md:peer-data-[variant=inset]:m-2 md:peer-data-[variant=inset]:ml-0 md:peer-data-[variant=inset]:rounded-xl md:peer-data-[variant=inset]:shadow-sm md:peer-data-[variant=inset]:peer-data-[state=collapsed]:ml-2\",\n        className\n      )}\n      {...props}\n    />\n  )\n}\n\nfunction SidebarInput({\n  className,\n  ...props\n}: React.ComponentProps<typeof Input>) {\n  return (\n    <Input\n      data-slot=\"sidebar-input\"\n      data-sidebar=\"input\"\n      className={cn(\"bg-background h-8 w-full shadow-none\", className)}\n      {...props}\n    />\n  )\n}\n\nfunction SidebarHeader({ className, ...props }: React.ComponentProps<\"div\">) {\n  return (\n    <div\n      data-slot=\"sidebar-header\"\n      data-sidebar=\"header\"\n      className={cn(\"flex flex-col gap-2 p-2\", className)}\n      {...props}\n    />\n  )\n}\n\nfunction SidebarFooter({ className, ...props }: React.ComponentProps<\"div\">) {\n  return (\n    <div\n      data-slot=\"sidebar-footer\"\n      data-sidebar=\"footer\"\n      className={cn(\"flex flex-col gap-2 p-2\", className)}\n      {...props}\n    />\n  )\n}\n\nfunction SidebarSeparator({\n  className,\n  ...props\n}: React.ComponentProps<typeof Separator>) {\n  return (\n    <Separator\n      data-slot=\"sidebar-separator\"\n      data-sidebar=\"separator\"\n      className={cn(\"bg-sidebar-border mx-2 w-auto\", className)}\n      {...props}\n    />\n  )\n}\n\nfunction SidebarContent({ className, ...props }: React.ComponentProps<\"div\">) {\n  return (\n    <div\n      data-slot=\"sidebar-content\"\n      data-sidebar=\"content\"\n      className={cn(\n        \"flex min-h-0 flex-1 flex-col gap-2 overflow-auto group-data-[collapsible=icon]:overflow-hidden\",\n        className\n      )}\n      {...props}\n    />\n  )\n}\n\nfunction SidebarGroup({ className, ...props }: React.ComponentProps<\"div\">) {\n  return (\n    <div\n      data-slot=\"sidebar-group\"\n      data-sidebar=\"group\"\n      className={cn(\"relative flex w-full min-w-0 flex-col p-2\", className)}\n      {...props}\n    />\n  )\n}\n\nfunction SidebarGroupLabel({\n  className,\n  asChild = false,\n  ...props\n}: React.ComponentProps<\"div\"> & { asChild?: boolean }) {\n  const Comp = asChild ? Slot : \"div\"\n\n  return (\n    <Comp\n      data-slot=\"sidebar-group-label\"\n      data-sidebar=\"group-label\"\n      className={cn(\n        \"text-sidebar-foreground/70 ring-sidebar-ring flex h-8 shrink-0 items-center rounded-md px-2 text-xs font-medium outline-hidden transition-[margin,opacity] duration-200 ease-linear focus-visible:ring-2 [&>svg]:h-4 [&>svg]:w-4 [&>svg]:shrink-0\",\n        \"group-data-[collapsible=icon]:-mt-8 group-data-[collapsible=icon]:opacity-0\",\n        className\n      )}\n      {...props}\n    />\n  )\n}\n\nfunction SidebarGroupAction({\n  className,\n  asChild = false,\n  ...props\n}: React.ComponentProps<\"button\"> & { asChild?: boolean }) {\n  const Comp = asChild ? Slot : \"button\"\n\n  return (\n    <Comp\n      data-slot=\"sidebar-group-action\"\n      data-sidebar=\"group-action\"\n      className={cn(\n        \"text-sidebar-foreground ring-sidebar-ring hover:bg-sidebar-accent hover:text-sidebar-accent-foreground absolute top-3.5 right-3 flex aspect-square w-5 items-center justify-center rounded-md p-0 outline-hidden transition-transform focus-visible:ring-2 [&>svg]:size-4 [&>svg]:shrink-0\",\n        // Increases the hit area of the button on mobile.\n        \"after:absolute after:-inset-2 md:after:hidden\",\n        \"group-data-[collapsible=icon]:hidden\",\n        className\n      )}\n      {...props}\n    />\n  )\n}\n\nfunction SidebarGroupContent({\n  className,\n  ...props\n}: React.ComponentProps<\"div\">) {\n  return (\n    <div\n      data-slot=\"sidebar-group-content\"\n      data-sidebar=\"group-content\"\n      className={cn(\"w-full text-sm\", className)}\n      {...props}\n    />\n  )\n}\n\nfunction SidebarMenu({ className, ...props }: React.ComponentProps<\"ul\">) {\n  return (\n    <ul\n      data-slot=\"sidebar-menu\"\n      data-sidebar=\"menu\"\n      className={cn(\"flex w-full min-w-0 flex-col gap-1\", className)}\n      {...props}\n    />\n  )\n}\n\nfunction SidebarMenuItem({ className, ...props }: React.ComponentProps<\"li\">) {\n  return (\n    <li\n      data-slot=\"sidebar-menu-item\"\n      data-sidebar=\"menu-item\"\n      className={cn(\"group/menu-item relative\", className)}\n      {...props}\n    />\n  )\n}\n\nconst sidebarMenuButtonVariants = cva(\n  \"peer/menu-button flex w-full items-center gap-2 overflow-hidden rounded-md p-2 text-left text-sm outline-hidden ring-sidebar-ring transition-[width,height,padding] hover:bg-sidebar-accent hover:text-sidebar-accent-foreground focus-visible:ring-2 active:bg-sidebar-accent active:text-sidebar-accent-foreground disabled:pointer-events-none disabled:opacity-50 group-has-data-[sidebar=menu-action]/menu-item:pr-8 aria-disabled:pointer-events-none aria-disabled:opacity-50 data-[active=true]:bg-sidebar-accent data-[active=true]:font-medium data-[active=true]:text-sidebar-accent-foreground data-[state=open]:hover:bg-sidebar-accent data-[state=open]:hover:text-sidebar-accent-foreground group-data-[collapsible=icon]:w-8! group-data-[collapsible=icon]:h-8! group-data-[collapsible=icon]:p-2! [&>span:last-child]:truncate [&>svg]:size-4 [&>svg]:shrink-0\",\n  {\n    variants: {\n      variant: {\n        default: \"hover:bg-sidebar-accent hover:text-sidebar-accent-foreground\",\n        outline:\n          \"bg-background shadow-[0_0_0_1px_hsl(var(--sidebar-border))] hover:bg-sidebar-accent hover:text-sidebar-accent-foreground hover:shadow-[0_0_0_1px_hsl(var(--sidebar-accent))]\",\n      },\n      size: {\n        default: \"h-8 text-sm\",\n        sm: \"h-7 text-xs\",\n        lg: \"h-12 text-sm group-data-[collapsible=icon]:p-0!\",\n      },\n    },\n    defaultVariants: {\n      variant: \"default\",\n      size: \"default\",\n    },\n  }\n)\n\nfunction SidebarMenuButton({\n  asChild = false,\n  isActive = false,\n  variant = \"default\",\n  size = \"default\",\n  tooltip,\n  className,\n  ...props\n}: React.ComponentProps<\"button\"> & {\n  asChild?: boolean\n  isActive?: boolean\n  tooltip?: string | React.ComponentProps<typeof TooltipContent>\n} & VariantProps<typeof sidebarMenuButtonVariants>) {\n  const Comp = asChild ? Slot : \"button\"\n  const { isMobile, state } = useSidebar()\n\n  const button = (\n    <Comp\n      data-slot=\"sidebar-menu-button\"\n      data-sidebar=\"menu-button\"\n      data-size={size}\n      data-active={isActive}\n      className={cn(sidebarMenuButtonVariants({ variant, size }), className)}\n      {...props}\n    />\n  )\n\n  if (!tooltip) {\n    return button\n  }\n\n  if (typeof tooltip === \"string\") {\n    tooltip = {\n      children: tooltip,\n    }\n  }\n\n  return (\n    <Tooltip>\n      <TooltipTrigger asChild>{button}</TooltipTrigger>\n      <TooltipContent\n        side=\"right\"\n        align=\"center\"\n        hidden={state !== \"collapsed\" || isMobile}\n        {...tooltip}\n      />\n    </Tooltip>\n  )\n}\n\nfunction SidebarMenuAction({\n  className,\n  asChild = false,\n  showOnHover = false,\n  ...props\n}: React.ComponentProps<\"button\"> & {\n  asChild?: boolean\n  showOnHover?: boolean\n}) {\n  const Comp = asChild ? Slot : \"button\"\n\n  return (\n    <Comp\n      data-slot=\"sidebar-menu-action\"\n      data-sidebar=\"menu-action\"\n      className={cn(\n        \"text-sidebar-foreground ring-sidebar-ring hover:bg-sidebar-accent hover:text-sidebar-accent-foreground peer-hover/menu-button:text-sidebar-accent-foreground absolute top-1.5 right-1 flex aspect-square w-5 items-center justify-center rounded-md p-0 outline-hidden transition-transform focus-visible:ring-2 [&>svg]:size-4 [&>svg]:shrink-0\",\n        // Increases the hit area of the button on mobile.\n        \"after:absolute after:-inset-2 md:after:hidden\",\n        \"peer-data-[size=sm]/menu-button:top-1\",\n        \"peer-data-[size=default]/menu-button:top-1.5\",\n        \"peer-data-[size=lg]/menu-button:top-2.5\",\n        \"group-data-[collapsible=icon]:hidden\",\n        showOnHover &&\n          \"peer-data-[active=true]/menu-button:text-sidebar-accent-foreground group-focus-within/menu-item:opacity-100 group-hover/menu-item:opacity-100 data-[state=open]:opacity-100 md:opacity-0\",\n        className\n      )}\n      {...props}\n    />\n  )\n}\n\nfunction SidebarMenuBadge({\n  className,\n  ...props\n}: React.ComponentProps<\"div\">) {\n  return (\n    <div\n      data-slot=\"sidebar-menu-badge\"\n      data-sidebar=\"menu-badge\"\n      className={cn(\n        \"text-sidebar-foreground pointer-events-none absolute right-1 flex h-5 min-w-5 items-center justify-center rounded-md px-1 text-xs font-medium tabular-nums select-none\",\n        \"peer-hover/menu-button:text-sidebar-accent-foreground peer-data-[active=true]/menu-button:text-sidebar-accent-foreground\",\n        \"peer-data-[size=sm]/menu-button:top-1\",\n        \"peer-data-[size=default]/menu-button:top-1.5\",\n        \"peer-data-[size=lg]/menu-button:top-2.5\",\n        \"group-data-[collapsible=icon]:hidden\",\n        className\n      )}\n      {...props}\n    />\n  )\n}\n\nfunction SidebarMenuSkeleton({\n  className,\n  showIcon = false,\n  ...props\n}: React.ComponentProps<\"div\"> & {\n  showIcon?: boolean\n}) {\n  // Random width between 50 to 90%.\n  const width = React.useMemo(() => {\n    return `${Math.floor(Math.random() * 40) + 50}%`\n  }, [])\n\n  return (\n    <div\n      data-slot=\"sidebar-menu-skeleton\"\n      data-sidebar=\"menu-skeleton\"\n      className={cn(\"flex h-8 items-center gap-2 rounded-md px-2\", className)}\n      {...props}\n    >\n      {showIcon && (\n        <Skeleton\n          className=\"size-4 rounded-md\"\n          data-sidebar=\"menu-skeleton-icon\"\n        />\n      )}\n      <Skeleton\n        className=\"h-4 max-w-[var(--skeleton-width)] flex-1\"\n        data-sidebar=\"menu-skeleton-text\"\n        style={\n          {\n            \"--skeleton-width\": width,\n          } as React.CSSProperties\n        }\n      />\n    </div>\n  )\n}\n\nfunction SidebarMenuSub({ className, ...props }: React.ComponentProps<\"ul\">) {\n  return (\n    <ul\n      data-slot=\"sidebar-menu-sub\"\n      data-sidebar=\"menu-sub\"\n      className={cn(\n        \"border-sidebar-border mx-3.5 flex min-w-0 translate-x-px flex-col gap-1 border-l px-2.5 py-0.5\",\n        \"group-data-[collapsible=icon]:hidden\",\n        className\n      )}\n      {...props}\n    />\n  )\n}\n\nfunction SidebarMenuSubItem({\n  className,\n  ...props\n}: React.ComponentProps<\"li\">) {\n  return (\n    <li\n      data-slot=\"sidebar-menu-sub-item\"\n      data-sidebar=\"menu-sub-item\"\n      className={cn(\"group/menu-sub-item relative\", className)}\n      {...props}\n    />\n  )\n}\n\nfunction SidebarMenuSubButton({\n  asChild = false,\n  size = \"md\",\n  isActive = false,\n  className,\n  ...props\n}: React.ComponentProps<\"a\"> & {\n  asChild?: boolean\n  size?: \"sm\" | \"md\"\n  isActive?: boolean\n}) {\n  const Comp = asChild ? Slot : \"a\"\n\n  return (\n    <Comp\n      data-slot=\"sidebar-menu-sub-button\"\n      data-sidebar=\"menu-sub-button\"\n      data-size={size}\n      data-active={isActive}\n      className={cn(\n        \"text-sidebar-foreground ring-sidebar-ring hover:bg-sidebar-accent hover:text-sidebar-accent-foreground active:bg-sidebar-accent active:text-sidebar-accent-foreground [&>svg]:text-sidebar-accent-foreground flex h-7 min-w-0 -translate-x-px items-center gap-2 overflow-hidden rounded-md px-2 outline outline-2 outline-transparent outline-offset-2 focus-visible:ring-2 disabled:pointer-events-none disabled:opacity-50 aria-disabled:pointer-events-none aria-disabled:opacity-50 [&>span:last-child]:truncate [&>svg]:size-4 [&>svg]:shrink-0\",\n        \"data-[active=true]:bg-sidebar-accent data-[active=true]:text-sidebar-accent-foreground\",\n        size === \"sm\" && \"text-xs\",\n        size === \"md\" && \"text-sm\",\n        \"group-data-[collapsible=icon]:hidden\",\n        className\n      )}\n      {...props}\n    />\n  )\n}\n\nexport {\n  Sidebar,\n  SidebarContent,\n  SidebarFooter,\n  SidebarGroup,\n  SidebarGroupAction,\n  SidebarGroupContent,\n  SidebarGroupLabel,\n  SidebarHeader,\n  SidebarInput,\n  SidebarInset,\n  SidebarMenu,\n  SidebarMenuAction,\n  SidebarMenuBadge,\n  SidebarMenuButton,\n  SidebarMenuItem,\n  SidebarMenuSkeleton,\n  SidebarMenuSub,\n  SidebarMenuSubButton,\n  SidebarMenuSubItem,\n  SidebarProvider,\n  SidebarRail,\n  SidebarSeparator,\n  SidebarTrigger,\n  useSidebar,\n}\n","path":null,"size_bytes":21846,"size_tokens":null},"client/src/pages/transfer.tsx":{"content":"import { useState, useEffect, useRef } from \"react\";\nimport { useQuery } from \"@tanstack/react-query\";\nimport { QRCodeSVG } from \"qrcode.react\";\nimport { Capacitor } from \"@capacitor/core\";\nimport { \n  ArrowUpRight, \n  ArrowDownLeft, \n  Copy, \n  QrCode,\n  Send,\n  Shield,\n  AlertCircle,\n  Coins,\n} from \"lucide-react\";\nimport { BackButton } from \"@/components/back-button\";\nimport { Card, CardContent } from \"@/components/ui/card\";\nimport { Button } from \"@/components/ui/button\";\nimport { Input } from \"@/components/ui/input\";\nimport { Label } from \"@/components/ui/label\";\nimport { Tabs, TabsContent, TabsList, TabsTrigger } from \"@/components/ui/tabs\";\nimport { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from \"@/components/ui/select\";\nimport { Alert, AlertDescription } from \"@/components/ui/alert\";\nimport { Skeleton } from \"@/components/ui/skeleton\";\nimport { useWallet } from \"@/lib/wallet-context\";\nimport { useToast } from \"@/hooks/use-toast\";\nimport { ChainIcon } from \"@/components/chain-icon\";\nimport { HardwareStatusCard } from \"@/components/hardware-status\";\nimport { clientStorage, type CustomToken } from \"@/lib/client-storage\";\nimport { formatCryptoBalance } from \"@/lib/price-service\";\nimport { TOKEN_PARENT_CHAIN_SYMBOL } from \"@/lib/chain-mappings\";\nimport type { Chain, Wallet } from \"@shared/schema\";\n\ninterface TokenOption {\n  id: string;\n  symbol: string;\n  name: string;\n  balance: string;\n  isNative: boolean;\n  contractAddress?: string;\n  decimals?: number;\n  image?: string;\n}\n\nfunction truncateAddress(address: string): string {\n  if (!address) return \"\";\n  return `${address.slice(0, 10)}...${address.slice(-8)}`;\n}\n\nconst formatBalance = formatCryptoBalance;\n\nfunction getAddressPlaceholder(symbol: string | undefined): string {\n  if (!symbol) return \"Enter address...\";\n  \n  switch (symbol.toUpperCase()) {\n    case 'BTC':\n      return \"bc1... or 1... or 3...\";\n    case 'SOL':\n      return \"Base58 address...\";\n    case 'XRP':\n      return \"r...\";\n    case 'ADA':\n      return \"addr1...\";\n    case 'DOGE':\n      return \"D...\";\n    case 'DOT':\n      return \"1... (SS58 format)\";\n    case 'LTC':\n      return \"L... or M... or ltc1...\";\n    case 'BCH':\n      return \"bitcoincash:q...\";\n    case 'TRX':\n      return \"T...\";\n    case 'ATOM':\n    case 'OSMO':\n      return \"cosmos1... or osmo1...\";\n    case 'ETH':\n    case 'BNB':\n    case 'MATIC':\n    case 'AVAX':\n    case 'ARB':\n    default:\n      return \"0x...\";\n  }\n}\n\ninterface GasEstimate {\n  gasPrice: string;\n  gasPriceGwei: string;\n  estimatedGas: string;\n  estimatedFee: string;\n  estimatedFeeUsd: string | null;\n  symbol: string;\n  error?: string;\n}\n\n// RPC endpoints for client-side gas estimation (mobile)\nconst RPC_ENDPOINTS: Record<string, string> = {\n  'chain-0': 'https://eth.llamarpc.com',           // Ethereum\n  'chain-3': 'https://bsc-dataseed1.binance.org',  // BNB Chain\n  'chain-4': 'https://polygon-rpc.com',            // Polygon\n  'chain-5': 'https://api.avax.network/ext/bc/C/rpc', // Avalanche\n  'chain-6': 'https://arb1.arbitrum.io/rpc',       // Arbitrum\n  'chain-7': 'https://mainnet.optimism.io',        // Optimism\n};\n\nconst DEFAULT_GAS_LIMITS: Record<string, number> = {\n  'chain-0': 21000,  // Ethereum\n  'chain-1': 250,    // Bitcoin (vbytes)\n  'chain-2': 5000,   // Solana (compute units)\n  'chain-3': 21000,  // BNB Chain\n  'chain-4': 21000,  // Polygon\n  'chain-5': 21000,  // Avalanche\n  'chain-6': 21000,  // Arbitrum\n  'chain-7': 21000,  // Optimism\n  'chain-8': 0,      // TRON (bandwidth)\n};\n\nconst TOKEN_GAS_LIMITS: Record<string, number> = {\n  'chain-0': 65000,  // Ethereum ERC20\n  'chain-3': 65000,  // BNB Chain BEP20\n  'chain-4': 65000,  // Polygon ERC20\n  'chain-5': 65000,  // Avalanche ERC20\n  'chain-6': 65000,  // Arbitrum ERC20\n  'chain-7': 65000,  // Optimism ERC20\n};\n\n// Non-EVM chain symbols and their static fees\nconst NON_EVM_CHAIN_FEES: Record<string, { fee: string; unit: string }> = {\n  'BTC': { fee: '0.00001', unit: 'BTC' },\n  'SOL': { fee: '0.000005', unit: 'SOL' },\n  'TRX': { fee: '0', unit: 'TRX' },\n  'XRP': { fee: '0.00001', unit: 'XRP' },\n  'DOGE': { fee: '1', unit: 'DOGE' },\n  'LTC': { fee: '0.0001', unit: 'LTC' },\n  'BCH': { fee: '0.00001', unit: 'BCH' },\n  'ADA': { fee: '0.17', unit: 'ADA' },\n  'ATOM': { fee: '0.005', unit: 'ATOM' },\n  'OSMO': { fee: '0.005', unit: 'OSMO' },\n  'DOT': { fee: '0.01', unit: 'DOT' },\n};\n\nasync function fetchClientSideGasEstimate(chainId: string, isNative: boolean, chainSymbol?: string): Promise<GasEstimate> {\n  const symbol = chainSymbol || 'ETH';\n  \n  // Non-EVM chains have static fees - check by symbol\n  const nonEvmFee = NON_EVM_CHAIN_FEES[symbol];\n  if (nonEvmFee) {\n    return {\n      gasPrice: '0',\n      gasPriceGwei: 'N/A',\n      estimatedGas: '0',\n      estimatedFee: nonEvmFee.fee,\n      estimatedFeeUsd: null,\n      symbol: nonEvmFee.unit,\n    };\n  }\n  \n  // For EVM chains, fetch gas price from RPC\n  const rpcUrl = RPC_ENDPOINTS[chainId];\n  if (!rpcUrl) {\n    return {\n      gasPrice: '0',\n      gasPriceGwei: '20',\n      estimatedGas: '21000',\n      estimatedFee: '0.00042',\n      estimatedFeeUsd: null,\n      symbol,\n      error: 'No RPC endpoint available',\n    };\n  }\n  \n  try {\n    console.log('[GasEstimate] Fetching gas price for chain:', chainId, 'RPC:', rpcUrl);\n    const response = await fetch(rpcUrl, {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify({\n        jsonrpc: '2.0',\n        method: 'eth_gasPrice',\n        params: [],\n        id: 1,\n      }),\n    });\n    \n    const data = await response.json();\n    console.log('[GasEstimate] Response:', data);\n    \n    if (!data.result) {\n      console.error('[GasEstimate] No result in response:', data);\n      throw new Error('No gas price result');\n    }\n    \n    const gasPriceWei = BigInt(data.result);\n    const gasPriceGwei = (Number(gasPriceWei) / 1e9).toFixed(2);\n    const gasLimit = isNative \n      ? (DEFAULT_GAS_LIMITS[chainId] || 21000)\n      : (TOKEN_GAS_LIMITS[chainId] || 65000);\n    const estimatedFeeWei = gasPriceWei * BigInt(gasLimit);\n    const estimatedFee = (Number(estimatedFeeWei) / 1e18).toFixed(6);\n    \n    return {\n      gasPrice: gasPriceWei.toString(),\n      gasPriceGwei,\n      estimatedGas: gasLimit.toString(),\n      estimatedFee,\n      estimatedFeeUsd: null,\n      symbol,\n    };\n  } catch (error) {\n    console.error('[GasEstimate] Client-side fetch failed:', error);\n    return {\n      gasPrice: '0',\n      gasPriceGwei: '20',\n      estimatedGas: '21000',\n      estimatedFee: '0.00042',\n      estimatedFeeUsd: null,\n      symbol,\n      error: 'Failed to fetch gas price',\n    };\n  }\n}\n\nfunction SendTab({ chains, wallets, initialChainId, initialTokenId }: { chains: Chain[]; wallets: Wallet[]; initialChainId?: string; initialTokenId?: string }) {\n  const { setShowPinModal, setPinAction, setPendingTransaction, topAssets, enabledAssetIds, tokenBalances, customTokenBalances } = useWallet();\n  const [selectedChainId, setSelectedChainId] = useState<string>(initialChainId || \"\");\n  const [selectedTokenId, setSelectedTokenId] = useState<string>(initialTokenId || \"native\");\n  const isTokenLocked = !!initialTokenId;\n  const [tokenOptions, setTokenOptions] = useState<TokenOption[]>([]);\n  const [toAddress, setToAddress] = useState(\"\");\n  const [amount, setAmount] = useState(\"\");\n  const [error, setError] = useState(\"\");\n\n  console.log(\"[SendTab] initialChainId:\", initialChainId, \"selectedChainId:\", selectedChainId, \"chains.length:\", chains.length);\n\n  const selectedChain = chains.find((c) => c.id === selectedChainId);\n  const selectedWallet = wallets.find((w) => w.chainId === selectedChainId);\n  const selectedToken = tokenOptions.find(t => t.id === selectedTokenId) || tokenOptions[0];\n\n  const isNativeToken = selectedToken?.isNative ?? true;\n  const isMobile = Capacitor.isNativePlatform();\n  \n  // Non-EVM chains - determined by chain symbol (more reliable than hardcoded IDs)\n  const NON_EVM_SYMBOLS = new Set(['BTC', 'SOL', 'TRX', 'XRP', 'DOGE', 'LTC', 'BCH', 'ADA', 'ATOM', 'OSMO', 'DOT']);\n  const isNonEvmChain = selectedChain ? NON_EVM_SYMBOLS.has(selectedChain.symbol) : false;\n  \n  const { data: gasEstimate, isLoading: gasLoading } = useQuery<GasEstimate>({\n    queryKey: [\"/api/gas-estimate\", selectedChainId, isNativeToken, isMobile, isNonEvmChain, selectedChain?.symbol],\n    queryFn: async () => {\n      // Non-EVM chains always use client-side static fees\n      if (isNonEvmChain) {\n        return fetchClientSideGasEstimate(selectedChainId, isNativeToken, selectedChain?.symbol);\n      }\n      // On mobile, use client-side gas estimation (no backend available)\n      if (isMobile) {\n        return fetchClientSideGasEstimate(selectedChainId, isNativeToken, selectedChain?.symbol);\n      }\n      // On desktop for EVM chains, use backend API\n      const response = await fetch(`/api/gas-estimate?chainId=${selectedChainId}&isNative=${isNativeToken}`);\n      return response.json();\n    },\n    enabled: !!selectedChainId && !!selectedChain,\n    refetchInterval: 30000,\n  });\n\n  // Update selected chain when initialChainId changes (e.g., user clicks different chain's Send button)\n  useEffect(() => {\n    console.log(\"[SendTab useEffect] initialChainId:\", initialChainId, \"chains.length:\", chains.length, \"current selectedChainId:\", selectedChainId);\n    if (initialChainId && chains.find(c => c.id === initialChainId)) {\n      console.log(\"[SendTab useEffect] Setting selectedChainId to initialChainId:\", initialChainId);\n      setSelectedChainId(initialChainId);\n    } else if (chains.length > 0 && !selectedChainId) {\n      console.log(\"[SendTab useEffect] Defaulting to first chain:\", chains[0].id);\n      setSelectedChainId(chains[0].id);\n    }\n  }, [chains, initialChainId]);\n\n  // Load custom tokens when chain or wallet changes\n  useEffect(() => {\n    async function loadTokenOptions() {\n      if (!selectedChain || !selectedWallet) {\n        setTokenOptions([]);\n        return;\n      }\n\n      // Start with native token\n      const options: TokenOption[] = [{\n        id: \"native\",\n        symbol: selectedChain.symbol,\n        name: selectedChain.name,\n        balance: selectedWallet.balance,\n        isNative: true,\n      }];\n\n      // Add standard tokens from topAssets that match this chain\n      const chainSymbol = selectedChain.symbol;\n      topAssets.forEach(asset => {\n        const parentChainSymbol = TOKEN_PARENT_CHAIN_SYMBOL[asset.id];\n        if (parentChainSymbol === chainSymbol && enabledAssetIds.has(asset.id)) {\n          const balance = tokenBalances[asset.id] || \"0\";\n          options.push({\n            id: asset.id,\n            symbol: asset.symbol.toUpperCase(),\n            name: asset.name,\n            balance,\n            isNative: false,\n            image: asset.image,\n          });\n        }\n      });\n\n      // Load wallet-specific custom tokens\n      try {\n        const customTokens = await clientStorage.getCustomTokens();\n        const walletTokens = customTokens.filter(token => \n          token.chainId === selectedChainId && \n          (token.walletId === selectedWallet.id || !token.walletId)\n        );\n\n        for (const token of walletTokens) {\n          const balance = customTokenBalances[token.id] || \"0\";\n          options.push({\n            id: token.id,\n            symbol: token.symbol,\n            name: token.name,\n            balance,\n            isNative: false,\n            contractAddress: token.contractAddress,\n            decimals: token.decimals,\n            image: token.image,\n          });\n        }\n      } catch (err) {\n        console.error(\"Failed to load custom tokens:\", err);\n      }\n\n      setTokenOptions(options);\n      // Only reset to native if no initialTokenId is provided\n      if (!initialTokenId) {\n        setSelectedTokenId(\"native\");\n      }\n    }\n\n    loadTokenOptions();\n  }, [selectedChainId, selectedChain, selectedWallet, initialTokenId, topAssets, enabledAssetIds, tokenBalances, customTokenBalances]);\n\n  const handleSend = () => {\n    setError(\"\");\n\n    if (!toAddress) {\n      setError(\"Please enter a recipient address\");\n      return;\n    }\n\n    if (!amount || parseFloat(amount) <= 0) {\n      setError(\"Please enter a valid amount\");\n      return;\n    }\n\n    const balance = parseFloat(selectedToken?.balance || \"0\");\n    if (parseFloat(amount) > balance) {\n      setError(\"Insufficient balance\");\n      return;\n    }\n\n    setPendingTransaction({\n      toAddress,\n      amount,\n      chainId: selectedChainId,\n      tokenSymbol: selectedToken?.symbol,\n      tokenContractAddress: selectedToken?.contractAddress,\n      isNativeToken: selectedToken?.isNative ?? true,\n    });\n    setPinAction(\"sign\");\n    setShowPinModal(true);\n  };\n\n  const handleMaxAmount = () => {\n    if (selectedToken) {\n      setAmount(selectedToken.balance);\n    }\n  };\n\n  const handleChainChange = (chainId: string) => {\n    setSelectedChainId(chainId);\n    setSelectedTokenId(\"native\");\n    setAmount(\"\");\n  };\n\n  return (\n    <div className=\"space-y-6\">\n      {!initialChainId && (\n        <div className=\"space-y-2\">\n          <Label htmlFor=\"chain\">Network</Label>\n          <Select value={selectedChainId} onValueChange={handleChainChange}>\n            <SelectTrigger id=\"chain\" data-testid=\"select-send-chain\">\n              <SelectValue placeholder=\"Select network\" />\n            </SelectTrigger>\n            <SelectContent>\n              {chains.map((chain) => {\n                const wallet = wallets.find((w) => w.chainId === chain.id);\n                return (\n                  <SelectItem key={chain.id} value={chain.id}>\n                    <div className=\"flex items-center gap-2\">\n                      <ChainIcon symbol={chain.symbol} iconColor={chain.iconColor} size=\"sm\" />\n                      <span>{chain.name}</span>\n                      <span className=\"text-muted-foreground\">\n                        ({formatBalance(wallet?.balance || \"0\")} {chain.symbol})\n                      </span>\n                    </div>\n                  </SelectItem>\n                );\n              })}\n            </SelectContent>\n          </Select>\n        </div>\n      )}\n\n      <div className=\"space-y-2\">\n        <Label htmlFor=\"token\">Coin / Token {isTokenLocked && <span className=\"text-xs text-muted-foreground\">(locked)</span>}</Label>\n        <Select value={selectedTokenId} onValueChange={setSelectedTokenId} disabled={isTokenLocked}>\n          <SelectTrigger id=\"token\" data-testid=\"select-send-token\" className={isTokenLocked ? \"opacity-70\" : \"\"}>\n            <SelectValue placeholder=\"Select coin or token\" />\n          </SelectTrigger>\n          <SelectContent>\n            {tokenOptions.map((token) => (\n              <SelectItem key={token.id} value={token.id}>\n                <div className=\"flex items-center gap-2\">\n                  {token.isNative ? (\n                    <ChainIcon symbol={token.symbol} size=\"sm\" />\n                  ) : token.image ? (\n                    <img \n                      src={token.image} \n                      alt={token.symbol} \n                      className=\"h-5 w-5 rounded-full object-cover\"\n                      onError={(e) => {\n                        (e.target as HTMLImageElement).style.display = 'none';\n                      }}\n                    />\n                  ) : (\n                    <Coins className=\"h-4 w-4 text-muted-foreground\" />\n                  )}\n                  <span>{token.symbol}</span>\n                  <span className=\"text-muted-foreground\">\n                    {token.name}\n                  </span>\n                  <span className=\"text-xs text-muted-foreground\">\n                    ({formatBalance(token.balance)})\n                  </span>\n                </div>\n              </SelectItem>\n            ))}\n          </SelectContent>\n        </Select>\n      </div>\n\n      <div className=\"space-y-2\">\n        <Label htmlFor=\"recipient\">Recipient Address</Label>\n        <Input\n          id=\"recipient\"\n          placeholder={getAddressPlaceholder(selectedChain?.symbol)}\n          value={toAddress}\n          onChange={(e) => setToAddress(e.target.value)}\n          className=\"font-mono\"\n          data-testid=\"input-recipient-address\"\n        />\n      </div>\n\n      <div className=\"space-y-2\">\n        <div className=\"flex items-center justify-between gap-2\">\n          <Label htmlFor=\"amount\">Amount</Label>\n          <Button \n            type=\"button\"\n            variant=\"ghost\" \n            size=\"sm\" \n            className=\"h-auto py-0 text-xs\"\n            onClick={handleMaxAmount}\n            data-testid=\"button-max-amount\"\n          >\n            Max: {formatBalance(selectedToken?.balance || \"0\")} {selectedToken?.symbol || selectedChain?.symbol}\n          </Button>\n        </div>\n        <div className=\"relative\">\n          <Input\n            id=\"amount\"\n            type=\"number\"\n            placeholder=\"0.00\"\n            value={amount}\n            onChange={(e) => setAmount(e.target.value)}\n            className=\"pr-16\"\n            data-testid=\"input-send-amount\"\n          />\n          <span className=\"absolute right-3 top-1/2 -translate-y-1/2 text-sm text-muted-foreground\">\n            {selectedToken?.symbol || selectedChain?.symbol}\n          </span>\n        </div>\n      </div>\n\n      {error && (\n        <Alert variant=\"destructive\">\n          <AlertCircle className=\"h-4 w-4\" />\n          <AlertDescription>{error}</AlertDescription>\n        </Alert>\n      )}\n\n      <div className=\"rounded-lg bg-muted/50 p-4\">\n        <div className=\"flex items-center justify-between gap-2 text-sm\">\n          <span className=\"text-muted-foreground\">Gas Price</span>\n          {gasLoading ? (\n            <Skeleton className=\"h-4 w-16\" />\n          ) : (\n            <span data-testid=\"text-gas-price\">\n              {isNonEvmChain \n                ? 'Fixed fee' \n                : gasEstimate?.gasPriceGwei && gasEstimate.gasPriceGwei !== 'N/A' \n                  ? `${gasEstimate.gasPriceGwei} Gwei` \n                  : '~20 Gwei'}\n            </span>\n          )}\n        </div>\n        <div className=\"mt-2 flex items-center justify-between gap-2 text-sm\">\n          <span className=\"text-muted-foreground\">Estimated Gas Fee</span>\n          {gasLoading ? (\n            <Skeleton className=\"h-4 w-20\" />\n          ) : (\n            <span data-testid=\"text-gas-fee\">\n              ~{gasEstimate?.estimatedFee || \"0.00042\"} {selectedChain?.symbol}\n            </span>\n          )}\n        </div>\n        <div className=\"mt-2 flex items-center justify-between gap-2 text-sm\">\n          <span className=\"text-muted-foreground\">Total</span>\n          {gasLoading ? (\n            <Skeleton className=\"h-4 w-24\" />\n          ) : (\n            <span className=\"font-medium\" data-testid=\"text-total-amount\">\n              {isNativeToken ? (\n                // Native token: amount + gas fee (both in same currency)\n                <>\n                  {amount \n                    ? (parseFloat(amount) + parseFloat(gasEstimate?.estimatedFee || \"0\")).toFixed(6) \n                    : \"0.00\"} {selectedChain?.symbol}\n                </>\n              ) : (\n                // Token transfer: show amount in token + gas fee in native\n                <>\n                  {amount || \"0\"} {selectedToken?.symbol} + ~{gasEstimate?.estimatedFee || \"0\"} {selectedChain?.symbol}\n                </>\n              )}\n            </span>\n          )}\n        </div>\n        {gasEstimate?.error && (\n          <p className=\"mt-2 text-xs text-muted-foreground\">\n            Using estimated values (live data unavailable)\n          </p>\n        )}\n      </div>\n\n      <Button \n        type=\"button\"\n        className=\"w-full\" \n        size=\"lg\"\n        onClick={handleSend}\n        disabled={!toAddress || !amount}\n        data-testid=\"button-sign-transaction\"\n      >\n        <Shield className=\"mr-2 h-4 w-4\" />\n        Sign & Send Transaction\n      </Button>\n\n      <p className=\"text-center text-xs text-muted-foreground\">\n        You will need to enter your PIN to authorize this transaction\n      </p>\n    </div>\n  );\n}\n\nfunction ReceiveTab({ chains, wallets, initialChainId }: { chains: Chain[]; wallets: Wallet[]; initialChainId?: string }) {\n  const { toast } = useToast();\n  const [selectedChainId, setSelectedChainId] = useState<string>(initialChainId || \"\");\n\n  const selectedChain = chains.find((c) => c.id === selectedChainId);\n  const selectedWallet = wallets.find((w) => w.chainId === selectedChainId);\n\n  // Update selected chain when initialChainId changes (e.g., user clicks different chain's Receive button)\n  useEffect(() => {\n    if (initialChainId && chains.find(c => c.id === initialChainId)) {\n      setSelectedChainId(initialChainId);\n    } else if (chains.length > 0 && !selectedChainId) {\n      setSelectedChainId(chains[0].id);\n    }\n  }, [chains, initialChainId]);\n\n  const copyAddress = () => {\n    if (selectedWallet) {\n      navigator.clipboard.writeText(selectedWallet.address);\n      toast({\n        title: \"Address Copied\",\n        description: \"Wallet address copied to clipboard.\",\n      });\n    }\n  };\n\n  return (\n    <div className=\"space-y-6\">\n      <div className=\"space-y-2\">\n        <Label htmlFor=\"receive-chain\">Network</Label>\n        <Select value={selectedChainId} onValueChange={setSelectedChainId}>\n          <SelectTrigger id=\"receive-chain\" data-testid=\"select-receive-chain\">\n            <SelectValue placeholder=\"Select network\" />\n          </SelectTrigger>\n          <SelectContent>\n            {chains.map((chain) => (\n              <SelectItem key={chain.id} value={chain.id}>\n                <div className=\"flex items-center gap-2\">\n                  <ChainIcon symbol={chain.symbol} iconColor={chain.iconColor} size=\"sm\" />\n                  <span>{chain.name}</span>\n                </div>\n              </SelectItem>\n            ))}\n          </SelectContent>\n        </Select>\n      </div>\n\n      <div className=\"flex flex-col items-center justify-center py-6\">\n        <div className=\"mb-6 flex h-64 w-64 items-center justify-center rounded-xl bg-white p-4\">\n          {selectedWallet ? (\n            <QRCodeSVG \n              value={selectedWallet.address} \n              size={224}\n              level=\"M\"\n              includeMargin={false}\n              data-testid=\"qr-code-address\"\n            />\n          ) : (\n            <div className=\"text-center\">\n              <QrCode className=\"mx-auto h-32 w-32 text-muted-foreground/50\" />\n              <p className=\"mt-2 text-sm text-muted-foreground\">Select a network</p>\n            </div>\n          )}\n        </div>\n\n        {selectedWallet && (\n          <>\n            <div className=\"mb-4 text-center\">\n              <p className=\"text-sm text-muted-foreground mb-1\">Your {selectedChain?.name} Address</p>\n              <code className=\"block rounded-lg bg-muted/50 px-4 py-3 font-mono text-sm break-all\">\n                {selectedWallet.address}\n              </code>\n            </div>\n\n            <div className=\"flex gap-2\">\n              <Button type=\"button\" variant=\"outline\" onClick={copyAddress} data-testid=\"button-copy-receive-address\">\n                <Copy className=\"mr-2 h-4 w-4\" />\n                Copy Address\n              </Button>\n            </div>\n          </>\n        )}\n      </div>\n\n      <Alert>\n        <AlertCircle className=\"h-4 w-4\" />\n        <AlertDescription>\n          Only send {selectedChain?.symbol} and tokens on the {selectedChain?.name} network to this address. Sending other assets may result in permanent loss.\n        </AlertDescription>\n      </Alert>\n    </div>\n  );\n}\n\nexport default function Transfer() {\n  const { isConnected, isUnlocked, chains, wallets, visibleWallets, walletMode, refreshBalances } = useWallet();\n  \n  // Use visibleWallets for hard wallet mode to ensure proper data display\n  const displayWallets = walletMode === \"hard_wallet\" ? visibleWallets : wallets;\n  \n  // Track URL search string reactively using window events\n  const [searchString, setSearchString] = useState(() => window.location.search);\n  \n  // Listen for URL changes (popstate for back/forward, and custom event for Link navigation)\n  useEffect(() => {\n    const updateSearch = () => {\n      setSearchString(window.location.search);\n    };\n    \n    // popstate fires on back/forward navigation\n    window.addEventListener('popstate', updateSearch);\n    \n    // Check for search string changes on every render (handles Link navigation)\n    updateSearch();\n    \n    return () => {\n      window.removeEventListener('popstate', updateSearch);\n    };\n  }, []);\n  \n  // Also check on any navigation by using an interval briefly or checking regularly\n  // This is needed because wouter's Link doesn't fire popstate\n  useEffect(() => {\n    const checkInterval = setInterval(() => {\n      if (window.location.search !== searchString) {\n        setSearchString(window.location.search);\n      }\n    }, 100);\n    \n    return () => clearInterval(checkInterval);\n  }, [searchString]);\n  \n  const queryParams = new URLSearchParams(searchString);\n  const defaultTab = queryParams.get(\"type\") === \"receive\" ? \"receive\" : \"send\";\n  const chainParam = queryParams.get(\"chain\") || undefined;\n  const tokenParam = queryParams.get(\"token\") || undefined;\n  const [activeTab, setActiveTab] = useState(defaultTab);\n  \n  // Update active tab when query params change\n  useEffect(() => {\n    const params = new URLSearchParams(searchString);\n    const typeParam = params.get(\"type\");\n    if (typeParam === \"receive\" || typeParam === \"send\") {\n      setActiveTab(typeParam);\n    }\n  }, [searchString]);\n  \n  console.log(\"[Transfer] chainParam:\", chainParam, \"search:\", searchString);\n\n  // Track if we've already refreshed balances on this page load\n  const hasRefreshedRef = useRef(false);\n  \n  // Refresh balances once when page loads in hard wallet mode\n  useEffect(() => {\n    if (walletMode === \"hard_wallet\" && displayWallets.length > 0 && !hasRefreshedRef.current) {\n      hasRefreshedRef.current = true;\n      refreshBalances();\n    }\n  }, [walletMode, displayWallets.length, refreshBalances]);\n\n  if (displayWallets.length === 0) {\n    return (\n      <div className=\"p-6\">\n        <h1 className=\"mb-6 text-3xl font-bold\">Send / Receive</h1>\n        <HardwareStatusCard />\n      </div>\n    );\n  }\n\n  return (\n    <div className=\"p-6\">\n      <div className=\"mb-6 flex items-center gap-3\">\n        <BackButton />\n        <h1 className=\"text-3xl font-bold\">Send / Receive</h1>\n      </div>\n\n      <Card className=\"max-w-lg mx-auto\">\n        <CardContent className=\"p-6\">\n          <Tabs value={activeTab} onValueChange={setActiveTab}>\n            <TabsList className=\"grid w-full grid-cols-2 mb-6\">\n              <TabsTrigger value=\"send\" data-testid=\"tab-send\">\n                <ArrowUpRight className=\"mr-2 h-4 w-4\" />\n                Send\n              </TabsTrigger>\n              <TabsTrigger value=\"receive\" data-testid=\"tab-receive\">\n                <ArrowDownLeft className=\"mr-2 h-4 w-4\" />\n                Receive\n              </TabsTrigger>\n            </TabsList>\n\n            <TabsContent value=\"send\">\n              <SendTab key={`send-${chainParam}-${tokenParam}`} chains={chains} wallets={displayWallets} initialChainId={chainParam} initialTokenId={tokenParam} />\n            </TabsContent>\n\n            <TabsContent value=\"receive\">\n              <ReceiveTab key={`receive-${chainParam}`} chains={chains} wallets={displayWallets} initialChainId={chainParam} />\n            </TabsContent>\n          </Tabs>\n        </CardContent>\n      </Card>\n    </div>\n  );\n}\n","path":null,"size_bytes":27625,"size_tokens":null},"client/src/components/ui/scroll-area.tsx":{"content":"import * as React from \"react\"\nimport * as ScrollAreaPrimitive from \"@radix-ui/react-scroll-area\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst ScrollArea = React.forwardRef<\n  React.ElementRef<typeof ScrollAreaPrimitive.Root>,\n  React.ComponentPropsWithoutRef<typeof ScrollAreaPrimitive.Root>\n>(({ className, children, ...props }, ref) => (\n  <ScrollAreaPrimitive.Root\n    ref={ref}\n    className={cn(\"relative overflow-hidden\", className)}\n    {...props}\n  >\n    <ScrollAreaPrimitive.Viewport className=\"h-full w-full rounded-[inherit]\">\n      {children}\n    </ScrollAreaPrimitive.Viewport>\n    <ScrollBar />\n    <ScrollAreaPrimitive.Corner />\n  </ScrollAreaPrimitive.Root>\n))\nScrollArea.displayName = ScrollAreaPrimitive.Root.displayName\n\nconst ScrollBar = React.forwardRef<\n  React.ElementRef<typeof ScrollAreaPrimitive.ScrollAreaScrollbar>,\n  React.ComponentPropsWithoutRef<typeof ScrollAreaPrimitive.ScrollAreaScrollbar>\n>(({ className, orientation = \"vertical\", ...props }, ref) => (\n  <ScrollAreaPrimitive.ScrollAreaScrollbar\n    ref={ref}\n    orientation={orientation}\n    className={cn(\n      \"flex touch-none select-none transition-colors\",\n      orientation === \"vertical\" &&\n        \"h-full w-2.5 border-l border-l-transparent p-[1px]\",\n      orientation === \"horizontal\" &&\n        \"h-2.5 flex-col border-t border-t-transparent p-[1px]\",\n      className\n    )}\n    {...props}\n  >\n    <ScrollAreaPrimitive.ScrollAreaThumb className=\"relative flex-1 rounded-full bg-border\" />\n  </ScrollAreaPrimitive.ScrollAreaScrollbar>\n))\nScrollBar.displayName = ScrollAreaPrimitive.ScrollAreaScrollbar.displayName\n\nexport { ScrollArea, ScrollBar }\n","path":null,"size_bytes":1642,"size_tokens":null},"client/src/lib/pico-serial.ts":{"content":"type PicoCommand = {\n  action: string;\n  pin?: string;\n  seed?: string;\n  message?: string;\n};\n\ntype PicoResponse = {\n  success?: boolean;\n  error?: string;\n  message?: string;\n  has_wallet?: boolean;\n  unlocked?: boolean;\n  locked_out?: boolean;\n  lockout_remaining?: number;\n  seed?: string;\n  signature?: string;\n  pong?: boolean;\n};\n\nclass PicoSerial {\n  private port: SerialPort | null = null;\n  private reader: ReadableStreamDefaultReader<string> | null = null;\n  private writer: WritableStreamDefaultWriter<string> | null = null;\n  private connected: boolean = false;\n  private responseBuffer: string = \"\";\n  \n  async connect(): Promise<boolean> {\n    try {\n      if (!(\"serial\" in navigator)) {\n        throw new Error(\"Web Serial API not supported. Use Chrome or Edge browser.\");\n      }\n      \n      // Request port - Pico vendor ID 0x2E8A\n      this.port = await (navigator.serial as any).requestPort({\n        filters: [{ usbVendorId: 0x2E8A }]\n      });\n      \n      await this.port.open({ baudRate: 115200 });\n      \n      const textDecoder = new TextDecoderStream();\n      const textEncoder = new TextEncoderStream();\n      \n      this.port.readable?.pipeTo(textDecoder.writable);\n      textEncoder.readable.pipeTo(this.port.writable!);\n      \n      this.reader = textDecoder.readable.getReader();\n      this.writer = textEncoder.writable.getWriter();\n      \n      this.connected = true;\n      \n      // Start reading in background\n      this.readLoop();\n      \n      // Wait a moment for connection to stabilize\n      await this.delay(500);\n      \n      // Send a ping to verify connection\n      const pingResult = await this.sendCommand({ action: \"ping\" });\n      if (pingResult.pong) {\n        return true;\n      }\n      \n      return false;\n    } catch (error) {\n      console.error(\"Failed to connect to Pico:\", error);\n      this.connected = false;\n      throw error;\n    }\n  }\n  \n  async disconnect(): Promise<void> {\n    this.connected = false;\n    \n    if (this.reader) {\n      await this.reader.cancel();\n      this.reader = null;\n    }\n    \n    if (this.writer) {\n      await this.writer.close();\n      this.writer = null;\n    }\n    \n    if (this.port) {\n      await this.port.close();\n      this.port = null;\n    }\n  }\n  \n  isConnected(): boolean {\n    return this.connected && this.port !== null;\n  }\n  \n  private async readLoop(): Promise<void> {\n    while (this.connected && this.reader) {\n      try {\n        const { value, done } = await this.reader.read();\n        if (done) break;\n        if (value) {\n          this.responseBuffer += value;\n        }\n      } catch {\n        break;\n      }\n    }\n  }\n  \n  private delay(ms: number): Promise<void> {\n    return new Promise(resolve => setTimeout(resolve, ms));\n  }\n  \n  async sendCommand(command: PicoCommand): Promise<PicoResponse> {\n    if (!this.connected || !this.writer) {\n      throw new Error(\"Not connected to Pico\");\n    }\n    \n    // Clear response buffer\n    this.responseBuffer = \"\";\n    \n    // Send command as JSON\n    const cmdString = JSON.stringify(command) + \"\\r\\n\";\n    await this.writer.write(cmdString);\n    \n    // Wait for response (with timeout)\n    const timeout = 5000;\n    const startTime = Date.now();\n    \n    while (Date.now() - startTime < timeout) {\n      // Look for complete JSON response in buffer\n      const lines = this.responseBuffer.split(\"\\n\");\n      for (const line of lines) {\n        const trimmed = line.trim();\n        if (trimmed.startsWith(\"{\") && trimmed.endsWith(\"}\")) {\n          try {\n            const response = JSON.parse(trimmed) as PicoResponse;\n            this.responseBuffer = \"\";\n            return response;\n          } catch {\n            // Not valid JSON, continue waiting\n          }\n        }\n      }\n      await this.delay(50);\n    }\n    \n    throw new Error(\"Timeout waiting for Pico response\");\n  }\n  \n  async getStatus(): Promise<PicoResponse> {\n    return this.sendCommand({ action: \"status\" });\n  }\n  \n  async setup(pin: string, seed: string): Promise<PicoResponse> {\n    return this.sendCommand({ action: \"setup\", pin, seed });\n  }\n  \n  async unlock(pin: string): Promise<PicoResponse> {\n    return this.sendCommand({ action: \"unlock\", pin });\n  }\n  \n  async lock(): Promise<PicoResponse> {\n    return this.sendCommand({ action: \"lock\" });\n  }\n  \n  async sign(message: string, pin: string): Promise<PicoResponse> {\n    return this.sendCommand({ action: \"sign\", message, pin });\n  }\n  \n  async getSeed(pin: string): Promise<PicoResponse> {\n    return this.sendCommand({ action: \"get_seed\", pin });\n  }\n  \n  async reset(pin: string): Promise<PicoResponse> {\n    return this.sendCommand({ action: \"reset\", pin });\n  }\n}\n\n// Singleton instance\nexport const picoSerial = new PicoSerial();\n\n// Helper to check if Web Serial is supported\nexport function isWebSerialSupported(): boolean {\n  return \"serial\" in navigator;\n}\n","path":null,"size_bytes":4871,"size_tokens":null},"client/src/hooks/use-leads.ts":{"content":"import { useMutation } from \"@tanstack/react-query\";\nimport { api, type InsertLead } from \"@shared/routes\";\nimport { useToast } from \"@/hooks/use-toast\";\n\nexport function useCreateLead() {\n  const { toast } = useToast();\n\n  return useMutation({\n    mutationFn: async (data: InsertLead) => {\n      const validated = api.leads.create.input.parse(data);\n      const res = await fetch(api.leads.create.path, {\n        method: api.leads.create.method,\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify(validated),\n      });\n\n      if (!res.ok) {\n        if (res.status === 400) {\n          const error = api.leads.create.responses[400].parse(await res.json());\n          throw new Error(error.message);\n        }\n        throw new Error('Failed to join waitlist');\n      }\n\n      return api.leads.create.responses[201].parse(await res.json());\n    },\n    onSuccess: () => {\n      toast({\n        title: \"Registered.\",\n        description: \"We'll be in touch.\",\n        duration: 3000,\n      });\n    },\n    onError: (error) => {\n      toast({\n        title: \"Error\",\n        description: error.message,\n        variant: \"destructive\",\n      });\n    },\n  });\n}\n","path":null,"size_bytes":1190,"size_tokens":null},"client/src/components/mobile-footer.tsx":{"content":"import { useState } from \"react\";\nimport { useLocation, Link } from \"wouter\";\nimport { \n  Wallet, \n  Shield,\n  LayoutDashboard, \n  Settings, \n  Coins,\n  Link2,\n  Layers,\n  Users\n} from \"lucide-react\";\nimport { cn } from \"@/lib/utils\";\nimport { useWallet } from \"@/lib/wallet-context\";\nimport { Button } from \"@/components/ui/button\";\n\ninterface NavItem {\n  label: string;\n  href: string;\n  icon: React.ReactNode;\n}\n\nexport function MobileFooter() {\n  const [location] = useLocation();\n  const { walletMode, setWalletMode } = useWallet();\n\n  const softWalletNavItems: NavItem[] = [\n    { label: \"Chains\", href: \"/\", icon: <Layers className=\"h-5 w-5\" /> },\n    { label: \"DApps\", href: \"/dapps\", icon: <Link2 className=\"h-5 w-5\" /> },\n    { label: \"Settings\", href: \"/settings\", icon: <Settings className=\"h-5 w-5\" /> },\n  ];\n\n  const hardWalletNavItems: NavItem[] = [\n    { label: \"Dashboard\", href: \"/\", icon: <LayoutDashboard className=\"h-5 w-5\" /> },\n    { label: \"Accounts\", href: \"/chains\", icon: <Users className=\"h-5 w-5\" /> },\n    { label: \"Settings\", href: \"/settings\", icon: <Settings className=\"h-5 w-5\" /> },\n    { label: \"Manage\", href: \"/manage-crypto\", icon: <Coins className=\"h-5 w-5\" /> },\n  ];\n\n  const navItems = walletMode === \"soft_wallet\" ? softWalletNavItems : hardWalletNavItems;\n\n  const isActive = (href: string) => {\n    if (href === \"/\") return location === \"/\";\n    return location.startsWith(href);\n  };\n\n  return (\n    <div className=\"fixed bottom-0 left-0 right-0 z-50 border-t border-border bg-background md:hidden\">\n      <div className=\"flex items-center justify-center gap-2 border-b border-border/50 px-4 py-2\">\n        <Button\n          variant={walletMode === \"hard_wallet\" ? \"default\" : \"outline\"}\n          size=\"sm\"\n          className=\"flex-1 gap-2\"\n          onClick={() => setWalletMode(\"hard_wallet\")}\n          data-testid=\"button-hard-wallet-mode\"\n        >\n          <Shield className=\"h-4 w-4\" />\n          Hard Wallet\n        </Button>\n        <Button\n          variant={walletMode === \"soft_wallet\" ? \"default\" : \"outline\"}\n          size=\"sm\"\n          className=\"flex-1 gap-2\"\n          onClick={() => setWalletMode(\"soft_wallet\")}\n          data-testid=\"button-soft-wallet-mode\"\n        >\n          <Wallet className=\"h-4 w-4\" />\n          Soft Wallet\n        </Button>\n      </div>\n\n      <nav className=\"flex items-center justify-around px-2 py-2\">\n        {navItems.map((item) => (\n          <Link\n            key={item.href}\n            href={item.href}\n            className={cn(\n              \"flex flex-col items-center gap-1 rounded-lg px-4 py-2 text-xs transition-colors\",\n              isActive(item.href)\n                ? \"bg-primary/10 text-primary\"\n                : \"text-muted-foreground hover-elevate\"\n            )}\n            data-testid={`nav-${item.label.toLowerCase()}`}\n          >\n            {item.icon}\n            <span>{item.label}</span>\n          </Link>\n        ))}\n      </nav>\n    </div>\n  );\n}\n","path":null,"size_bytes":2982,"size_tokens":null},"drizzle.config.ts":{"content":"import { defineConfig } from \"drizzle-kit\";\n\nif (!process.env.DATABASE_URL) {\n  throw new Error(\"DATABASE_URL, ensure the database is provisioned\");\n}\n\nexport default defineConfig({\n  out: \"./migrations\",\n  schema: \"./shared/schema.ts\",\n  dialect: \"postgresql\",\n  dbCredentials: {\n    url: process.env.DATABASE_URL,\n  },\n});\n","path":null,"size_bytes":325,"size_tokens":null},"shared/schema.ts":{"content":"import { z } from \"zod\";\n\n// Hardware Device - represents the simulated hardware wallet\nexport const hardwareDeviceSchema = z.object({\n  id: z.string(),\n  name: z.string(),\n  pinHash: z.string(), // Encrypted PIN stored in \"hardware\"\n  pinLength: z.number().min(4).max(6),\n  seedPhrase: z.string(), // Encrypted seed phrase\n  isConnected: z.boolean(),\n  lastConnected: z.string().optional(),\n  createdAt: z.string(),\n});\n\nexport type HardwareDevice = z.infer<typeof hardwareDeviceSchema>;\n\nexport const insertHardwareDeviceSchema = hardwareDeviceSchema.omit({\n  id: true,\n  createdAt: true,\n});\n\nexport type InsertHardwareDevice = z.infer<typeof insertHardwareDeviceSchema>;\n\n// Blockchain Chain\nexport const chainSchema = z.object({\n  id: z.string(),\n  name: z.string(),\n  symbol: z.string(),\n  rpcUrl: z.string(),\n  chainId: z.number(),\n  blockExplorer: z.string().optional(),\n  iconColor: z.string(), // For UI display\n  isDefault: z.boolean(),\n  decimals: z.number().default(18),\n});\n\nexport type Chain = z.infer<typeof chainSchema>;\n\nexport const insertChainSchema = chainSchema.omit({\n  id: true,\n});\n\nexport type InsertChain = z.infer<typeof insertChainSchema>;\n\n// Token (ERC-20, BEP-20, etc.)\nexport const tokenSchema = z.object({\n  id: z.string(),\n  chainId: z.string(),\n  name: z.string(),\n  symbol: z.string(),\n  contractAddress: z.string(),\n  decimals: z.number().default(18),\n  iconColor: z.string().optional(),\n});\n\nexport type Token = z.infer<typeof tokenSchema>;\n\nexport const insertTokenSchema = tokenSchema.omit({\n  id: true,\n});\n\nexport type InsertToken = z.infer<typeof insertTokenSchema>;\n\n// Wallet - supports multiple wallets per chain via accountIndex\nexport const walletSchema = z.object({\n  id: z.string(),\n  deviceId: z.string(),\n  chainId: z.string(),\n  address: z.string(),\n  balance: z.string(), // Stored as string for precision\n  isActive: z.boolean(),\n  accountIndex: z.number().default(0), // BIP44 account index for multi-wallet support\n  label: z.string().optional(), // Optional user-defined label\n  walletGroupId: z.string().optional(), // Unique ID for independent seed group (undefined = uses primary seed)\n});\n\nexport type Wallet = z.infer<typeof walletSchema>;\n\nexport const insertWalletSchema = walletSchema.omit({\n  id: true,\n});\n\nexport type InsertWallet = z.infer<typeof insertWalletSchema>;\n\n// Transaction\nexport const transactionSchema = z.object({\n  id: z.string(),\n  walletId: z.string(),\n  chainId: z.string(),\n  type: z.enum([\"send\", \"receive\"]),\n  status: z.enum([\"pending\", \"confirmed\", \"failed\"]),\n  amount: z.string(),\n  tokenSymbol: z.string(),\n  toAddress: z.string(),\n  fromAddress: z.string(),\n  txHash: z.string().optional(),\n  gasUsed: z.string().optional(),\n  timestamp: z.string(),\n});\n\nexport type Transaction = z.infer<typeof transactionSchema>;\n\nexport const insertTransactionSchema = transactionSchema.omit({\n  id: true,\n});\n\nexport type InsertTransaction = z.infer<typeof insertTransactionSchema>;\n\n// PIN verification request\nexport const pinVerifySchema = z.object({\n  deviceId: z.string(),\n  pin: z.string().min(4).max(6),\n});\n\nexport type PinVerify = z.infer<typeof pinVerifySchema>;\n\n// Send transaction request\nexport const sendTransactionSchema = z.object({\n  deviceId: z.string(),\n  walletId: z.string(),\n  toAddress: z.string(),\n  amount: z.string(),\n  tokenSymbol: z.string().optional(),\n  pin: z.string().min(4).max(6),\n});\n\nexport type SendTransaction = z.infer<typeof sendTransactionSchema>;\n\n// Session state\nexport const sessionSchema = z.object({\n  deviceId: z.string().optional(),\n  isUnlocked: z.boolean(),\n  unlockExpiry: z.string().optional(),\n});\n\nexport type Session = z.infer<typeof sessionSchema>;\n\n// Default chains for the wallet\nexport const DEFAULT_CHAINS: Omit<Chain, \"id\">[] = [\n  {\n    name: \"Ethereum\",\n    symbol: \"ETH\",\n    rpcUrl: \"https://eth.llamarpc.com\",\n    chainId: 1,\n    blockExplorer: \"https://etherscan.io\",\n    iconColor: \"#627EEA\",\n    isDefault: true,\n    decimals: 18,\n  },\n  {\n    name: \"Bitcoin\",\n    symbol: \"BTC\",\n    rpcUrl: \"\",\n    chainId: 0,\n    blockExplorer: \"https://blockchain.com\",\n    iconColor: \"#F7931A\",\n    isDefault: true,\n    decimals: 8,\n  },\n  {\n    name: \"BNB Smart Chain\",\n    symbol: \"BNB\",\n    rpcUrl: \"https://bsc-dataseed.binance.org\",\n    chainId: 56,\n    blockExplorer: \"https://bscscan.com\",\n    iconColor: \"#F3BA2F\",\n    isDefault: true,\n    decimals: 18,\n  },\n  {\n    name: \"Polygon\",\n    symbol: \"MATIC\",\n    rpcUrl: \"https://polygon-rpc.com\",\n    chainId: 137,\n    blockExplorer: \"https://polygonscan.com\",\n    iconColor: \"#8247E5\",\n    isDefault: true,\n    decimals: 18,\n  },\n  {\n    name: \"Avalanche\",\n    symbol: \"AVAX\",\n    rpcUrl: \"https://api.avax.network/ext/bc/C/rpc\",\n    chainId: 43114,\n    blockExplorer: \"https://snowtrace.io\",\n    iconColor: \"#E84142\",\n    isDefault: true,\n    decimals: 18,\n  },\n  {\n    name: \"Arbitrum\",\n    symbol: \"ARB\",\n    rpcUrl: \"https://arb1.arbitrum.io/rpc\",\n    chainId: 42161,\n    blockExplorer: \"https://arbiscan.io\",\n    iconColor: \"#28A0F0\",\n    isDefault: true,\n    decimals: 18,\n  },\n  {\n    name: \"XRP\",\n    symbol: \"XRP\",\n    rpcUrl: \"\",\n    chainId: -2,\n    blockExplorer: \"https://xrpscan.com\",\n    iconColor: \"#23292F\",\n    isDefault: true,\n    decimals: 6,\n  },\n  {\n    name: \"Dogecoin\",\n    symbol: \"DOGE\",\n    rpcUrl: \"\",\n    chainId: -3,\n    blockExplorer: \"https://dogechain.info\",\n    iconColor: \"#C2A633\",\n    isDefault: true,\n    decimals: 8,\n  },\n  {\n    name: \"TRON\",\n    symbol: \"TRX\",\n    rpcUrl: \"\",\n    chainId: -5,\n    blockExplorer: \"https://tronscan.org\",\n    iconColor: \"#FF0013\",\n    isDefault: true,\n    decimals: 6,\n  },\n  {\n    name: \"Litecoin\",\n    symbol: \"LTC\",\n    rpcUrl: \"\",\n    chainId: -7,\n    blockExplorer: \"https://blockchair.com/litecoin\",\n    iconColor: \"#345D9D\",\n    isDefault: true,\n    decimals: 8,\n  },\n  {\n    name: \"Bitcoin Cash\",\n    symbol: \"BCH\",\n    rpcUrl: \"\",\n    chainId: -8,\n    blockExplorer: \"https://blockchair.com/bitcoin-cash\",\n    iconColor: \"#8DC351\",\n    isDefault: true,\n    decimals: 8,\n  },\n  {\n    name: \"Solana\",\n    symbol: \"SOL\",\n    rpcUrl: \"https://api.mainnet-beta.solana.com\",\n    chainId: -9,\n    blockExplorer: \"https://solscan.io\",\n    iconColor: \"#9945FF\",\n    isDefault: true,\n    decimals: 9,\n  },\n  {\n    name: \"Cardano\",\n    symbol: \"ADA\",\n    rpcUrl: \"\",\n    chainId: -10,\n    blockExplorer: \"https://cardanoscan.io\",\n    iconColor: \"#0033AD\",\n    isDefault: true,\n    decimals: 6,\n  },\n  {\n    name: \"Cosmos\",\n    symbol: \"ATOM\",\n    rpcUrl: \"https://cosmos-rpc.polkachu.com\",\n    chainId: -11,\n    blockExplorer: \"https://www.mintscan.io/cosmos\",\n    iconColor: \"#2E3148\",\n    isDefault: true,\n    decimals: 6,\n  },\n  {\n    name: \"Osmosis\",\n    symbol: \"OSMO\",\n    rpcUrl: \"https://osmosis-rpc.polkachu.com\",\n    chainId: -12,\n    blockExplorer: \"https://www.mintscan.io/osmosis\",\n    iconColor: \"#750BBB\",\n    isDefault: true,\n    decimals: 6,\n  },\n  {\n    name: \"Polkadot\",\n    symbol: \"DOT\",\n    rpcUrl: \"https://rpc.polkadot.io\",\n    chainId: -13,\n    blockExplorer: \"https://polkadot.subscan.io\",\n    iconColor: \"#E6007A\",\n    isDefault: true,\n    decimals: 10,\n  },\n];\n\n// Default USDT token configurations for multiple chains\nexport const DEFAULT_USDT_TOKENS: Omit<Token, \"id\">[] = [\n  {\n    chainId: \"eth\", // Will be replaced with actual chain ID\n    name: \"Tether USD\",\n    symbol: \"USDT\",\n    contractAddress: \"0xdAC17F958D2ee523a2206206994597C13D831ec7\",\n    decimals: 6,\n    iconColor: \"#26A17B\",\n  },\n  {\n    chainId: \"bnb\",\n    name: \"Tether USD (BSC)\",\n    symbol: \"USDT\",\n    contractAddress: \"0x55d398326f99059fF775485246999027B3197955\",\n    decimals: 18,\n    iconColor: \"#26A17B\",\n  },\n  {\n    chainId: \"matic\",\n    name: \"Tether USD (Polygon)\",\n    symbol: \"USDT\",\n    contractAddress: \"0xc2132D05D31c914a87C6611C10748AEb04B58e8F\",\n    decimals: 6,\n    iconColor: \"#26A17B\",\n  },\n  {\n    chainId: \"arb\",\n    name: \"Tether USD (Arbitrum)\",\n    symbol: \"USDT\",\n    contractAddress: \"0xFd086bC7CD5C481DCC9C85ebE478A1C0b69FCbb9\",\n    decimals: 6,\n    iconColor: \"#26A17B\",\n  },\n  {\n    chainId: \"trx\",\n    name: \"Tether USD (TRON)\",\n    symbol: \"USDT\",\n    contractAddress: \"TR7NHqjeKQxGTCi8q8ZY4pL8otSzgjLj6t\",\n    decimals: 6,\n    iconColor: \"#26A17B\",\n  },\n];\n\n// Legacy user schema for compatibility\nexport const users = {\n  id: \"\",\n  username: \"\",\n  password: \"\",\n};\n\nexport const insertUserSchema = z.object({\n  username: z.string(),\n  password: z.string(),\n});\n\nexport type InsertUser = z.infer<typeof insertUserSchema>;\nexport type User = { id: string; username: string; password: string };\n\n// Crypto Asset - represents a coin/token for the Manage Crypto feature\nexport const cryptoAssetSchema = z.object({\n  id: z.string(), // CoinGecko id\n  symbol: z.string(),\n  name: z.string(),\n  image: z.string().optional(),\n  currentPrice: z.number().optional(),\n  marketCap: z.number().optional(),\n  marketCapRank: z.number().optional(),\n  priceChangePercentage24h: z.number().optional(),\n});\n\nexport type CryptoAsset = z.infer<typeof cryptoAssetSchema>;\n\n// Static fallback list of top 20 crypto assets (by market cap as of 2024)\nexport const FALLBACK_TOP_ASSETS: CryptoAsset[] = [\n  { id: \"bitcoin\", symbol: \"BTC\", name: \"Bitcoin\", marketCapRank: 1, image: \"https://assets.coingecko.com/coins/images/1/small/bitcoin.png\" },\n  { id: \"ethereum\", symbol: \"ETH\", name: \"Ethereum\", marketCapRank: 2, image: \"https://assets.coingecko.com/coins/images/279/small/ethereum.png\" },\n  { id: \"tether\", symbol: \"USDT\", name: \"USDT (Ethereum)\", marketCapRank: 3, image: \"https://assets.coingecko.com/coins/images/325/small/Tether.png\" },\n  { id: \"tether-bsc\", symbol: \"USDT\", name: \"USDT (BNB Chain)\", marketCapRank: 4, image: \"https://assets.coingecko.com/coins/images/325/small/Tether.png\" },\n  { id: \"tether-tron\", symbol: \"USDT\", name: \"USDT (TRON)\", marketCapRank: 5, image: \"https://assets.coingecko.com/coins/images/325/small/Tether.png\" },\n  { id: \"binancecoin\", symbol: \"BNB\", name: \"BNB\", marketCapRank: 6, image: \"https://assets.coingecko.com/coins/images/825/small/bnb-icon2_2x.png\" },\n  { id: \"solana\", symbol: \"SOL\", name: \"Solana\", marketCapRank: 7, image: \"https://assets.coingecko.com/coins/images/4128/small/solana.png\" },\n  { id: \"usd-coin\", symbol: \"USDC\", name: \"USDC (Ethereum)\", marketCapRank: 8, image: \"https://assets.coingecko.com/coins/images/6319/small/usdc.png\" },\n  { id: \"usd-coin-bsc\", symbol: \"USDC\", name: \"USDC (BNB Chain)\", marketCapRank: 9, image: \"https://assets.coingecko.com/coins/images/6319/small/usdc.png\" },\n  { id: \"usd-coin-tron\", symbol: \"USDC\", name: \"USDC (TRON)\", marketCapRank: 10, image: \"https://assets.coingecko.com/coins/images/6319/small/usdc.png\" },\n  { id: \"ripple\", symbol: \"XRP\", name: \"XRP\", marketCapRank: 11, image: \"https://assets.coingecko.com/coins/images/44/small/xrp-symbol-white-128.png\" },\n  { id: \"staked-ether\", symbol: \"STETH\", name: \"Lido Staked Ether\", marketCapRank: 12, image: \"https://assets.coingecko.com/coins/images/13442/small/steth_logo.png\" },\n  { id: \"dogecoin\", symbol: \"DOGE\", name: \"Dogecoin\", marketCapRank: 13, image: \"https://assets.coingecko.com/coins/images/5/small/dogecoin.png\" },\n  { id: \"cardano\", symbol: \"ADA\", name: \"Cardano\", marketCapRank: 14, image: \"https://assets.coingecko.com/coins/images/975/small/cardano.png\" },\n  { id: \"tron\", symbol: \"TRX\", name: \"TRON\", marketCapRank: 15, image: \"https://assets.coingecko.com/coins/images/1094/small/tron-logo.png\" },\n  { id: \"avalanche-2\", symbol: \"AVAX\", name: \"Avalanche\", marketCapRank: 16, image: \"https://assets.coingecko.com/coins/images/12559/small/Avalanche_Circle_RedWhite_Trans.png\" },\n  { id: \"shiba-inu\", symbol: \"SHIB\", name: \"Shiba Inu\", marketCapRank: 17, image: \"https://assets.coingecko.com/coins/images/11939/small/shiba.png\" },\n  { id: \"chainlink\", symbol: \"LINK\", name: \"Chainlink\", marketCapRank: 18, image: \"https://assets.coingecko.com/coins/images/877/small/chainlink-new-logo.png\" },\n  { id: \"wrapped-bitcoin\", symbol: \"WBTC\", name: \"Wrapped Bitcoin\", marketCapRank: 19, image: \"https://assets.coingecko.com/coins/images/7598/small/wrapped_bitcoin_wbtc.png\" },\n  { id: \"polkadot\", symbol: \"DOT\", name: \"Polkadot\", marketCapRank: 20, image: \"https://assets.coingecko.com/coins/images/12171/small/polkadot.png\" },\n  { id: \"bitcoin-cash\", symbol: \"BCH\", name: \"Bitcoin Cash\", marketCapRank: 21, image: \"https://assets.coingecko.com/coins/images/780/small/bitcoin-cash-circle.png\" },\n  { id: \"matic-network\", symbol: \"MATIC\", name: \"Polygon\", marketCapRank: 22, image: \"https://assets.coingecko.com/coins/images/4713/small/polygon.png\" },\n  { id: \"litecoin\", symbol: \"LTC\", name: \"Litecoin\", marketCapRank: 23, image: \"https://assets.coingecko.com/coins/images/2/small/litecoin.png\" },\n  { id: \"uniswap\", symbol: \"UNI\", name: \"Uniswap\", marketCapRank: 24, image: \"https://assets.coingecko.com/coins/images/12504/small/uniswap-logo.png\" },\n  { id: \"cosmos\", symbol: \"ATOM\", name: \"Cosmos\", marketCapRank: 25, image: \"https://assets.coingecko.com/coins/images/1481/small/cosmos_hub.png\" },\n  { id: \"osmosis\", symbol: \"OSMO\", name: \"Osmosis\", marketCapRank: 26, image: \"https://assets.coingecko.com/coins/images/16724/small/osmo.png\" },\n  { id: \"dai\", symbol: \"DAI\", name: \"DAI\", marketCapRank: 27, image: \"https://assets.coingecko.com/coins/images/9956/small/Badge_Dai.png\" },\n  { id: \"aave\", symbol: \"AAVE\", name: \"Aave\", marketCapRank: 28, image: \"https://assets.coingecko.com/coins/images/12645/small/AAVE.png\" },\n  { id: \"maker\", symbol: \"MKR\", name: \"Maker\", marketCapRank: 29, image: \"https://assets.coingecko.com/coins/images/1364/small/maker.png\" },\n  { id: \"the-graph\", symbol: \"GRT\", name: \"The Graph\", marketCapRank: 30, image: \"https://assets.coingecko.com/coins/images/13397/small/Graph_Token.png\" },\n  { id: \"pancakeswap-token\", symbol: \"CAKE\", name: \"PancakeSwap\", marketCapRank: 31, image: \"https://assets-cdn.trustwallet.com/blockchains/smartchain/assets/0x0E09FaBB73Bd3Ade0a17ECC321fD13a19e81cE82/logo.png\" },\n  { id: \"venus\", symbol: \"XVS\", name: \"Venus\", marketCapRank: 32, image: \"https://assets-cdn.trustwallet.com/blockchains/smartchain/assets/0xcF6BB5389c92Bdda8a3747Ddb454cB7a64626C63/logo.png\" },\n  { id: \"trust-wallet-token\", symbol: \"TWT\", name: \"Trust Wallet Token\", marketCapRank: 33, image: \"https://assets-cdn.trustwallet.com/blockchains/smartchain/assets/0x4B0F1812e5Df2A09796481Ff14017e6005508003/logo.png\" },\n  { id: \"baby-doge-coin\", symbol: \"BABY\", name: \"Baby Doge Coin\", marketCapRank: 34, image: \"https://assets-cdn.trustwallet.com/blockchains/smartchain/assets/0xc748673057861a797275CD8A068AbB95A902e8de/logo.png\" },\n];\n","path":null,"size_bytes":14620,"size_tokens":null},"client/src/components/ui/navigation-menu.tsx":{"content":"import * as React from \"react\"\nimport * as NavigationMenuPrimitive from \"@radix-ui/react-navigation-menu\"\nimport { cva } from \"class-variance-authority\"\nimport { ChevronDown } from \"lucide-react\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst NavigationMenu = React.forwardRef<\n  React.ElementRef<typeof NavigationMenuPrimitive.Root>,\n  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.Root>\n>(({ className, children, ...props }, ref) => (\n  <NavigationMenuPrimitive.Root\n    ref={ref}\n    className={cn(\n      \"relative z-10 flex max-w-max flex-1 items-center justify-center\",\n      className\n    )}\n    {...props}\n  >\n    {children}\n    <NavigationMenuViewport />\n  </NavigationMenuPrimitive.Root>\n))\nNavigationMenu.displayName = NavigationMenuPrimitive.Root.displayName\n\nconst NavigationMenuList = React.forwardRef<\n  React.ElementRef<typeof NavigationMenuPrimitive.List>,\n  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.List>\n>(({ className, ...props }, ref) => (\n  <NavigationMenuPrimitive.List\n    ref={ref}\n    className={cn(\n      \"group flex flex-1 list-none items-center justify-center space-x-1\",\n      className\n    )}\n    {...props}\n  />\n))\nNavigationMenuList.displayName = NavigationMenuPrimitive.List.displayName\n\nconst NavigationMenuItem = NavigationMenuPrimitive.Item\n\nconst navigationMenuTriggerStyle = cva(\n  \"group inline-flex h-10 w-max items-center justify-center rounded-md bg-background px-4 py-2 text-sm font-medium transition-colors hover:bg-accent hover:text-accent-foreground focus:bg-accent focus:text-accent-foreground focus:outline-none disabled:pointer-events-none disabled:opacity-50 data-[state=open]:text-accent-foreground data-[state=open]:bg-accent/50 data-[state=open]:hover:bg-accent data-[state=open]:focus:bg-accent\"\n)\n\nconst NavigationMenuTrigger = React.forwardRef<\n  React.ElementRef<typeof NavigationMenuPrimitive.Trigger>,\n  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.Trigger>\n>(({ className, children, ...props }, ref) => (\n  <NavigationMenuPrimitive.Trigger\n    ref={ref}\n    className={cn(navigationMenuTriggerStyle(), \"group\", className)}\n    {...props}\n  >\n    {children}{\" \"}\n    <ChevronDown\n      className=\"relative top-[1px] ml-1 h-3 w-3 transition duration-200 group-data-[state=open]:rotate-180\"\n      aria-hidden=\"true\"\n    />\n  </NavigationMenuPrimitive.Trigger>\n))\nNavigationMenuTrigger.displayName = NavigationMenuPrimitive.Trigger.displayName\n\nconst NavigationMenuContent = React.forwardRef<\n  React.ElementRef<typeof NavigationMenuPrimitive.Content>,\n  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.Content>\n>(({ className, ...props }, ref) => (\n  <NavigationMenuPrimitive.Content\n    ref={ref}\n    className={cn(\n      \"left-0 top-0 w-full data-[motion^=from-]:animate-in data-[motion^=to-]:animate-out data-[motion^=from-]:fade-in data-[motion^=to-]:fade-out data-[motion=from-end]:slide-in-from-right-52 data-[motion=from-start]:slide-in-from-left-52 data-[motion=to-end]:slide-out-to-right-52 data-[motion=to-start]:slide-out-to-left-52 md:absolute md:w-auto \",\n      className\n    )}\n    {...props}\n  />\n))\nNavigationMenuContent.displayName = NavigationMenuPrimitive.Content.displayName\n\nconst NavigationMenuLink = NavigationMenuPrimitive.Link\n\nconst NavigationMenuViewport = React.forwardRef<\n  React.ElementRef<typeof NavigationMenuPrimitive.Viewport>,\n  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.Viewport>\n>(({ className, ...props }, ref) => (\n  <div className={cn(\"absolute left-0 top-full flex justify-center\")}>\n    <NavigationMenuPrimitive.Viewport\n      className={cn(\n        \"origin-top-center relative mt-1.5 h-[var(--radix-navigation-menu-viewport-height)] w-full overflow-hidden rounded-md border bg-popover text-popover-foreground shadow-lg data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-90 md:w-[var(--radix-navigation-menu-viewport-width)]\",\n        className\n      )}\n      ref={ref}\n      {...props}\n    />\n  </div>\n))\nNavigationMenuViewport.displayName =\n  NavigationMenuPrimitive.Viewport.displayName\n\nconst NavigationMenuIndicator = React.forwardRef<\n  React.ElementRef<typeof NavigationMenuPrimitive.Indicator>,\n  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.Indicator>\n>(({ className, ...props }, ref) => (\n  <NavigationMenuPrimitive.Indicator\n    ref={ref}\n    className={cn(\n      \"top-full z-[1] flex h-1.5 items-end justify-center overflow-hidden data-[state=visible]:animate-in data-[state=hidden]:animate-out data-[state=hidden]:fade-out data-[state=visible]:fade-in\",\n      className\n    )}\n    {...props}\n  >\n    <div className=\"relative top-[60%] h-2 w-2 rotate-45 rounded-tl-sm bg-border shadow-md\" />\n  </NavigationMenuPrimitive.Indicator>\n))\nNavigationMenuIndicator.displayName =\n  NavigationMenuPrimitive.Indicator.displayName\n\nexport {\n  navigationMenuTriggerStyle,\n  NavigationMenu,\n  NavigationMenuList,\n  NavigationMenuItem,\n  NavigationMenuContent,\n  NavigationMenuTrigger,\n  NavigationMenuLink,\n  NavigationMenuIndicator,\n  NavigationMenuViewport,\n}\n","path":null,"size_bytes":5128,"size_tokens":null},"client/src/components/ui/radio-group.tsx":{"content":"import * as React from \"react\"\nimport * as RadioGroupPrimitive from \"@radix-ui/react-radio-group\"\nimport { Circle } from \"lucide-react\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst RadioGroup = React.forwardRef<\n  React.ElementRef<typeof RadioGroupPrimitive.Root>,\n  React.ComponentPropsWithoutRef<typeof RadioGroupPrimitive.Root>\n>(({ className, ...props }, ref) => {\n  return (\n    <RadioGroupPrimitive.Root\n      className={cn(\"grid gap-2\", className)}\n      {...props}\n      ref={ref}\n    />\n  )\n})\nRadioGroup.displayName = RadioGroupPrimitive.Root.displayName\n\nconst RadioGroupItem = React.forwardRef<\n  React.ElementRef<typeof RadioGroupPrimitive.Item>,\n  React.ComponentPropsWithoutRef<typeof RadioGroupPrimitive.Item>\n>(({ className, ...props }, ref) => {\n  return (\n    <RadioGroupPrimitive.Item\n      ref={ref}\n      className={cn(\n        \"aspect-square h-4 w-4 rounded-full border border-primary text-primary ring-offset-background focus:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50\",\n        className\n      )}\n      {...props}\n    >\n      <RadioGroupPrimitive.Indicator className=\"flex items-center justify-center\">\n        <Circle className=\"h-2.5 w-2.5 fill-current text-current\" />\n      </RadioGroupPrimitive.Indicator>\n    </RadioGroupPrimitive.Item>\n  )\n})\nRadioGroupItem.displayName = RadioGroupPrimitive.Item.displayName\n\nexport { RadioGroup, RadioGroupItem }\n","path":null,"size_bytes":1467,"size_tokens":null},"server/storage.ts":{"content":"import { type User, type InsertUser } from \"@shared/schema\";\nimport { randomUUID } from \"crypto\";\n\n// modify the interface with any CRUD methods\n// you might need\n\nexport interface IStorage {\n  getUser(id: string): Promise<User | undefined>;\n  getUserByUsername(username: string): Promise<User | undefined>;\n  createUser(user: InsertUser): Promise<User>;\n}\n\nexport class MemStorage implements IStorage {\n  private users: Map<string, User>;\n\n  constructor() {\n    this.users = new Map();\n  }\n\n  async getUser(id: string): Promise<User | undefined> {\n    return this.users.get(id);\n  }\n\n  async getUserByUsername(username: string): Promise<User | undefined> {\n    return Array.from(this.users.values()).find(\n      (user) => user.username === username,\n    );\n  }\n\n  async createUser(insertUser: InsertUser): Promise<User> {\n    const id = randomUUID();\n    const user: User = { ...insertUser, id };\n    this.users.set(id, user);\n    return user;\n  }\n}\n\nexport const storage = new MemStorage();\n","path":null,"size_bytes":993,"size_tokens":null},"client/src/lib/queryClient.ts":{"content":"import { QueryClient, QueryFunction } from \"@tanstack/react-query\";\n\nasync function throwIfResNotOk(res: Response) {\n  if (!res.ok) {\n    const text = (await res.text()) || res.statusText;\n    throw new Error(`${res.status}: ${text}`);\n  }\n}\n\nexport async function apiRequest(\n  method: string,\n  url: string,\n  data?: unknown | undefined,\n): Promise<Response> {\n  const res = await fetch(url, {\n    method,\n    headers: data ? { \"Content-Type\": \"application/json\" } : {},\n    body: data ? JSON.stringify(data) : undefined,\n    credentials: \"include\",\n  });\n\n  await throwIfResNotOk(res);\n  return res;\n}\n\ntype UnauthorizedBehavior = \"returnNull\" | \"throw\";\nexport const getQueryFn: <T>(options: {\n  on401: UnauthorizedBehavior;\n}) => QueryFunction<T> =\n  ({ on401: unauthorizedBehavior }) =>\n  async ({ queryKey }) => {\n    const res = await fetch(queryKey.join(\"/\") as string, {\n      credentials: \"include\",\n    });\n\n    if (unauthorizedBehavior === \"returnNull\" && res.status === 401) {\n      return null;\n    }\n\n    await throwIfResNotOk(res);\n    return await res.json();\n  };\n\nexport const queryClient = new QueryClient({\n  defaultOptions: {\n    queries: {\n      queryFn: getQueryFn({ on401: \"throw\" }),\n      refetchInterval: false,\n      refetchOnWindowFocus: false,\n      staleTime: Infinity,\n      retry: false,\n    },\n    mutations: {\n      retry: false,\n    },\n  },\n});\n","path":null,"size_bytes":1383,"size_tokens":null},"server/routes.ts":{"content":"import type { Express } from \"express\";\nimport { createServer, type Server } from \"http\";\nimport { WebSocketServer, WebSocket } from \"ws\";\nimport { storage } from \"./storage\";\n\n// Bridge state for mobile-to-desktop Pico connection\ninterface BridgeSession {\n  desktopWs: WebSocket | null;\n  mobileWs: WebSocket | null;\n  sessionId: string;\n  createdAt: number;\n}\n\nconst bridgeSessions: Map<string, BridgeSession> = new Map();\n\nfunction generateSessionId(): string {\n  return Math.random().toString(36).substring(2, 8).toUpperCase();\n}\n\n// Chain RPC endpoints for gas estimation\nconst CHAIN_RPC_ENDPOINTS: Record<string, string> = {\n  'chain-0': 'https://eth.llamarpc.com',           // Ethereum\n  'chain-1': 'https://bitcoin.drpc.org',           // Bitcoin (not used for gas)\n  'chain-2': 'https://api.mainnet-beta.solana.com', // Solana\n  'chain-3': 'https://bsc-dataseed1.binance.org',  // BNB Chain\n  'chain-4': 'https://polygon-rpc.com',            // Polygon\n  'chain-5': 'https://api.avax.network/ext/bc/C/rpc', // Avalanche\n  'chain-6': 'https://arb1.arbitrum.io/rpc',       // Arbitrum\n  'chain-7': 'https://mainnet.optimism.io',        // Optimism\n  'chain-8': 'https://api.trongrid.io',            // TRON\n};\n\n// Default gas limits for native transfers\nconst DEFAULT_GAS_LIMITS: Record<string, number> = {\n  'chain-0': 21000, // Ethereum\n  'chain-3': 21000, // BNB Chain\n  'chain-4': 21000, // Polygon\n  'chain-5': 21000, // Avalanche\n  'chain-6': 21000, // Arbitrum\n  'chain-7': 21000, // Optimism\n};\n\n// Gas limits for ERC20 token transfers (higher due to contract interaction)\nconst TOKEN_GAS_LIMITS: Record<string, number> = {\n  'chain-0': 65000, // Ethereum ERC20\n  'chain-3': 65000, // BNB Chain BEP20\n  'chain-4': 65000, // Polygon ERC20\n  'chain-5': 65000, // Avalanche ERC20\n  'chain-6': 65000, // Arbitrum ERC20\n  'chain-7': 65000, // Optimism ERC20\n};\n\n// EVM chain IDs that support eth_gasPrice\nconst EVM_CHAINS = new Set(['chain-0', 'chain-3', 'chain-4', 'chain-5', 'chain-6', 'chain-7']);\n\nasync function fetchGasPrice(chainId: string): Promise<{ gasPriceWei: bigint; gasPriceGwei: string } | null> {\n  const rpcUrl = CHAIN_RPC_ENDPOINTS[chainId];\n  if (!rpcUrl) return null;\n\n  try {\n    // Only EVM chains support eth_gasPrice\n    if (EVM_CHAINS.has(chainId)) {\n      const response = await fetch(rpcUrl, {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify({\n          jsonrpc: '2.0',\n          method: 'eth_gasPrice',\n          params: [],\n          id: 1,\n        }),\n      });\n      \n      const data = await response.json();\n      if (data.result) {\n        const gasPriceWei = BigInt(data.result);\n        const gasPriceGwei = (Number(gasPriceWei) / 1e9).toFixed(2);\n        return { gasPriceWei, gasPriceGwei };\n      }\n    }\n  } catch (error) {\n    console.error(`Failed to fetch gas price for ${chainId}:`, error);\n  }\n  \n  return null;\n}\n\nexport async function registerRoutes(\n  httpServer: Server,\n  app: Express\n): Promise<Server> {\n  \n  // Gas estimate endpoint\n  app.get('/api/gas-estimate', async (req, res) => {\n    const chainId = req.query.chainId as string;\n    const isNative = req.query.isNative !== 'false'; // Default to true (native transfer)\n    \n    if (!chainId) {\n      return res.json({\n        gasPrice: '0',\n        gasPriceGwei: '20',\n        estimatedGas: '21000',\n        estimatedFee: '0.00042',\n        estimatedFeeUsd: null,\n        symbol: 'ETH',\n        error: 'No chain specified',\n      });\n    }\n\n    // Determine chain symbol\n    const chainSymbols: Record<string, string> = {\n      'chain-0': 'ETH',     // Ethereum\n      'chain-1': 'BTC',     // Bitcoin\n      'chain-2': 'SOL',     // Solana\n      'chain-3': 'BNB',     // BNB Chain\n      'chain-4': 'MATIC',   // Polygon\n      'chain-5': 'AVAX',    // Avalanche\n      'chain-6': 'ETH',     // Arbitrum (uses ETH)\n      'chain-7': 'ETH',     // Optimism (uses ETH)\n      'chain-8': 'TRX',     // TRON\n    };\n    const symbol = chainSymbols[chainId] || 'ETH';\n\n    // Fetch real gas price for EVM chains\n    const gasData = await fetchGasPrice(chainId);\n    \n    if (gasData) {\n      // Use higher gas limit for token transfers vs native transfers\n      const gasLimit = isNative \n        ? (DEFAULT_GAS_LIMITS[chainId] || 21000)\n        : (TOKEN_GAS_LIMITS[chainId] || 65000);\n      const estimatedFeeWei = gasData.gasPriceWei * BigInt(gasLimit);\n      const estimatedFee = (Number(estimatedFeeWei) / 1e18).toFixed(6);\n      \n      return res.json({\n        gasPrice: gasData.gasPriceWei.toString(),\n        gasPriceGwei: gasData.gasPriceGwei,\n        estimatedGas: gasLimit.toString(),\n        estimatedFee,\n        estimatedFeeUsd: null, // Would need price data to calculate\n        symbol,\n        isTokenTransfer: !isNative,\n      });\n    }\n\n    // Fallback for non-EVM chains or errors\n    const fallbackFees: Record<string, { fee: string; unit: string }> = {\n      'chain-1': { fee: '0.00001', unit: 'BTC' }, // Bitcoin\n      'chain-2': { fee: '0.000005', unit: 'SOL' }, // Solana\n      'chain-8': { fee: '0', unit: 'TRX' }, // TRON (free for most transfers)\n    };\n\n    const fallback = fallbackFees[chainId] || { fee: '0.0001', unit: symbol };\n    \n    return res.json({\n      gasPrice: '0',\n      gasPriceGwei: chainId === 'chain-0' || chainId === 'chain-3' ? '20' : 'N/A',\n      estimatedGas: DEFAULT_GAS_LIMITS[chainId]?.toString() || 'N/A',\n      estimatedFee: fallback.fee,\n      estimatedFeeUsd: null,\n      symbol: fallback.unit,\n      error: 'Using estimated values',\n    });\n  });\n\n  // Bridge session management API\n  app.post('/api/bridge/create', (req, res) => {\n    const sessionId = generateSessionId();\n    bridgeSessions.set(sessionId, {\n      desktopWs: null,\n      mobileWs: null,\n      sessionId,\n      createdAt: Date.now()\n    });\n    \n    // Clean up old sessions (older than 1 hour)\n    const oneHourAgo = Date.now() - 60 * 60 * 1000;\n    Array.from(bridgeSessions.entries()).forEach(([id, session]) => {\n      if (session.createdAt < oneHourAgo) {\n        bridgeSessions.delete(id);\n      }\n    });\n    \n    res.json({ sessionId });\n  });\n  \n  app.get('/api/bridge/status/:sessionId', (req, res) => {\n    const session = bridgeSessions.get(req.params.sessionId);\n    if (!session) {\n      return res.json({ exists: false });\n    }\n    res.json({\n      exists: true,\n      desktopConnected: session.desktopWs !== null && session.desktopWs.readyState === WebSocket.OPEN,\n      mobileConnected: session.mobileWs !== null && session.mobileWs.readyState === WebSocket.OPEN\n    });\n  });\n\n  // WebSocket server for bridge communication\n  const wss = new WebSocketServer({ server: httpServer, path: '/ws/bridge' });\n  \n  wss.on('connection', (ws, req) => {\n    const url = new URL(req.url || '', `http://${req.headers.host}`);\n    const sessionId = url.searchParams.get('sessionId');\n    const role = url.searchParams.get('role'); // 'desktop' or 'mobile'\n    \n    if (!sessionId || !role) {\n      ws.close(1008, 'Missing sessionId or role');\n      return;\n    }\n    \n    let session = bridgeSessions.get(sessionId);\n    if (!session) {\n      // Auto-create session for desktop\n      if (role === 'desktop') {\n        session = {\n          desktopWs: null,\n          mobileWs: null,\n          sessionId,\n          createdAt: Date.now()\n        };\n        bridgeSessions.set(sessionId, session);\n      } else {\n        ws.close(1008, 'Session not found');\n        return;\n      }\n    }\n    \n    if (role === 'desktop') {\n      session.desktopWs = ws;\n      // Notify mobile if connected\n      if (session.mobileWs && session.mobileWs.readyState === WebSocket.OPEN) {\n        session.mobileWs.send(JSON.stringify({ type: 'desktop_connected' }));\n      }\n    } else if (role === 'mobile') {\n      session.mobileWs = ws;\n      // Notify desktop if connected\n      if (session.desktopWs && session.desktopWs.readyState === WebSocket.OPEN) {\n        session.desktopWs.send(JSON.stringify({ type: 'mobile_connected' }));\n      }\n    }\n    \n    ws.on('message', (data) => {\n      try {\n        const message = JSON.parse(data.toString());\n        const currentSession = bridgeSessions.get(sessionId);\n        if (!currentSession) return;\n        \n        // Validate message has required fields\n        if (typeof message !== 'object' || !message.type) {\n          ws.send(JSON.stringify({ type: 'error', error: 'Invalid message format' }));\n          return;\n        }\n        \n        // Relay messages between desktop and mobile with role validation\n        if (role === 'desktop' && currentSession.mobileWs && currentSession.mobileWs.readyState === WebSocket.OPEN) {\n          currentSession.mobileWs.send(JSON.stringify({ ...message, from: 'desktop' }));\n        } else if (role === 'mobile' && currentSession.desktopWs && currentSession.desktopWs.readyState === WebSocket.OPEN) {\n          currentSession.desktopWs.send(JSON.stringify({ ...message, from: 'mobile' }));\n        } else if (role === 'mobile' && (!currentSession.desktopWs || currentSession.desktopWs.readyState !== WebSocket.OPEN)) {\n          // Desktop not connected - notify mobile\n          ws.send(JSON.stringify({ type: 'error', error: 'Desktop not connected' }));\n        }\n      } catch (e) {\n        console.error('Bridge message error:', e);\n        ws.send(JSON.stringify({ type: 'error', error: 'Failed to process message' }));\n      }\n    });\n    \n    ws.on('close', () => {\n      const currentSession = bridgeSessions.get(sessionId);\n      if (!currentSession) return;\n      \n      if (role === 'desktop') {\n        currentSession.desktopWs = null;\n        if (currentSession.mobileWs && currentSession.mobileWs.readyState === WebSocket.OPEN) {\n          currentSession.mobileWs.send(JSON.stringify({ type: 'desktop_disconnected' }));\n        }\n      } else if (role === 'mobile') {\n        currentSession.mobileWs = null;\n        if (currentSession.desktopWs && currentSession.desktopWs.readyState === WebSocket.OPEN) {\n          currentSession.desktopWs.send(JSON.stringify({ type: 'mobile_disconnected' }));\n        }\n      }\n      \n      // Clean up session when both peers disconnect\n      if (!currentSession.desktopWs && !currentSession.mobileWs) {\n        bridgeSessions.delete(sessionId);\n      }\n    });\n    \n    // Send connection confirmation\n    ws.send(JSON.stringify({ type: 'connected', role, sessionId }));\n  });\n\n  return httpServer;\n}\n","path":null,"size_bytes":10435,"size_tokens":null},"client/requirements.md":{"content":"## Packages\nframer-motion | Subtle entry animations for the text\nzod | Schema validation\nreact-hook-form | Form handling\n@hookform/resolvers | Zod resolver for forms\n\n## Notes\nAPI endpoints defined in shared/routes\nStyle direction: Minimalist plain text, raw aesthetic, no decorative elements\nFont: JetBrains Mono / Monospace for the raw feel\n","path":null,"size_bytes":343,"size_tokens":null},"tailwind.config.ts":{"content":"import type { Config } from \"tailwindcss\";\n\nexport default {\n  darkMode: [\"class\"],\n  content: [\"./client/index.html\", \"./client/src/**/*.{js,jsx,ts,tsx}\"],\n  theme: {\n    extend: {\n      borderRadius: {\n        lg: \".5625rem\", /* 9px */\n        md: \".375rem\", /* 6px */\n        sm: \".1875rem\", /* 3px */\n      },\n      colors: {\n        // Flat / base colors (regular buttons)\n        background: \"hsl(var(--background) / <alpha-value>)\",\n        foreground: \"hsl(var(--foreground) / <alpha-value>)\",\n        border: \"hsl(var(--border) / <alpha-value>)\",\n        input: \"hsl(var(--input) / <alpha-value>)\",\n        card: {\n          DEFAULT: \"hsl(var(--card) / <alpha-value>)\",\n          foreground: \"hsl(var(--card-foreground) / <alpha-value>)\",\n          border: \"hsl(var(--card-border) / <alpha-value>)\",\n        },\n        popover: {\n          DEFAULT: \"hsl(var(--popover) / <alpha-value>)\",\n          foreground: \"hsl(var(--popover-foreground) / <alpha-value>)\",\n          border: \"hsl(var(--popover-border) / <alpha-value>)\",\n        },\n        primary: {\n          DEFAULT: \"hsl(var(--primary) / <alpha-value>)\",\n          foreground: \"hsl(var(--primary-foreground) / <alpha-value>)\",\n          border: \"var(--primary-border)\",\n        },\n        secondary: {\n          DEFAULT: \"hsl(var(--secondary) / <alpha-value>)\",\n          foreground: \"hsl(var(--secondary-foreground) / <alpha-value>)\",\n          border: \"var(--secondary-border)\",\n        },\n        muted: {\n          DEFAULT: \"hsl(var(--muted) / <alpha-value>)\",\n          foreground: \"hsl(var(--muted-foreground) / <alpha-value>)\",\n          border: \"var(--muted-border)\",\n        },\n        accent: {\n          DEFAULT: \"hsl(var(--accent) / <alpha-value>)\",\n          foreground: \"hsl(var(--accent-foreground) / <alpha-value>)\",\n          border: \"var(--accent-border)\",\n        },\n        destructive: {\n          DEFAULT: \"hsl(var(--destructive) / <alpha-value>)\",\n          foreground: \"hsl(var(--destructive-foreground) / <alpha-value>)\",\n          border: \"var(--destructive-border)\",\n        },\n        ring: \"hsl(var(--ring) / <alpha-value>)\",\n        chart: {\n          \"1\": \"hsl(var(--chart-1) / <alpha-value>)\",\n          \"2\": \"hsl(var(--chart-2) / <alpha-value>)\",\n          \"3\": \"hsl(var(--chart-3) / <alpha-value>)\",\n          \"4\": \"hsl(var(--chart-4) / <alpha-value>)\",\n          \"5\": \"hsl(var(--chart-5) / <alpha-value>)\",\n        },\n        sidebar: {\n          ring: \"hsl(var(--sidebar-ring) / <alpha-value>)\",\n          DEFAULT: \"hsl(var(--sidebar) / <alpha-value>)\",\n          foreground: \"hsl(var(--sidebar-foreground) / <alpha-value>)\",\n          border: \"hsl(var(--sidebar-border) / <alpha-value>)\",\n        },\n        \"sidebar-primary\": {\n          DEFAULT: \"hsl(var(--sidebar-primary) / <alpha-value>)\",\n          foreground: \"hsl(var(--sidebar-primary-foreground) / <alpha-value>)\",\n          border: \"var(--sidebar-primary-border)\",\n        },\n        \"sidebar-accent\": {\n          DEFAULT: \"hsl(var(--sidebar-accent) / <alpha-value>)\",\n          foreground: \"hsl(var(--sidebar-accent-foreground) / <alpha-value>)\",\n          border: \"var(--sidebar-accent-border)\"\n        },\n        status: {\n          online: \"rgb(34 197 94)\",\n          away: \"rgb(245 158 11)\",\n          busy: \"rgb(239 68 68)\",\n          offline: \"rgb(156 163 175)\",\n        },\n      },\n      fontFamily: {\n        sans: [\"var(--font-sans)\"],\n        serif: [\"var(--font-serif)\"],\n        mono: [\"var(--font-mono)\"],\n      },\n      keyframes: {\n        \"accordion-down\": {\n          from: { height: \"0\" },\n          to: { height: \"var(--radix-accordion-content-height)\" },\n        },\n        \"accordion-up\": {\n          from: { height: \"var(--radix-accordion-content-height)\" },\n          to: { height: \"0\" },\n        },\n      },\n      animation: {\n        \"accordion-down\": \"accordion-down 0.2s ease-out\",\n        \"accordion-up\": \"accordion-up 0.2s ease-out\",\n      },\n    },\n  },\n  plugins: [require(\"tailwindcss-animate\"), require(\"@tailwindcss/typography\")],\n} satisfies Config;\n","path":null,"size_bytes":4050,"size_tokens":null},"client/src/lib/pi-wallet.ts":{"content":"declare global {\n  interface Navigator {\n    serial: Serial;\n  }\n  interface Serial {\n    requestPort(options?: { filters?: Array<{ usbVendorId: number }> }): Promise<SerialPort>;\n  }\n  interface SerialPort {\n    open(options: { baudRate: number }): Promise<void>;\n    close(): Promise<void>;\n    readable: ReadableStream<Uint8Array> | null;\n    writable: WritableStream<Uint8Array> | null;\n  }\n}\n\nexport interface PiWalletResponse {\n  success?: boolean;\n  error?: string;\n  message?: string;\n  has_wallet?: boolean;\n  unlocked?: boolean;\n  locked_out?: boolean;\n  lockout_remaining?: number;\n  seed?: string;\n  signature?: string;\n  pong?: boolean;\n  chains?: string[];\n}\n\nexport interface StoredChainPreference {\n  symbol: string;\n  accountIndex: number;\n  label?: string;\n}\n\nexport interface PiWalletStatus {\n  initialized: boolean;\n  locked: boolean;\n  has_seed: boolean;\n  device_name?: string;\n}\n\nclass PiWalletService {\n  private port: SerialPort | null = null;\n  private reader: ReadableStreamDefaultReader<Uint8Array> | null = null;\n  private writer: WritableStreamDefaultWriter<Uint8Array> | null = null;\n  private connected: boolean = false;\n  private readBuffer: string = \"\";\n  private responseResolver: ((value: PiWalletResponse) => void) | null = null;\n  private responseTimeout: ReturnType<typeof setTimeout> | null = null;\n  private currentPin: string | null = null;\n  private cachedSeed: string | null = null;\n\n  isWebSerialSupported(): boolean {\n    return typeof navigator !== \"undefined\" && \"serial\" in navigator;\n  }\n\n  async connect(): Promise<boolean> {\n    if (!this.isWebSerialSupported()) {\n      throw new Error(\"WebSerial is not supported in this browser. Please use Chrome or Edge.\");\n    }\n\n    // Clean up any previous connection attempt\n    await this.disconnect();\n\n    try {\n      // Show all serial devices (no filter) so user can select their Pico\n      this.port = await navigator.serial.requestPort();\n      await this.port.open({ baudRate: 115200 });\n\n      if (this.port.readable && this.port.writable) {\n        this.reader = this.port.readable.getReader();\n        this.writer = this.port.writable.getWriter();\n        this.connected = true;\n        this.startReading();\n        \n        await this.delay(500);\n        return true;\n      }\n      return false;\n    } catch (error: any) {\n      if (error.name === \"NotFoundError\") {\n        throw new Error(\"No device selected. Please try again.\");\n      }\n      throw error;\n    }\n  }\n\n  private delay(ms: number): Promise<void> {\n    return new Promise(resolve => setTimeout(resolve, ms));\n  }\n\n  async disconnect(): Promise<void> {\n    this.connected = false;\n    this.currentPin = null;\n    this.cachedSeed = null;\n    \n    if (this.reader) {\n      try {\n        await this.reader.cancel();\n        this.reader.releaseLock();\n      } catch {}\n      this.reader = null;\n    }\n    \n    if (this.writer) {\n      try {\n        this.writer.releaseLock();\n      } catch {}\n      this.writer = null;\n    }\n    \n    if (this.port) {\n      try {\n        await this.port.close();\n      } catch {}\n      this.port = null;\n    }\n  }\n\n  isConnected(): boolean {\n    return this.connected;\n  }\n\n  private async startReading(): Promise<void> {\n    const decoder = new TextDecoder();\n    \n    while (this.connected && this.reader) {\n      try {\n        const { value, done } = await this.reader.read();\n        if (done) break;\n        \n        this.readBuffer += decoder.decode(value);\n        \n        let newlineIndex;\n        while ((newlineIndex = this.readBuffer.indexOf(\"\\n\")) !== -1) {\n          const line = this.readBuffer.slice(0, newlineIndex).trim();\n          this.readBuffer = this.readBuffer.slice(newlineIndex + 1);\n          \n          if (line && line.startsWith(\"{\") && this.responseResolver) {\n            try {\n              const response = JSON.parse(line) as PiWalletResponse;\n              if (this.responseTimeout) {\n                clearTimeout(this.responseTimeout);\n                this.responseTimeout = null;\n              }\n              this.responseResolver(response);\n              this.responseResolver = null;\n            } catch {}\n          }\n        }\n      } catch (error) {\n        if (this.connected) {\n          console.error(\"Read error:\", error);\n        }\n        break;\n      }\n    }\n  }\n\n  async sendCommand(action: string, params?: Record<string, any>): Promise<PiWalletResponse> {\n    if (!this.writer || !this.connected) {\n      throw new Error(\"Not connected to Pico wallet\");\n    }\n\n    const message = JSON.stringify({ action, ...params }) + \"\\r\\n\";\n    const encoder = new TextEncoder();\n    await this.writer.write(encoder.encode(message));\n\n    return new Promise((resolve, reject) => {\n      this.responseResolver = resolve;\n      this.responseTimeout = setTimeout(() => {\n        this.responseResolver = null;\n        reject(new Error(\"Command timed out\"));\n      }, 10000);\n    });\n  }\n\n  async ping(): Promise<boolean> {\n    try {\n      const response = await this.sendCommand(\"ping\");\n      return response.pong === true;\n    } catch {\n      return false;\n    }\n  }\n\n  async getStatus(): Promise<PiWalletStatus | null> {\n    try {\n      const response = await this.sendCommand(\"status\");\n      return {\n        initialized: response.has_wallet === true,\n        locked: response.unlocked !== true,\n        has_seed: response.has_wallet === true,\n        device_name: \"Pico Hardware Wallet\",\n      };\n    } catch {\n      return null;\n    }\n  }\n\n  async setupWallet(pin: string, seedPhrase: string): Promise<boolean> {\n    const response = await this.sendCommand(\"setup\", { pin, seed: seedPhrase });\n    if (response.error) {\n      throw new Error(response.error);\n    }\n    if (response.success) {\n      this.currentPin = pin;\n      this.cachedSeed = seedPhrase;\n      return true;\n    }\n    return false;\n  }\n\n  async unlock(pin: string): Promise<boolean> {\n    const response = await this.sendCommand(\"unlock\", { pin });\n    if (response.error) {\n      throw new Error(response.error);\n    }\n    if (response.success) {\n      this.currentPin = pin;\n      \n      if (!this.cachedSeed) {\n        const seedResponse = await this.sendCommand(\"get_seed\", { pin });\n        if (seedResponse.seed) {\n          this.cachedSeed = seedResponse.seed;\n        }\n      }\n      return true;\n    }\n    return false;\n  }\n\n  async lock(): Promise<boolean> {\n    const response = await this.sendCommand(\"lock\");\n    this.cachedSeed = null;\n    return response.success === true;\n  }\n\n  getSeedPhrase(): string | null {\n    return this.cachedSeed;\n  }\n\n  async getAddress(chainId: number = 1): Promise<string | null> {\n    if (!this.cachedSeed) {\n      throw new Error(\"Wallet not unlocked\");\n    }\n    \n    const { ethers } = await import(\"ethers\");\n    const mnemonic = ethers.Mnemonic.fromPhrase(this.cachedSeed);\n    const hdNode = ethers.HDNodeWallet.fromMnemonic(mnemonic, \"m/44'/60'/0'/0/0\");\n    return hdNode.address;\n  }\n\n  async getAddresses(chainIds: number[]): Promise<Array<{ chainId: number; address: string; path: string }>> {\n    if (!this.cachedSeed) {\n      throw new Error(\"Wallet not unlocked\");\n    }\n\n    const { ethers } = await import(\"ethers\");\n    const mnemonic = ethers.Mnemonic.fromPhrase(this.cachedSeed);\n    const path = \"m/44'/60'/0'/0/0\";\n    const hdNode = ethers.HDNodeWallet.fromMnemonic(mnemonic, path);\n    \n    return chainIds.map(chainId => ({\n      chainId,\n      address: hdNode.address,\n      path,\n    }));\n  }\n\n  async signTransaction(tx: {\n    to: string;\n    value: string;\n    data?: string;\n    nonce: number;\n    gasLimit: string;\n    gasPrice?: string;\n    maxFeePerGas?: string;\n    maxPriorityFeePerGas?: string;\n    chainId: number;\n  }): Promise<string> {\n    if (!this.cachedSeed) {\n      throw new Error(\"Wallet not unlocked\");\n    }\n\n    const { ethers } = await import(\"ethers\");\n    const mnemonic = ethers.Mnemonic.fromPhrase(this.cachedSeed);\n    const hdNode = ethers.HDNodeWallet.fromMnemonic(mnemonic, \"m/44'/60'/0'/0/0\");\n    \n    const txRequest: Record<string, any> = {\n      to: tx.to,\n      value: ethers.parseEther(tx.value),\n      data: tx.data || \"0x\",\n      nonce: tx.nonce,\n      gasLimit: BigInt(tx.gasLimit),\n      chainId: tx.chainId,\n    };\n\n    if (tx.maxFeePerGas && tx.maxPriorityFeePerGas) {\n      txRequest.maxFeePerGas = BigInt(tx.maxFeePerGas);\n      txRequest.maxPriorityFeePerGas = BigInt(tx.maxPriorityFeePerGas);\n    } else if (tx.gasPrice) {\n      txRequest.gasPrice = BigInt(tx.gasPrice);\n    }\n\n    const signedTx = await hdNode.signTransaction(txRequest);\n    return signedTx;\n  }\n\n  async signMessage(message: string): Promise<string> {\n    if (!this.cachedSeed) {\n      throw new Error(\"Wallet not unlocked\");\n    }\n\n    const { ethers } = await import(\"ethers\");\n    const mnemonic = ethers.Mnemonic.fromPhrase(this.cachedSeed);\n    const hdNode = ethers.HDNodeWallet.fromMnemonic(mnemonic, \"m/44'/60'/0'/0/0\");\n    \n    return await hdNode.signMessage(message);\n  }\n\n  async initWallet(seedPhrase?: string): Promise<{ mnemonic: string } | null> {\n    if (!this.currentPin) {\n      throw new Error(\"PIN not set. Please unlock first.\");\n    }\n    \n    let mnemonic = seedPhrase;\n    if (!mnemonic) {\n      const { ethers } = await import(\"ethers\");\n      const wallet = ethers.Wallet.createRandom();\n      mnemonic = wallet.mnemonic?.phrase;\n    }\n    \n    if (!mnemonic) {\n      throw new Error(\"Failed to generate mnemonic\");\n    }\n\n    const success = await this.setupWallet(this.currentPin, mnemonic);\n    if (success) {\n      return { mnemonic };\n    }\n    return null;\n  }\n\n  async wipe(): Promise<boolean> {\n    if (!this.currentPin) {\n      throw new Error(\"PIN required to reset wallet\");\n    }\n    const response = await this.sendCommand(\"reset\", { pin: this.currentPin });\n    if (response.success) {\n      this.cachedSeed = null;\n      return true;\n    }\n    return false;\n  }\n\n  async factoryReset(): Promise<boolean> {\n    try {\n      const response = await this.sendCommand(\"factory_reset\");\n      if (response.success) {\n        this.cachedSeed = null;\n        this.currentPin = null;\n        return true;\n      }\n      return false;\n    } catch {\n      return false;\n    }\n  }\n\n  async saveChains(chains: StoredChainPreference[]): Promise<boolean> {\n    if (!this.currentPin) {\n      throw new Error(\"Wallet must be unlocked to save chains\");\n    }\n    try {\n      const response = await this.sendCommand(\"save_chains\", { \n        pin: this.currentPin, \n        chains: JSON.stringify(chains) \n      });\n      if (response.error === \"unsupported_command\") {\n        console.log(\"[PiWallet] Device does not support chain storage - using fallback\");\n        return false;\n      }\n      return response.success === true;\n    } catch (error: any) {\n      if (error.message?.includes(\"unsupported\") || error.message?.includes(\"unknown\")) {\n        console.log(\"[PiWallet] Device does not support chain storage - using fallback\");\n        return false;\n      }\n      throw error;\n    }\n  }\n\n  async getChains(): Promise<StoredChainPreference[] | null> {\n    if (!this.currentPin) {\n      throw new Error(\"Wallet must be unlocked to get chains\");\n    }\n    try {\n      const response = await this.sendCommand(\"get_chains\", { pin: this.currentPin });\n      if (response.error === \"unsupported_command\") {\n        console.log(\"[PiWallet] Device does not support chain storage - using fallback\");\n        return null;\n      }\n      if (response.chains) {\n        if (typeof response.chains === \"string\") {\n          return JSON.parse(response.chains);\n        }\n        return response.chains as unknown as StoredChainPreference[];\n      }\n      return [];\n    } catch (error: any) {\n      if (error.message?.includes(\"unsupported\") || error.message?.includes(\"unknown\") || error.message?.includes(\"timed out\")) {\n        console.log(\"[PiWallet] Device does not support chain storage or command timed out - using fallback\");\n        return null;\n      }\n      throw error;\n    }\n  }\n\n  supportsChainStorage(): boolean {\n    return true;\n  }\n}\n\nexport const piWallet = new PiWalletService();\n","path":null,"size_bytes":12119,"size_tokens":null},"client/src/pages/manage-crypto.tsx":{"content":"import { useState, useMemo, useEffect } from \"react\";\nimport { useWallet } from \"@/lib/wallet-context\";\nimport { Card, CardContent, CardHeader, CardTitle } from \"@/components/ui/card\";\nimport { Button } from \"@/components/ui/button\";\nimport { Switch } from \"@/components/ui/switch\";\nimport { Input } from \"@/components/ui/input\";\nimport { Badge } from \"@/components/ui/badge\";\nimport { Label } from \"@/components/ui/label\";\nimport {\n  Dialog,\n  DialogContent,\n  DialogDescription,\n  DialogFooter,\n  DialogHeader,\n  DialogTitle,\n  DialogTrigger,\n} from \"@/components/ui/dialog\";\nimport {\n  Select,\n  SelectContent,\n  SelectItem,\n  SelectTrigger,\n  SelectValue,\n} from \"@/components/ui/select\";\nimport { Search, RefreshCw, CheckSquare, Square, Plus, Trash2, Loader2, AlertCircle, Radio, ArrowLeft } from \"lucide-react\";\nimport { BackButton } from \"@/components/back-button\";\nimport { getTokenInfo } from \"@/lib/blockchain\";\nimport { Link, useSearch, useLocation } from \"wouter\";\nimport { TOKEN_PARENT_CHAIN_SYMBOL, TOKEN_PARENT_CHAIN } from \"@/lib/chain-mappings\";\nimport { FALLBACK_TOP_ASSETS } from \"@shared/schema\";\n\n// Direct symbol-to-logo mapping (using Trust Wallet CDN which is more reliable)\nconst CUSTOM_TOKEN_LOGOS: Record<string, string> = {\n  'CAKE': 'https://assets-cdn.trustwallet.com/blockchains/smartchain/assets/0x0E09FaBB73Bd3Ade0a17ECC321fD13a19e81cE82/logo.png',\n  'TWT': 'https://assets-cdn.trustwallet.com/blockchains/smartchain/assets/0x4B0F1812e5Df2A09796481Ff14017e6005508003/logo.png',\n  'BABY': 'https://assets-cdn.trustwallet.com/blockchains/smartchain/assets/0xc748673057861a797275CD8A068AbB95A902e8de/logo.png',\n  'XVS': 'https://assets-cdn.trustwallet.com/blockchains/smartchain/assets/0xcF6BB5389c92Bdda8a3747Ddb454cB7a64626C63/logo.png',\n};\n\n// Get token image with fallback to FALLBACK_TOP_ASSETS\nfunction getTokenImage(tokenId: string, tokenSymbol: string, tokenImage?: string): string | undefined {\n  // Check direct image first\n  if (tokenImage && tokenImage.trim()) {\n    return tokenImage;\n  }\n  \n  // Check CUSTOM_TOKEN_LOGOS by symbol\n  const symbolUpper = tokenSymbol.toUpperCase().trim();\n  if (CUSTOM_TOKEN_LOGOS[symbolUpper]) {\n    return CUSTOM_TOKEN_LOGOS[symbolUpper];\n  }\n  \n  // Check FALLBACK_TOP_ASSETS by token ID\n  const matchingAsset = FALLBACK_TOP_ASSETS.find(a => a.id === tokenId);\n  if (matchingAsset?.image && matchingAsset.image.trim()) {\n    return matchingAsset.image;\n  }\n  \n  // Check FALLBACK_TOP_ASSETS by symbol\n  const matchingBySymbol = FALLBACK_TOP_ASSETS.find(a => a.symbol.toUpperCase() === symbolUpper);\n  if (matchingBySymbol?.image && matchingBySymbol.image.trim()) {\n    return matchingBySymbol.image;\n  }\n  \n  return undefined;\n}\n\n// Fetch token logo from CoinGecko API\nasync function fetchTokenLogoFromCoinGecko(symbol: string, name: string): Promise<string | undefined> {\n  try {\n    const symbolUpper = symbol.toUpperCase().trim();\n    \n    // Try direct symbol mapping first\n    if (CUSTOM_TOKEN_LOGOS[symbolUpper]) {\n      return CUSTOM_TOKEN_LOGOS[symbolUpper];\n    }\n\n    // Search CoinGecko by symbol\n    const searchResponse = await fetch(\n      `https://api.coingecko.com/api/v3/search?query=${encodeURIComponent(symbol)}`,\n      { signal: AbortSignal.timeout(5000) }\n    );\n    \n    if (!searchResponse.ok) return undefined;\n    const searchData = await searchResponse.json();\n    \n    if (!searchData.coins || searchData.coins.length === 0) return undefined;\n\n    // Find the best match - first by exact symbol match, then by name\n    let bestMatch = searchData.coins[0];\n    for (const coin of searchData.coins) {\n      if (coin.symbol?.toUpperCase() === symbolUpper) {\n        bestMatch = coin;\n        break;\n      }\n      if (coin.name?.toLowerCase() === name.toLowerCase()) {\n        bestMatch = coin;\n        break;\n      }\n    }\n\n    if (bestMatch?.large) {\n      console.log(`[COINGECKO] Found logo for ${symbol}:`, bestMatch.large);\n      return bestMatch.large;\n    }\n  } catch (error) {\n    console.log(`[COINGECKO] Failed to fetch logo for ${symbol}:`, error);\n  }\n  \n  return undefined;\n}\n\nconst SUPPORTED_CHAINS = [\n  { id: 'ETH', name: 'Ethereum (ERC-20)', evmChainId: 1, rpcUrl: 'https://eth.llamarpc.com', type: 'evm' as const },\n  { id: 'BNB', name: 'BNB Chain (BEP-20)', evmChainId: 56, rpcUrl: 'https://bsc-dataseed.binance.org', type: 'evm' as const },\n  { id: 'MATIC', name: 'Polygon', evmChainId: 137, rpcUrl: 'https://polygon-rpc.com', type: 'evm' as const },\n  { id: 'ARB', name: 'Arbitrum', evmChainId: 42161, rpcUrl: 'https://arb1.arbitrum.io/rpc', type: 'evm' as const },\n  { id: 'TRX', name: 'TRON (TRC-20)', evmChainId: 0, rpcUrl: '', type: 'tron' as const },\n];\n\nexport default function ManageCrypto() {\n  const { \n    topAssets, \n    enabledAssetIds, \n    isLoadingAssets, \n    toggleAssetEnabled, \n    refreshTopAssets,\n    enableAllAssets,\n    disableAllAssets,\n    customTokens,\n    addCustomToken,\n    removeCustomToken,\n    walletMode,\n    wallets,\n  } = useWallet();\n\n  // Get chain and wallet from URL params\n  const searchString = useSearch();\n  const urlParams = new URLSearchParams(searchString);\n  const chainFromUrl = urlParams.get('chain');\n  const walletFromUrl = urlParams.get('wallet');\n  const isChainSpecific = !!chainFromUrl;\n\n  // Get available chains based on URL param\n  const availableChains = isChainSpecific \n    ? SUPPORTED_CHAINS.filter(c => c.id === chainFromUrl)\n    : SUPPORTED_CHAINS;\n  \n  const chainData = SUPPORTED_CHAINS.find(c => c.id === chainFromUrl);\n  const tokenTypeLabel = chainFromUrl === 'ETH' ? 'ERC-20' :\n                         chainFromUrl === 'BNB' ? 'BEP-20' :\n                         chainFromUrl === 'TRX' ? 'TRC-20' :\n                         chainData?.name || 'custom';\n\n  const [searchQuery, setSearchQuery] = useState(\"\");\n  const [isAddDialogOpen, setIsAddDialogOpen] = useState(false);\n  const [selectedChain, setSelectedChain] = useState(chainFromUrl || \"\");\n  const [contractAddress, setContractAddress] = useState(\"\");\n  const [tokenInfo, setTokenInfo] = useState<{ name: string; symbol: string; decimals: number } | null>(null);\n  const [isFetchingInfo, setIsFetchingInfo] = useState(false);\n  const [fetchError, setFetchError] = useState(\"\");\n  const [isAdding, setIsAdding] = useState(false);\n  const [manualName, setManualName] = useState(\"\");\n  const [manualSymbol, setManualSymbol] = useState(\"\");\n  const [manualDecimals, setManualDecimals] = useState(\"18\");\n\n  // Update selected chain when URL param changes\n  useEffect(() => {\n    if (chainFromUrl && SUPPORTED_CHAINS.some(c => c.id === chainFromUrl)) {\n      setSelectedChain(chainFromUrl);\n    }\n  }, [chainFromUrl]);\n\n  const filteredAssets = useMemo(() => {\n    if (!searchQuery.trim()) return topAssets;\n    const query = searchQuery.toLowerCase();\n    return topAssets.filter(\n      (asset) =>\n        asset.name.toLowerCase().includes(query) ||\n        asset.symbol.toLowerCase().includes(query)\n    );\n  }, [topAssets, searchQuery]);\n\n  const enabledCount = enabledAssetIds.size;\n  const totalCount = topAssets.length;\n\n  const selectedChainData = SUPPORTED_CHAINS.find(c => c.id === selectedChain);\n  const isTronChain = selectedChainData?.type === 'tron';\n\n  const handleChainChange = (chainId: string) => {\n    setSelectedChain(chainId);\n    setTokenInfo(null);\n    setFetchError(\"\");\n    setManualName(\"\");\n    setManualSymbol(\"\");\n    setManualDecimals(\"18\");\n  };\n\n  const handleContractAddressChange = (address: string) => {\n    setContractAddress(address);\n    setTokenInfo(null);\n    setFetchError(\"\");\n  };\n\n  const fetchTokenInfo = async () => {\n    if (!selectedChain || !contractAddress) return;\n    \n    const chain = SUPPORTED_CHAINS.find(c => c.id === selectedChain);\n    if (!chain) return;\n\n    if (chain.type === 'tron') {\n      setFetchError(\"TRON tokens require manual entry. Please fill in the token details below.\");\n      return;\n    }\n\n    setIsFetchingInfo(true);\n    setFetchError(\"\");\n\n    try {\n      const info = await getTokenInfo(contractAddress, chain.rpcUrl, chain.evmChainId);\n      if (info) {\n        setTokenInfo(info);\n      } else {\n        setFetchError(\"Could not fetch token info. Please verify the contract address.\");\n      }\n    } catch (error) {\n      setFetchError(\"Failed to fetch token info. Please check the address.\");\n    } finally {\n      setIsFetchingInfo(false);\n    }\n  };\n\n  const canAddToken = () => {\n    if (!selectedChain || !contractAddress) return false;\n    if (isTronChain) {\n      return manualName.trim() && manualSymbol.trim() && manualDecimals;\n    }\n    return !!tokenInfo;\n  };\n\n  const handleAddToken = async () => {\n    if (!selectedChain || !contractAddress) return;\n\n    const chain = SUPPORTED_CHAINS.find(c => c.id === selectedChain);\n    if (!chain) return;\n\n    const tokenData = isTronChain\n      ? { name: manualName.trim(), symbol: manualSymbol.trim().toUpperCase(), decimals: parseInt(manualDecimals) || 18 }\n      : tokenInfo;\n\n    if (!tokenData) return;\n\n    // Find the wallet to add the token to\n    // If walletFromUrl is specified, use that; otherwise find a wallet on the selected chain\n    let targetWalletId = walletFromUrl;\n    if (!targetWalletId) {\n      // Find any wallet on this chain\n      const chainWallet = wallets.find(w => {\n        const walletChain = w.chainId;\n        // Match by chain symbol (e.g., ETH, BNB, etc.)\n        return walletChain && walletChain.includes(chain.id.toLowerCase());\n      });\n      if (chainWallet) {\n        targetWalletId = chainWallet.id;\n      } else if (wallets.length > 0) {\n        // Fallback to first wallet\n        targetWalletId = wallets[0].id;\n      }\n    }\n\n    if (!targetWalletId) {\n      setFetchError(\"No wallet available to add token to\");\n      return;\n    }\n\n    setIsAdding(true);\n    try {\n      // Fetch token logo from CoinGecko (with caching via direct mapping)\n      console.log(`[TOKEN_ADD] Fetching logo for ${tokenData.symbol}...`);\n      let tokenImage = await fetchTokenLogoFromCoinGecko(tokenData.symbol, tokenData.name);\n      \n      // Fallback to FALLBACK_TOP_ASSETS if CoinGecko fetch failed\n      if (!tokenImage || !tokenImage.trim()) {\n        const symbolUpper = tokenData.symbol.toUpperCase().trim();\n        const matchingAsset = FALLBACK_TOP_ASSETS.find(\n          a => a.symbol.toUpperCase().trim() === symbolUpper\n        );\n        tokenImage = matchingAsset?.image || '';\n      }\n      \n      // Ensure tokenImage is never undefined (use empty string as fallback)\n      if (!tokenImage) {\n        tokenImage = '';\n      }\n      \n      console.log(`[TOKEN_ADD] Logo for ${tokenData.symbol}:`, tokenImage);\n\n      await addCustomToken({\n        chainId: chain.id,\n        chainType: chain.type,\n        contractAddress: contractAddress.trim(),\n        name: tokenData.name,\n        symbol: tokenData.symbol,\n        decimals: tokenData.decimals,\n        evmChainId: chain.evmChainId,\n        rpcUrl: chain.rpcUrl,\n        image: tokenImage,\n        walletId: targetWalletId,\n      });\n\n      resetDialog();\n      setIsAddDialogOpen(false);\n    } catch (error) {\n      setFetchError(\"Failed to add token\");\n    } finally {\n      setIsAdding(false);\n    }\n  };\n\n  const handleRemoveToken = async (id: string) => {\n    await removeCustomToken(id);\n  };\n\n  const resetDialog = () => {\n    setSelectedChain(\"\");\n    setContractAddress(\"\");\n    setTokenInfo(null);\n    setFetchError(\"\");\n    setManualName(\"\");\n    setManualSymbol(\"\");\n    setManualDecimals(\"18\");\n  };\n\n  const [, setLocation] = useLocation();\n\n  const handleBack = () => {\n    if (isChainSpecific && chainFromUrl && walletFromUrl) {\n      // When viewing chain-specific page, navigate directly to wallet page\n      setLocation(`/?chain=${chainFromUrl}&wallet=${walletFromUrl}`);\n    } else {\n      // Otherwise use browser back\n      window.history.back();\n    }\n  };\n\n  return (\n    <div className=\"container mx-auto p-6 max-w-4xl\">\n      <div className=\"flex flex-col gap-6\">\n        <div className=\"flex flex-col gap-2\">\n          <div className=\"flex items-center gap-3 mb-2\">\n            <Button\n              variant=\"ghost\"\n              size=\"icon\"\n              onClick={handleBack}\n              data-testid=\"button-back\"\n            >\n              <ArrowLeft className=\"h-5 w-5\" />\n            </Button>\n            <h1 className=\"text-2xl font-semibold\" data-testid=\"text-page-title\">\n              {isChainSpecific ? `Add ${tokenTypeLabel} Token` : 'Manage Crypto'}\n            </h1>\n          </div>\n          <p className=\"text-muted-foreground\">\n            {isChainSpecific \n              ? `Add a custom ${tokenTypeLabel} token to track in your ${chainData?.name || chainFromUrl} wallet.`\n              : 'Choose which cryptocurrencies to display on your dashboard. Enable or disable assets to customize your view.'}\n          </p>\n        </div>\n\n        {walletMode !== \"hard_wallet\" && isChainSpecific && (\n        <Card>\n          <CardHeader className=\"pb-4\">\n            <div className=\"flex flex-col gap-4\">\n              <div className=\"flex items-center gap-2\">\n                <CardTitle className=\"text-lg\">Popular Tokens</CardTitle>\n                <Badge variant=\"secondary\" className=\"text-xs\">\n                  {topAssets\n                    .filter(asset => {\n                      const parentChainSymbol = TOKEN_PARENT_CHAIN_SYMBOL[asset.id];\n                      return parentChainSymbol === chainFromUrl && TOKEN_PARENT_CHAIN[asset.id];\n                    })\n                    .filter(a => enabledAssetIds.has(a.id)).length} enabled\n                </Badge>\n              </div>\n              <p className=\"text-sm text-muted-foreground\">Enable major tokens to display them in your wallet</p>\n            </div>\n          </CardHeader>\n          <CardContent>\n            <div className=\"space-y-2\">\n              {topAssets\n                .filter(asset => {\n                  const parentChainSymbol = TOKEN_PARENT_CHAIN_SYMBOL[asset.id];\n                  return parentChainSymbol === chainFromUrl && TOKEN_PARENT_CHAIN[asset.id];\n                })\n                .slice(0, 10)\n                .map((token) => (\n                  <div\n                    key={token.id}\n                    className=\"flex items-center justify-between p-3 rounded-md border\"\n                    data-testid={`major-token-row-${token.id}`}\n                  >\n                    <div className=\"flex items-center gap-3 flex-1\">\n                      {(() => {\n                        const imageUrl = getTokenImage(token.id, token.symbol, token.image);\n                        if (imageUrl) {\n                          return (\n                            <img\n                              src={imageUrl}\n                              alt={token.name}\n                              className=\"h-8 w-8 rounded-full shrink-0\"\n                              onError={(e) => { (e.target as HTMLImageElement).style.display = 'none'; }}\n                            />\n                          );\n                        }\n                        return (\n                          <div className=\"flex h-8 w-8 items-center justify-center rounded-full bg-muted text-xs font-semibold shrink-0\">\n                            {token.symbol.slice(0, 2).toUpperCase()}\n                          </div>\n                        );\n                      })()}\n                      <div className=\"flex-1 min-w-0\">\n                        <p className=\"font-medium text-sm\">{token.name}</p>\n                        <p className=\"text-xs text-muted-foreground\">{token.symbol}</p>\n                      </div>\n                    </div>\n                    <Switch\n                      checked={enabledAssetIds.has(token.id)}\n                      onCheckedChange={() => toggleAssetEnabled(token.id, !enabledAssetIds.has(token.id))}\n                      data-testid={`switch-enable-token-${token.id}`}\n                    />\n                  </div>\n                ))}\n            </div>\n          </CardContent>\n        </Card>\n        )}\n\n        {walletMode !== \"hard_wallet\" && (\n        <Card>\n          <CardHeader className=\"pb-4\">\n            <div className=\"flex flex-col gap-4 sm:flex-row sm:items-center sm:justify-between\">\n              <div className=\"flex items-center gap-2\">\n                <CardTitle className=\"text-lg\">Custom Tokens</CardTitle>\n                <Badge variant=\"secondary\" className=\"text-xs\">\n                  {isChainSpecific && walletFromUrl \n                    ? customTokens.filter(t => t.chainId === chainFromUrl && t.walletId === walletFromUrl).length \n                    : customTokens.length} added\n                </Badge>\n              </div>\n              <Dialog open={isAddDialogOpen} onOpenChange={(open) => {\n                setIsAddDialogOpen(open);\n                if (!open) resetDialog();\n              }}>\n                <DialogTrigger asChild>\n                  <Button size=\"sm\" data-testid=\"button-add-custom-token\">\n                    <Plus className=\"mr-1 h-4 w-4\" />\n                    Add Custom Token\n                  </Button>\n                </DialogTrigger>\n                <DialogContent>\n                  <DialogHeader>\n                    <DialogTitle>Add Custom Token</DialogTitle>\n                    <DialogDescription>\n                      {isChainSpecific \n                        ? `Add a ${tokenTypeLabel} token by entering its contract address.`\n                        : 'Add an ERC-20, BEP-20, or TRC-20 token by entering its contract address.'}\n                    </DialogDescription>\n                  </DialogHeader>\n                  <div className=\"space-y-4 py-4\">\n                    <div className=\"space-y-2\">\n                      <Label htmlFor=\"chain\">Blockchain Network</Label>\n                      <Select value={selectedChain} onValueChange={handleChainChange} disabled={isChainSpecific}>\n                        <SelectTrigger id=\"chain\" data-testid=\"select-chain\">\n                          <SelectValue placeholder=\"Select a network\" />\n                        </SelectTrigger>\n                        <SelectContent>\n                          {availableChains.map((chain) => (\n                            <SelectItem key={chain.id} value={chain.id}>\n                              {chain.name}\n                            </SelectItem>\n                          ))}\n                        </SelectContent>\n                      </Select>\n                    </div>\n                    <div className=\"space-y-2\">\n                      <Label htmlFor=\"contract\">Contract Address</Label>\n                      <div className=\"flex gap-2\">\n                        <Input\n                          id=\"contract\"\n                          placeholder={isTronChain ? \"T...\" : \"0x...\"}\n                          value={contractAddress}\n                          onChange={(e) => handleContractAddressChange(e.target.value)}\n                          data-testid=\"input-contract-address\"\n                        />\n                        {!isTronChain && (\n                          <Button\n                            variant=\"outline\"\n                            onClick={fetchTokenInfo}\n                            disabled={!selectedChain || !contractAddress || isFetchingInfo}\n                            data-testid=\"button-fetch-info\"\n                          >\n                            {isFetchingInfo ? (\n                              <Loader2 className=\"h-4 w-4 animate-spin\" />\n                            ) : (\n                              \"Fetch\"\n                            )}\n                          </Button>\n                        )}\n                      </div>\n                    </div>\n                    {fetchError && (\n                      <div className=\"flex items-center gap-2 text-sm text-amber-600 dark:text-amber-400\">\n                        <AlertCircle className=\"h-4 w-4\" />\n                        {fetchError}\n                      </div>\n                    )}\n                    {isTronChain && selectedChain && (\n                      <div className=\"space-y-3 rounded-md border p-3 bg-muted/50\">\n                        <p className=\"text-sm text-muted-foreground\">Enter token details manually for TRC-20 tokens:</p>\n                        <div className=\"space-y-2\">\n                          <Label htmlFor=\"manualName\">Token Name</Label>\n                          <Input\n                            id=\"manualName\"\n                            placeholder=\"e.g., Tether USD\"\n                            value={manualName}\n                            onChange={(e) => setManualName(e.target.value)}\n                            data-testid=\"input-manual-name\"\n                          />\n                        </div>\n                        <div className=\"space-y-2\">\n                          <Label htmlFor=\"manualSymbol\">Token Symbol</Label>\n                          <Input\n                            id=\"manualSymbol\"\n                            placeholder=\"e.g., USDT\"\n                            value={manualSymbol}\n                            onChange={(e) => setManualSymbol(e.target.value)}\n                            data-testid=\"input-manual-symbol\"\n                          />\n                        </div>\n                        <div className=\"space-y-2\">\n                          <Label htmlFor=\"manualDecimals\">Decimals</Label>\n                          <Input\n                            id=\"manualDecimals\"\n                            type=\"number\"\n                            min=\"0\"\n                            max=\"18\"\n                            placeholder=\"18\"\n                            value={manualDecimals}\n                            onChange={(e) => setManualDecimals(e.target.value)}\n                            data-testid=\"input-manual-decimals\"\n                          />\n                        </div>\n                      </div>\n                    )}\n                    {tokenInfo && !isTronChain && (\n                      <div className=\"rounded-md border p-3 space-y-2 bg-muted/50\">\n                        <div className=\"flex justify-between\">\n                          <span className=\"text-sm text-muted-foreground\">Name:</span>\n                          <span className=\"font-medium\">{tokenInfo.name}</span>\n                        </div>\n                        <div className=\"flex justify-between\">\n                          <span className=\"text-sm text-muted-foreground\">Symbol:</span>\n                          <span className=\"font-medium\">{tokenInfo.symbol}</span>\n                        </div>\n                        <div className=\"flex justify-between\">\n                          <span className=\"text-sm text-muted-foreground\">Decimals:</span>\n                          <span className=\"font-medium\">{tokenInfo.decimals}</span>\n                        </div>\n                      </div>\n                    )}\n                  </div>\n                  <DialogFooter>\n                    <Button\n                      variant=\"outline\"\n                      onClick={() => {\n                        resetDialog();\n                        setIsAddDialogOpen(false);\n                      }}\n                    >\n                      Cancel\n                    </Button>\n                    <Button\n                      onClick={handleAddToken}\n                      disabled={!canAddToken() || isAdding}\n                      data-testid=\"button-confirm-add-token\"\n                    >\n                      {isAdding ? (\n                        <Loader2 className=\"mr-2 h-4 w-4 animate-spin\" />\n                      ) : null}\n                      Add Token\n                    </Button>\n                  </DialogFooter>\n                </DialogContent>\n              </Dialog>\n            </div>\n          </CardHeader>\n          <CardContent>\n            {(() => {\n              // Filter tokens to show only those for the current wallet\n              const tokensToShow = isChainSpecific && walletFromUrl\n                ? customTokens.filter(t => t.chainId === chainFromUrl && t.walletId === walletFromUrl)\n                : customTokens;\n              \n              // Find tokens from other wallets on the same chain that could be added\n              const availableTokensFromOtherWallets = isChainSpecific && walletFromUrl\n                ? customTokens.filter(t => \n                    t.chainId === chainFromUrl && \n                    t.walletId !== walletFromUrl &&\n                    // Check if this token isn't already added to current wallet\n                    !customTokens.some(existing => \n                      existing.walletId === walletFromUrl && \n                      existing.contractAddress.toLowerCase() === t.contractAddress.toLowerCase()\n                    )\n                  )\n                  // Remove duplicates (same token might be in multiple other wallets)\n                  .filter((token, index, self) => \n                    index === self.findIndex(t => t.contractAddress.toLowerCase() === token.contractAddress.toLowerCase())\n                  )\n                : [];\n\n              const handleAddTokenToWallet = async (token: typeof customTokens[0]) => {\n                if (!walletFromUrl) return;\n                await addCustomToken({\n                  chainId: token.chainId,\n                  chainType: token.chainType,\n                  contractAddress: token.contractAddress,\n                  name: token.name,\n                  symbol: token.symbol,\n                  decimals: token.decimals,\n                  evmChainId: token.evmChainId,\n                  rpcUrl: token.rpcUrl,\n                  walletId: walletFromUrl,\n                });\n              };\n              \n              if (tokensToShow.length === 0 && availableTokensFromOtherWallets.length === 0) {\n                return (\n                  <div className=\"flex flex-col items-center justify-center py-8 text-muted-foreground\">\n                    <p>No custom tokens added yet.</p>\n                    <p className=\"text-sm\">\n                      {isChainSpecific \n                        ? `Click \"Add Custom Token\" to track any ${tokenTypeLabel} token.`\n                        : 'Click \"Add Custom Token\" to track any ERC-20, BEP-20, or TRC-20 token.'}\n                    </p>\n                  </div>\n                );\n              }\n              \n              return (\n              <div className=\"space-y-4\">\n                {tokensToShow.length > 0 && (\n                  <div className=\"space-y-2\">\n                    {tokensToShow.map((token) => {\n                      const chain = SUPPORTED_CHAINS.find(c => c.id === token.chainId);\n                      const sym = token.symbol.toUpperCase().trim();\n                      const icon = token.image || CUSTOM_TOKEN_LOGOS[sym] || FALLBACK_TOP_ASSETS.find(a => a.symbol.toUpperCase().trim() === sym)?.image;\n                      return (\n                        <div\n                          key={token.id}\n                          className=\"flex items-center justify-between rounded-md border p-3\"\n                          data-testid={`custom-token-row-${token.id}`}\n                        >\n                          <div className=\"flex items-center gap-3\">\n                            {icon ? (\n                              <img\n                                src={icon}\n                                alt={token.name}\n                                className=\"h-8 w-8 rounded-full bg-muted\"\n                                onError={(e) => { (e.target as HTMLImageElement).style.display = 'none'; }}\n                              />\n                            ) : null}\n                            <div className={`flex h-8 w-8 items-center justify-center rounded-full bg-muted text-xs font-semibold ${icon ? 'hidden' : ''}`}>\n                              {token.symbol.slice(0, 2)}\n                            </div>\n                            <div className=\"flex flex-col\">\n                              <span className=\"font-medium\">{token.name}</span>\n                              <span className=\"text-sm text-muted-foreground\">\n                                {token.symbol} on {chain?.name || token.chainId}\n                              </span>\n                            </div>\n                          </div>\n                          <Button\n                            variant=\"ghost\"\n                            size=\"icon\"\n                            onClick={() => handleRemoveToken(token.id)}\n                            className=\"text-red-600 hover:text-red-700 hover:bg-red-100 dark:text-red-400 dark:hover:bg-red-900/20\"\n                            data-testid={`button-remove-token-${token.id}`}\n                          >\n                            <Trash2 className=\"h-4 w-4\" />\n                          </Button>\n                        </div>\n                      );\n                    })}\n                  </div>\n                )}\n                \n                {availableTokensFromOtherWallets.length > 0 && (\n                  <div className=\"space-y-2\">\n                    <p className=\"text-sm text-muted-foreground font-medium\">Available from other wallets:</p>\n                    {availableTokensFromOtherWallets.map((token) => {\n                      const chain = SUPPORTED_CHAINS.find(c => c.id === token.chainId);\n                      const sym = token.symbol.toUpperCase().trim();\n                      const icon = token.image || CUSTOM_TOKEN_LOGOS[sym] || FALLBACK_TOP_ASSETS.find(a => a.symbol.toUpperCase().trim() === sym)?.image;\n                      return (\n                        <div\n                          key={`available-${token.id}`}\n                          className=\"flex items-center justify-between rounded-md border border-dashed p-3\"\n                          data-testid={`available-token-row-${token.contractAddress}`}\n                        >\n                          <div className=\"flex items-center gap-3\">\n                            {icon ? (\n                              <img\n                                src={icon}\n                                alt={token.name}\n                                className=\"h-8 w-8 rounded-full bg-muted\"\n                                onError={(e) => { (e.target as HTMLImageElement).style.display = 'none'; }}\n                              />\n                            ) : null}\n                            <div className={`flex h-8 w-8 items-center justify-center rounded-full bg-muted text-xs font-semibold ${icon ? 'hidden' : ''}`}>\n                              {token.symbol.slice(0, 2)}\n                            </div>\n                            <div className=\"flex flex-col\">\n                              <span className=\"font-medium\">{token.name}</span>\n                              <span className=\"text-sm text-muted-foreground\">\n                                {token.symbol} on {chain?.name || token.chainId}\n                              </span>\n                            </div>\n                          </div>\n                          <Button\n                            variant=\"ghost\"\n                            size=\"icon\"\n                            onClick={() => handleAddTokenToWallet(token)}\n                            className=\"text-primary\"\n                            data-testid={`button-add-available-token-${token.contractAddress}`}\n                          >\n                            <Plus className=\"h-4 w-4\" />\n                          </Button>\n                        </div>\n                      );\n                    })}\n                  </div>\n                )}\n              </div>\n              );\n            })()}\n          </CardContent>\n        </Card>\n        )}\n\n        {!isChainSpecific && walletMode === \"hard_wallet\" && (\n        <Card>\n          <CardHeader className=\"pb-4\">\n            <div className=\"flex flex-col gap-4 sm:flex-row sm:items-center sm:justify-between\">\n              <div className=\"flex items-center gap-2\">\n                <CardTitle className=\"text-lg\">Top Cryptocurrencies</CardTitle>\n                <Badge variant=\"secondary\" className=\"text-xs\">\n                  {enabledCount}/{totalCount} enabled\n                </Badge>\n              </div>\n              <div className=\"flex flex-wrap items-center gap-2\">\n                <Button\n                  variant=\"outline\"\n                  size=\"sm\"\n                  onClick={enableAllAssets}\n                  data-testid=\"button-enable-all\"\n                >\n                  <CheckSquare className=\"mr-1 h-4 w-4\" />\n                  Enable All\n                </Button>\n                <Button\n                  variant=\"outline\"\n                  size=\"sm\"\n                  onClick={disableAllAssets}\n                  data-testid=\"button-disable-all\"\n                >\n                  <Square className=\"mr-1 h-4 w-4\" />\n                  Disable All\n                </Button>\n                <Button\n                  variant=\"outline\"\n                  size=\"icon\"\n                  onClick={refreshTopAssets}\n                  disabled={isLoadingAssets}\n                  data-testid=\"button-refresh-assets\"\n                >\n                  <RefreshCw className={`h-4 w-4 ${isLoadingAssets ? \"animate-spin\" : \"\"}`} />\n                </Button>\n              </div>\n            </div>\n          </CardHeader>\n          <CardContent className=\"space-y-4\">\n            <div className=\"relative\">\n              <Search className=\"absolute left-3 top-1/2 h-4 w-4 -translate-y-1/2 text-muted-foreground\" />\n              <Input\n                placeholder=\"Search by name or symbol...\"\n                value={searchQuery}\n                onChange={(e) => setSearchQuery(e.target.value)}\n                className=\"pl-10\"\n                data-testid=\"input-search-assets\"\n              />\n            </div>\n\n            {isLoadingAssets && topAssets.length === 0 ? (\n              <div className=\"flex items-center justify-center py-12\">\n                <RefreshCw className=\"h-6 w-6 animate-spin text-muted-foreground\" />\n              </div>\n            ) : filteredAssets.length === 0 ? (\n              <div className=\"flex items-center justify-center py-12 text-muted-foreground\">\n                No assets found matching \"{searchQuery}\"\n              </div>\n            ) : (\n              <div className=\"space-y-2\">\n                {filteredAssets.map((asset) => {\n                  const isEnabled = enabledAssetIds.has(asset.id);\n\n                  return (\n                    <div\n                      key={asset.id}\n                      className=\"flex items-center justify-between rounded-md border p-3 hover-elevate\"\n                      data-testid={`asset-row-${asset.id}`}\n                    >\n                      <div className=\"flex items-center gap-3\">\n                        {asset.image ? (\n                          <img\n                            src={asset.image}\n                            alt={asset.name}\n                            className=\"h-8 w-8 rounded-full bg-muted\"\n                            data-testid={`img-asset-${asset.id}`}\n                            onError={(e) => {\n                              const target = e.target as HTMLImageElement;\n                              target.style.display = 'none';\n                              target.nextElementSibling?.classList.remove('hidden');\n                            }}\n                          />\n                        ) : null}\n                        <div className={`flex h-8 w-8 items-center justify-center rounded-full bg-muted text-xs font-semibold ${asset.image ? 'hidden' : ''}`}>\n                          {asset.symbol.slice(0, 2).toUpperCase()}\n                        </div>\n                        <div className=\"flex flex-col\">\n                          <span className=\"font-medium\" data-testid={`text-asset-name-${asset.id}`}>\n                            {asset.name}\n                          </span>\n                          <span className=\"text-sm text-muted-foreground\">\n                            {asset.symbol}\n                          </span>\n                        </div>\n                      </div>\n\n                      <Switch\n                        checked={isEnabled}\n                        onCheckedChange={(checked) => toggleAssetEnabled(asset.id, checked)}\n                        data-testid={`switch-asset-${asset.id}`}\n                      />\n                    </div>\n                  );\n                })}\n              </div>\n            )}\n          </CardContent>\n        </Card>\n        )}\n      </div>\n    </div>\n  );\n}\n","path":null,"size_bytes":36752,"size_tokens":null},"client/src/components/ui/form.tsx":{"content":"\"use client\"\n\nimport * as React from \"react\"\nimport * as LabelPrimitive from \"@radix-ui/react-label\"\nimport { Slot } from \"@radix-ui/react-slot\"\nimport {\n  Controller,\n  FormProvider,\n  useFormContext,\n  type ControllerProps,\n  type FieldPath,\n  type FieldValues,\n} from \"react-hook-form\"\n\nimport { cn } from \"@/lib/utils\"\nimport { Label } from \"@/components/ui/label\"\n\nconst Form = FormProvider\n\ntype FormFieldContextValue<\n  TFieldValues extends FieldValues = FieldValues,\n  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>\n> = {\n  name: TName\n}\n\nconst FormFieldContext = React.createContext<FormFieldContextValue>(\n  {} as FormFieldContextValue\n)\n\nconst FormField = <\n  TFieldValues extends FieldValues = FieldValues,\n  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>\n>({\n  ...props\n}: ControllerProps<TFieldValues, TName>) => {\n  return (\n    <FormFieldContext.Provider value={{ name: props.name }}>\n      <Controller {...props} />\n    </FormFieldContext.Provider>\n  )\n}\n\nconst useFormField = () => {\n  const fieldContext = React.useContext(FormFieldContext)\n  const itemContext = React.useContext(FormItemContext)\n  const { getFieldState, formState } = useFormContext()\n\n  const fieldState = getFieldState(fieldContext.name, formState)\n\n  if (!fieldContext) {\n    throw new Error(\"useFormField should be used within <FormField>\")\n  }\n\n  const { id } = itemContext\n\n  return {\n    id,\n    name: fieldContext.name,\n    formItemId: `${id}-form-item`,\n    formDescriptionId: `${id}-form-item-description`,\n    formMessageId: `${id}-form-item-message`,\n    ...fieldState,\n  }\n}\n\ntype FormItemContextValue = {\n  id: string\n}\n\nconst FormItemContext = React.createContext<FormItemContextValue>(\n  {} as FormItemContextValue\n)\n\nconst FormItem = React.forwardRef<\n  HTMLDivElement,\n  React.HTMLAttributes<HTMLDivElement>\n>(({ className, ...props }, ref) => {\n  const id = React.useId()\n\n  return (\n    <FormItemContext.Provider value={{ id }}>\n      <div ref={ref} className={cn(\"space-y-2\", className)} {...props} />\n    </FormItemContext.Provider>\n  )\n})\nFormItem.displayName = \"FormItem\"\n\nconst FormLabel = React.forwardRef<\n  React.ElementRef<typeof LabelPrimitive.Root>,\n  React.ComponentPropsWithoutRef<typeof LabelPrimitive.Root>\n>(({ className, ...props }, ref) => {\n  const { error, formItemId } = useFormField()\n\n  return (\n    <Label\n      ref={ref}\n      className={cn(error && \"text-destructive\", className)}\n      htmlFor={formItemId}\n      {...props}\n    />\n  )\n})\nFormLabel.displayName = \"FormLabel\"\n\nconst FormControl = React.forwardRef<\n  React.ElementRef<typeof Slot>,\n  React.ComponentPropsWithoutRef<typeof Slot>\n>(({ ...props }, ref) => {\n  const { error, formItemId, formDescriptionId, formMessageId } = useFormField()\n\n  return (\n    <Slot\n      ref={ref}\n      id={formItemId}\n      aria-describedby={\n        !error\n          ? `${formDescriptionId}`\n          : `${formDescriptionId} ${formMessageId}`\n      }\n      aria-invalid={!!error}\n      {...props}\n    />\n  )\n})\nFormControl.displayName = \"FormControl\"\n\nconst FormDescription = React.forwardRef<\n  HTMLParagraphElement,\n  React.HTMLAttributes<HTMLParagraphElement>\n>(({ className, ...props }, ref) => {\n  const { formDescriptionId } = useFormField()\n\n  return (\n    <p\n      ref={ref}\n      id={formDescriptionId}\n      className={cn(\"text-sm text-muted-foreground\", className)}\n      {...props}\n    />\n  )\n})\nFormDescription.displayName = \"FormDescription\"\n\nconst FormMessage = React.forwardRef<\n  HTMLParagraphElement,\n  React.HTMLAttributes<HTMLParagraphElement>\n>(({ className, children, ...props }, ref) => {\n  const { error, formMessageId } = useFormField()\n  const body = error ? String(error?.message ?? \"\") : children\n\n  if (!body) {\n    return null\n  }\n\n  return (\n    <p\n      ref={ref}\n      id={formMessageId}\n      className={cn(\"text-sm font-medium text-destructive\", className)}\n      {...props}\n    >\n      {body}\n    </p>\n  )\n})\nFormMessage.displayName = \"FormMessage\"\n\nexport {\n  useFormField,\n  Form,\n  FormItem,\n  FormLabel,\n  FormControl,\n  FormDescription,\n  FormMessage,\n  FormField,\n}\n","path":null,"size_bytes":4120,"size_tokens":null},"client/src/components/ui/table.tsx":{"content":"import * as React from \"react\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst Table = React.forwardRef<\n  HTMLTableElement,\n  React.HTMLAttributes<HTMLTableElement>\n>(({ className, ...props }, ref) => (\n  <div className=\"relative w-full overflow-auto\">\n    <table\n      ref={ref}\n      className={cn(\"w-full caption-bottom text-sm\", className)}\n      {...props}\n    />\n  </div>\n))\nTable.displayName = \"Table\"\n\nconst TableHeader = React.forwardRef<\n  HTMLTableSectionElement,\n  React.HTMLAttributes<HTMLTableSectionElement>\n>(({ className, ...props }, ref) => (\n  <thead ref={ref} className={cn(\"[&_tr]:border-b\", className)} {...props} />\n))\nTableHeader.displayName = \"TableHeader\"\n\nconst TableBody = React.forwardRef<\n  HTMLTableSectionElement,\n  React.HTMLAttributes<HTMLTableSectionElement>\n>(({ className, ...props }, ref) => (\n  <tbody\n    ref={ref}\n    className={cn(\"[&_tr:last-child]:border-0\", className)}\n    {...props}\n  />\n))\nTableBody.displayName = \"TableBody\"\n\nconst TableFooter = React.forwardRef<\n  HTMLTableSectionElement,\n  React.HTMLAttributes<HTMLTableSectionElement>\n>(({ className, ...props }, ref) => (\n  <tfoot\n    ref={ref}\n    className={cn(\n      \"border-t bg-muted/50 font-medium [&>tr]:last:border-b-0\",\n      className\n    )}\n    {...props}\n  />\n))\nTableFooter.displayName = \"TableFooter\"\n\nconst TableRow = React.forwardRef<\n  HTMLTableRowElement,\n  React.HTMLAttributes<HTMLTableRowElement>\n>(({ className, ...props }, ref) => (\n  <tr\n    ref={ref}\n    className={cn(\n      \"border-b transition-colors hover:bg-muted/50 data-[state=selected]:bg-muted\",\n      className\n    )}\n    {...props}\n  />\n))\nTableRow.displayName = \"TableRow\"\n\nconst TableHead = React.forwardRef<\n  HTMLTableCellElement,\n  React.ThHTMLAttributes<HTMLTableCellElement>\n>(({ className, ...props }, ref) => (\n  <th\n    ref={ref}\n    className={cn(\n      \"h-12 px-4 text-left align-middle font-medium text-muted-foreground [&:has([role=checkbox])]:pr-0\",\n      className\n    )}\n    {...props}\n  />\n))\nTableHead.displayName = \"TableHead\"\n\nconst TableCell = React.forwardRef<\n  HTMLTableCellElement,\n  React.TdHTMLAttributes<HTMLTableCellElement>\n>(({ className, ...props }, ref) => (\n  <td\n    ref={ref}\n    className={cn(\"p-4 align-middle [&:has([role=checkbox])]:pr-0\", className)}\n    {...props}\n  />\n))\nTableCell.displayName = \"TableCell\"\n\nconst TableCaption = React.forwardRef<\n  HTMLTableCaptionElement,\n  React.HTMLAttributes<HTMLTableCaptionElement>\n>(({ className, ...props }, ref) => (\n  <caption\n    ref={ref}\n    className={cn(\"mt-4 text-sm text-muted-foreground\", className)}\n    {...props}\n  />\n))\nTableCaption.displayName = \"TableCaption\"\n\nexport {\n  Table,\n  TableHeader,\n  TableBody,\n  TableFooter,\n  TableHead,\n  TableRow,\n  TableCell,\n  TableCaption,\n}\n","path":null,"size_bytes":2765,"size_tokens":null},"client/src/components/ui/alert.tsx":{"content":"import * as React from \"react\"\nimport { cva, type VariantProps } from \"class-variance-authority\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst alertVariants = cva(\n  \"relative w-full rounded-lg border p-4 [&>svg~*]:pl-7 [&>svg+div]:translate-y-[-3px] [&>svg]:absolute [&>svg]:left-4 [&>svg]:top-4 [&>svg]:text-foreground\",\n  {\n    variants: {\n      variant: {\n        default: \"bg-background text-foreground\",\n        destructive:\n          \"border-destructive/50 text-destructive dark:border-destructive [&>svg]:text-destructive\",\n      },\n    },\n    defaultVariants: {\n      variant: \"default\",\n    },\n  }\n)\n\nconst Alert = React.forwardRef<\n  HTMLDivElement,\n  React.HTMLAttributes<HTMLDivElement> & VariantProps<typeof alertVariants>\n>(({ className, variant, ...props }, ref) => (\n  <div\n    ref={ref}\n    role=\"alert\"\n    className={cn(alertVariants({ variant }), className)}\n    {...props}\n  />\n))\nAlert.displayName = \"Alert\"\n\nconst AlertTitle = React.forwardRef<\n  HTMLParagraphElement,\n  React.HTMLAttributes<HTMLHeadingElement>\n>(({ className, ...props }, ref) => (\n  <h5\n    ref={ref}\n    className={cn(\"mb-1 font-medium leading-none tracking-tight\", className)}\n    {...props}\n  />\n))\nAlertTitle.displayName = \"AlertTitle\"\n\nconst AlertDescription = React.forwardRef<\n  HTMLParagraphElement,\n  React.HTMLAttributes<HTMLParagraphElement>\n>(({ className, ...props }, ref) => (\n  <div\n    ref={ref}\n    className={cn(\"text-sm [&_p]:leading-relaxed\", className)}\n    {...props}\n  />\n))\nAlertDescription.displayName = \"AlertDescription\"\n\nexport { Alert, AlertTitle, AlertDescription }\n","path":null,"size_bytes":1584,"size_tokens":null},"client/src/lib/transaction-service.ts":{"content":"import { ethers } from \"ethers\";\n\nexport interface TransactionParams {\n  chainId: string;\n  from: string;\n  to: string;\n  amount: string;\n  tokenSymbol?: string;\n  tokenContractAddress?: string;\n  isNativeToken: boolean;\n  decimals?: number;\n}\n\nexport interface UnsignedTransaction {\n  chainType: \"evm\" | \"solana\" | \"tron\" | \"bitcoin\";\n  chainId: number;\n  to: string;\n  value: string;\n  data?: string;\n  nonce?: number;\n  gasLimit?: string;\n  gasPrice?: string;\n  maxFeePerGas?: string;\n  maxPriorityFeePerGas?: string;\n}\n\nexport interface TransactionResult {\n  success: boolean;\n  txHash?: string;\n  error?: string;\n}\n\nconst CHAIN_ID_MAP: Record<string, { evmChainId: number; type: \"evm\" | \"solana\" | \"tron\" | \"bitcoin\" }> = {\n  \"chain-0\": { evmChainId: 1, type: \"evm\" },      // Ethereum\n  \"chain-1\": { evmChainId: 0, type: \"bitcoin\" }, // Bitcoin\n  \"chain-2\": { evmChainId: 56, type: \"evm\" },    // BNB Smart Chain\n  \"chain-3\": { evmChainId: 137, type: \"evm\" },   // Polygon\n  \"chain-4\": { evmChainId: 43114, type: \"evm\" }, // Avalanche\n  \"chain-5\": { evmChainId: 42161, type: \"evm\" }, // Arbitrum\n  \"chain-6\": { evmChainId: 0, type: \"bitcoin\" }, // XRP (unsupported, fallback to bitcoin type)\n  \"chain-7\": { evmChainId: 0, type: \"bitcoin\" }, // Dogecoin\n  \"chain-8\": { evmChainId: 0, type: \"tron\" },    // TRON\n  \"chain-9\": { evmChainId: 0, type: \"bitcoin\" }, // Litecoin\n  \"chain-10\": { evmChainId: 0, type: \"bitcoin\" }, // Bitcoin Cash\n  \"chain-11\": { evmChainId: 0, type: \"solana\" }, // Solana\n};\n\nconst RPC_ENDPOINTS: Record<number, string> = {\n  1: \"https://eth.llamarpc.com\",\n  56: \"https://bsc-dataseed.binance.org\",\n  137: \"https://polygon-rpc.com\",\n  43114: \"https://api.avax.network/ext/bc/C/rpc\",\n  42161: \"https://arb1.arbitrum.io/rpc\",\n  10: \"https://mainnet.optimism.io\",\n};\n\nconst ERC20_ABI = [\n  \"function transfer(address to, uint256 amount) returns (bool)\",\n  \"function balanceOf(address owner) view returns (uint256)\",\n  \"function decimals() view returns (uint8)\",\n];\n\nexport function getChainInfo(chainId: string): { evmChainId: number; type: \"evm\" | \"solana\" | \"tron\" | \"bitcoin\" } | null {\n  return CHAIN_ID_MAP[chainId] || null;\n}\n\nexport function getChainSymbol(chainId: string): string {\n  const symbols: Record<string, string> = {\n    \"chain-0\": \"ETH\",      // Ethereum\n    \"chain-1\": \"BTC\",      // Bitcoin\n    \"chain-2\": \"BNB\",      // BNB Smart Chain\n    \"chain-3\": \"MATIC\",    // Polygon\n    \"chain-4\": \"AVAX\",     // Avalanche\n    \"chain-5\": \"ARB\",      // Arbitrum (uses ETH for gas but different symbol)\n    \"chain-6\": \"XRP\",      // XRP\n    \"chain-7\": \"DOGE\",     // Dogecoin\n    \"chain-8\": \"TRX\",      // TRON\n    \"chain-9\": \"LTC\",      // Litecoin\n    \"chain-10\": \"BCH\",     // Bitcoin Cash\n    \"chain-11\": \"SOL\",     // Solana\n  };\n  return symbols[chainId] || \"ETH\";\n}\n\nexport async function getProvider(chainId: number): Promise<ethers.JsonRpcProvider | null> {\n  const rpcUrl = RPC_ENDPOINTS[chainId];\n  if (!rpcUrl) return null;\n  return new ethers.JsonRpcProvider(rpcUrl, chainId);\n}\n\nexport async function buildEvmNativeTransaction(\n  params: TransactionParams,\n  evmChainId: number\n): Promise<ethers.TransactionRequest | null> {\n  try {\n    const provider = await getProvider(evmChainId);\n    if (!provider) return null;\n\n    const [gasPrice, nonce, feeData] = await Promise.all([\n      provider.getFeeData().then(f => f.gasPrice),\n      provider.getTransactionCount(params.from),\n      provider.getFeeData(),\n    ]);\n\n    const value = ethers.parseEther(params.amount);\n    \n    const tx: ethers.TransactionRequest = {\n      to: params.to,\n      value,\n      chainId: evmChainId,\n      gasLimit: BigInt(21000),\n      nonce,\n    };\n\n    if (feeData.maxFeePerGas && feeData.maxPriorityFeePerGas) {\n      tx.maxFeePerGas = feeData.maxFeePerGas;\n      tx.maxPriorityFeePerGas = feeData.maxPriorityFeePerGas;\n    } else {\n      tx.gasPrice = gasPrice || BigInt(20000000000);\n    }\n\n    return tx;\n  } catch (error) {\n    console.error(\"Failed to build EVM native transaction:\", error);\n    return null;\n  }\n}\n\nexport async function buildErc20Transaction(\n  params: TransactionParams,\n  evmChainId: number\n): Promise<ethers.TransactionRequest | null> {\n  try {\n    if (!params.tokenContractAddress) {\n      console.error(\"Token contract address required for ERC20 transfer\");\n      return null;\n    }\n\n    const provider = await getProvider(evmChainId);\n    if (!provider) return null;\n\n    const contract = new ethers.Contract(params.tokenContractAddress, ERC20_ABI, provider);\n    \n    const decimals = params.decimals || await contract.decimals();\n    const amount = ethers.parseUnits(params.amount, decimals);\n    \n    const data = contract.interface.encodeFunctionData(\"transfer\", [params.to, amount]);\n\n    const [gasPrice, nonce, feeData] = await Promise.all([\n      provider.getFeeData().then(f => f.gasPrice),\n      provider.getTransactionCount(params.from),\n      provider.getFeeData(),\n    ]);\n\n    const gasEstimate = await provider.estimateGas({\n      from: params.from,\n      to: params.tokenContractAddress,\n      data,\n    });\n\n    const tx: ethers.TransactionRequest = {\n      to: params.tokenContractAddress,\n      value: BigInt(0),\n      data,\n      chainId: evmChainId,\n      gasLimit: gasEstimate * BigInt(12) / BigInt(10),\n      nonce,\n    };\n\n    if (feeData.maxFeePerGas && feeData.maxPriorityFeePerGas) {\n      tx.maxFeePerGas = feeData.maxFeePerGas;\n      tx.maxPriorityFeePerGas = feeData.maxPriorityFeePerGas;\n    } else {\n      tx.gasPrice = gasPrice || BigInt(20000000000);\n    }\n\n    return tx;\n  } catch (error) {\n    console.error(\"Failed to build ERC20 transaction:\", error);\n    return null;\n  }\n}\n\nexport interface SolanaTransactionData {\n  from: string;\n  to: string;\n  amount: string;\n  lamports: bigint;\n}\n\nexport interface TronTransactionData {\n  from: string;\n  to: string;\n  amount: string;\n  sunAmount: bigint;\n}\n\nexport interface BitcoinTransactionData {\n  from: string;\n  to: string;\n  amount: string;\n  satoshis: bigint;\n}\n\nexport async function buildSolanaTransaction(\n  params: TransactionParams\n): Promise<SolanaTransactionData | null> {\n  try {\n    const lamports = BigInt(Math.floor(parseFloat(params.amount) * 1e9));\n    return {\n      from: params.from,\n      to: params.to,\n      amount: params.amount,\n      lamports,\n    };\n  } catch (error) {\n    console.error(\"Failed to build Solana transaction:\", error);\n    return null;\n  }\n}\n\nexport async function buildTronTransaction(\n  params: TransactionParams\n): Promise<TronTransactionData | null> {\n  try {\n    const sunAmount = BigInt(Math.floor(parseFloat(params.amount) * 1e6));\n    return {\n      from: params.from,\n      to: params.to,\n      amount: params.amount,\n      sunAmount,\n    };\n  } catch (error) {\n    console.error(\"Failed to build TRON transaction:\", error);\n    return null;\n  }\n}\n\nexport async function buildBitcoinTransaction(\n  params: TransactionParams\n): Promise<BitcoinTransactionData | null> {\n  try {\n    const satoshis = BigInt(Math.floor(parseFloat(params.amount) * 1e8));\n    return {\n      from: params.from,\n      to: params.to,\n      amount: params.amount,\n      satoshis,\n    };\n  } catch (error) {\n    console.error(\"Failed to build Bitcoin transaction:\", error);\n    return null;\n  }\n}\n\nexport async function buildTransaction(params: TransactionParams): Promise<{\n  tx: ethers.TransactionRequest | null;\n  chainType: \"evm\" | \"solana\" | \"tron\" | \"bitcoin\";\n  evmChainId: number;\n  solanaData?: SolanaTransactionData;\n  tronData?: TronTransactionData;\n  bitcoinData?: BitcoinTransactionData;\n} | null> {\n  const chainInfo = getChainInfo(params.chainId);\n  if (!chainInfo) {\n    console.error(\"Unknown chain:\", params.chainId);\n    return null;\n  }\n\n  if (chainInfo.type === \"evm\") {\n    if (params.isNativeToken) {\n      const tx = await buildEvmNativeTransaction(params, chainInfo.evmChainId);\n      return tx ? { tx, chainType: \"evm\", evmChainId: chainInfo.evmChainId } : null;\n    } else {\n      const tx = await buildErc20Transaction(params, chainInfo.evmChainId);\n      return tx ? { tx, chainType: \"evm\", evmChainId: chainInfo.evmChainId } : null;\n    }\n  }\n\n  if (chainInfo.type === \"solana\") {\n    const solanaData = await buildSolanaTransaction(params);\n    return solanaData ? { tx: null, chainType: \"solana\", evmChainId: 0, solanaData } : null;\n  }\n\n  if (chainInfo.type === \"tron\") {\n    const tronData = await buildTronTransaction(params);\n    return tronData ? { tx: null, chainType: \"tron\", evmChainId: 0, tronData } : null;\n  }\n\n  if (chainInfo.type === \"bitcoin\") {\n    const bitcoinData = await buildBitcoinTransaction(params);\n    return bitcoinData ? { tx: null, chainType: \"bitcoin\", evmChainId: 0, bitcoinData } : null;\n  }\n\n  return null;\n}\n\nexport async function broadcastEvmTransaction(\n  signedTx: string,\n  chainId: number\n): Promise<TransactionResult> {\n  try {\n    const provider = await getProvider(chainId);\n    if (!provider) {\n      return { success: false, error: `No RPC endpoint for chain ${chainId}` };\n    }\n\n    const txResponse = await provider.broadcastTransaction(signedTx);\n    return { success: true, txHash: txResponse.hash };\n  } catch (error: any) {\n    return { success: false, error: error.message || \"Failed to broadcast transaction\" };\n  }\n}\n\nexport async function broadcastSolanaTransaction(\n  signedTx: string\n): Promise<TransactionResult> {\n  try {\n    const response = await fetch(\"https://api.mainnet-beta.solana.com\", {\n      method: \"POST\",\n      headers: { \"Content-Type\": \"application/json\" },\n      body: JSON.stringify({\n        jsonrpc: \"2.0\",\n        id: 1,\n        method: \"sendTransaction\",\n        params: [signedTx, { encoding: \"base64\" }],\n      }),\n    });\n\n    const data = await response.json();\n    if (data.error) {\n      return { success: false, error: data.error.message };\n    }\n    return { success: true, txHash: data.result };\n  } catch (error: any) {\n    return { success: false, error: error.message || \"Failed to broadcast Solana transaction\" };\n  }\n}\n\nexport async function broadcastTronTransaction(\n  signedTx: string\n): Promise<TransactionResult> {\n  try {\n    const response = await fetch(\"https://api.trongrid.io/wallet/broadcasttransaction\", {\n      method: \"POST\",\n      headers: { \"Content-Type\": \"application/json\" },\n      body: signedTx,\n    });\n\n    const data = await response.json();\n    if (data.result) {\n      return { success: true, txHash: data.txid };\n    }\n    return { success: false, error: data.message || \"Failed to broadcast TRON transaction\" };\n  } catch (error: any) {\n    return { success: false, error: error.message || \"Failed to broadcast TRON transaction\" };\n  }\n}\n\nexport async function broadcastTransaction(\n  signedTx: string,\n  chainType: \"evm\" | \"solana\" | \"tron\" | \"bitcoin\",\n  evmChainId?: number\n): Promise<TransactionResult> {\n  switch (chainType) {\n    case \"evm\":\n      if (!evmChainId) return { success: false, error: \"EVM chain ID required\" };\n      return broadcastEvmTransaction(signedTx, evmChainId);\n    case \"solana\":\n      return broadcastSolanaTransaction(signedTx);\n    case \"tron\":\n      return broadcastTronTransaction(signedTx);\n    case \"bitcoin\":\n      return { success: false, error: \"Bitcoin transactions not yet supported\" };\n    default:\n      return { success: false, error: \"Unknown chain type\" };\n  }\n}\n\n// Token contracts mapped by correct chain IDs:\n// chain-0: Ethereum, chain-2: BNB Smart Chain, chain-3: Polygon, chain-4: Avalanche, chain-5: Arbitrum\nconst TOKEN_CONTRACTS: Record<string, Record<string, { address: string; decimals: number }>> = {\n  \"USDT\": {\n    \"chain-0\": { address: \"0xdAC17F958D2ee523a2206206994597C13D831ec7\", decimals: 6 },      // Ethereum\n    \"chain-2\": { address: \"0x55d398326f99059fF775485246999027B3197955\", decimals: 18 },     // BNB Smart Chain\n    \"chain-3\": { address: \"0xc2132D05D31c914a87C6611C10748AEb04B58e8F\", decimals: 6 },      // Polygon\n    \"chain-5\": { address: \"0xFd086bC7CD5C481DCC9C85ebE478A1C0b69FCbb9\", decimals: 6 },      // Arbitrum\n  },\n  \"USDC\": {\n    \"chain-0\": { address: \"0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48\", decimals: 6 },      // Ethereum\n    \"chain-2\": { address: \"0x8AC76a51cc950d9822D68b83fE1Ad97B32Cd580d\", decimals: 18 },     // BNB Smart Chain\n    \"chain-3\": { address: \"0x3c499c542cef5e3811e1192ce70d8cc03d5c3359\", decimals: 6 },      // Polygon\n    \"chain-5\": { address: \"0xaf88d065e77c8cC2239327C5EDb3A432268e5831\", decimals: 6 },      // Arbitrum\n  },\n  \"WBTC\": {\n    \"chain-0\": { address: \"0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599\", decimals: 8 },      // Ethereum\n  },\n  \"LINK\": {\n    \"chain-0\": { address: \"0x514910771AF9Ca656af840dff83E8264EcF986CA\", decimals: 18 },     // Ethereum\n    \"chain-2\": { address: \"0xF8A0BF9cF54Bb92F17374d9e9A321E6a111a51bD\", decimals: 18 },     // BNB Smart Chain\n  },\n  \"UNI\": {\n    \"chain-0\": { address: \"0x1f9840a85d5aF5bf1D1762F925BDADdC4201F984\", decimals: 18 },     // Ethereum\n  },\n  \"SHIB\": {\n    \"chain-0\": { address: \"0x95aD61b0a150d79219dCF64E1E6Cc01f0B64C4cE\", decimals: 18 },     // Ethereum\n  },\n  \"STETH\": {\n    \"chain-0\": { address: \"0xae7ab96520DE3A18E5e111B5EaAb095312D7fE84\", decimals: 18 },     // Ethereum\n  },\n  \"AAVE\": {\n    \"chain-0\": { address: \"0x7Fc66500c84A76Ad7e9c93437bFc5Ac33E2DDaE9\", decimals: 18 },     // Ethereum\n  },\n  \"MKR\": {\n    \"chain-0\": { address: \"0x9f8F72aA9304c8B593d555F12eF6589cC3A579A2\", decimals: 18 },     // Ethereum\n  },\n  \"GRT\": {\n    \"chain-0\": { address: \"0xc944E90C64B2c07662A292be6244BDf05Cda44a7\", decimals: 18 },     // Ethereum\n  },\n  \"DAI\": {\n    \"chain-0\": { address: \"0x6B175474E89094C44Da98b954EedeAC495271d0F\", decimals: 18 },     // Ethereum\n    \"chain-2\": { address: \"0x1AF3F329e8BE154074D8769D1FFa4eE058B1DBc3\", decimals: 18 },     // BNB Smart Chain\n  },\n};\n\nexport function getTokenContract(tokenSymbol: string, chainId: string): { address: string; decimals: number } | null {\n  const symbol = tokenSymbol.toUpperCase();\n  const chainContracts = TOKEN_CONTRACTS[symbol];\n  if (!chainContracts) return null;\n  return chainContracts[chainId] || null;\n}\n\nexport function isChainSupported(chainId: string): { supported: boolean; type: string; evmChainId?: number; reason?: string } {\n  const chainInfo = getChainInfo(chainId);\n  if (!chainInfo) {\n    return { supported: false, type: \"unknown\", reason: \"Unknown chain\" };\n  }\n\n  switch (chainInfo.type) {\n    case \"evm\":\n      return { supported: true, type: \"evm\", evmChainId: chainInfo.evmChainId };\n    case \"solana\":\n      return { supported: true, type: \"solana\" };\n    case \"tron\":\n      return { supported: true, type: \"tron\" };\n    case \"bitcoin\":\n      return { supported: true, type: \"bitcoin\" };\n    default:\n      return { supported: false, type: \"unknown\", reason: \"Unknown chain type\" };\n  }\n}\n","path":null,"size_bytes":14769,"size_tokens":null},"client/src/lib/price-service.ts":{"content":"import { CryptoAsset, FALLBACK_TOP_ASSETS } from \"@shared/schema\";\n\nconst FALLBACK_PRICES: Record<string, number> = {\n  ETH: 3500,\n  BNB: 600,\n  MATIC: 0.85,\n  AVAX: 35,\n  ARB: 1.2,\n  BTC: 100000,\n  SOL: 180,\n  XRP: 2.2,\n  DOGE: 0.35,\n  ADA: 0.95,\n  TRX: 0.25,\n  DOT: 7.5,\n  LTC: 105,\n  BCH: 450,\n  OP: 2.5,\n  USDT: 1,\n  USDC: 1,\n};\n\nconst DEFILLAMA_IDS: Record<string, string> = {\n  ETH: \"coingecko:ethereum\",\n  BNB: \"coingecko:binancecoin\",\n  MATIC: \"coingecko:matic-network\",\n  AVAX: \"coingecko:avalanche-2\",\n  ARB: \"coingecko:arbitrum\",\n  BTC: \"coingecko:bitcoin\",\n  SOL: \"coingecko:solana\",\n  XRP: \"coingecko:ripple\",\n  DOGE: \"coingecko:dogecoin\",\n  ADA: \"coingecko:cardano\",\n  TRX: \"coingecko:tron\",\n  DOT: \"coingecko:polkadot\",\n  LTC: \"coingecko:litecoin\",\n  BCH: \"coingecko:bitcoin-cash\",\n  OP: \"coingecko:optimism\",\n  USDT: \"coingecko:tether\",\n  USDC: \"coingecko:usd-coin\",\n};\n\nexport interface PriceData {\n  [symbol: string]: number;\n}\n\nlet cachedPrices: PriceData = { ...FALLBACK_PRICES };\nlet lastFetchTime = 0;\nconst CACHE_DURATION = 30000;\n\nasync function fetchFromDefiLlama(): Promise<PriceData | null> {\n  try {\n    const coins = Object.values(DEFILLAMA_IDS).join(\",\");\n    const response = await fetch(\n      `https://coins.llama.fi/prices/current/${coins}`,\n      { signal: AbortSignal.timeout(10000) }\n    );\n\n    if (!response.ok) return null;\n\n    const data = await response.json();\n    const prices: PriceData = {};\n\n    for (const [symbol, coinId] of Object.entries(DEFILLAMA_IDS)) {\n      const coinData = data.coins?.[coinId];\n      if (coinData?.price) {\n        prices[symbol] = coinData.price;\n      }\n    }\n\n    return Object.keys(prices).length > 0 ? prices : null;\n  } catch {\n    return null;\n  }\n}\n\nexport async function fetchPrices(): Promise<PriceData> {\n  const now = Date.now();\n  if (now - lastFetchTime < CACHE_DURATION && Object.keys(cachedPrices).length > 0) {\n    return cachedPrices;\n  }\n\n  const prices = await fetchFromDefiLlama();\n\n  if (prices && Object.keys(prices).length > 0) {\n    cachedPrices = { ...FALLBACK_PRICES, ...prices };\n    lastFetchTime = now;\n    return cachedPrices;\n  }\n\n  return cachedPrices;\n}\n\nexport function formatUSD(amount: number): string {\n  if (amount >= 1000000) {\n    return `$${(amount / 1000000).toFixed(2)}M`;\n  }\n  if (amount >= 1000) {\n    return `$${(amount / 1000).toFixed(2)}K`;\n  }\n  // Check if it's a round number (no decimal part)\n  if (Number.isInteger(amount) && amount >= 1) {\n    return `$${amount.toFixed(0)}`;\n  }\n  if (amount >= 1) {\n    return `$${amount.toFixed(2)}`;\n  }\n  if (amount >= 0.01) {\n    return `$${amount.toFixed(2)}`;\n  }\n  if (amount > 0) {\n    return `$${amount.toFixed(4)}`;\n  }\n  return \"$0.00\";\n}\n\n// Format crypto balance with smart decimal handling\n// - Zero: shows \"0.00\"\n// - Round numbers: no decimals (e.g., 5 instead of 5.00)\n// - Small amounts: shows more decimals (up to 4-6 based on size)\n// - Normal amounts: shows 2-4 decimals based on size\nexport function formatCryptoBalance(balance: string | number): string {\n  const num = typeof balance === 'string' ? parseFloat(balance) : balance;\n  \n  if (isNaN(num) || num === 0) {\n    return \"0.00\";\n  }\n  \n  // For very large numbers\n  if (num >= 1000000) {\n    const formatted = num / 1000000;\n    return Number.isInteger(formatted) ? `${formatted.toFixed(0)}M` : `${formatted.toFixed(2)}M`;\n  }\n  if (num >= 1000) {\n    const formatted = num / 1000;\n    return Number.isInteger(formatted) ? `${formatted.toFixed(0)}K` : `${formatted.toFixed(2)}K`;\n  }\n  \n  // Check if it's a round number (no significant decimal part)\n  if (Number.isInteger(num)) {\n    return num.toString();\n  }\n  \n  // For amounts >= 100, show 2 decimals\n  if (num >= 100) {\n    const fixed = num.toFixed(2);\n    // Remove trailing zeros but keep at least 2 decimal places for non-round numbers\n    return parseFloat(fixed).toString();\n  }\n  \n  // For amounts >= 1, show 4 decimals\n  if (num >= 1) {\n    const fixed = num.toFixed(4);\n    return parseFloat(fixed).toString();\n  }\n  \n  // For amounts >= 0.01, show 4 decimals\n  if (num >= 0.01) {\n    const fixed = num.toFixed(4);\n    return parseFloat(fixed).toString();\n  }\n  \n  // For very small amounts, show up to 6 decimals\n  if (num >= 0.000001) {\n    const fixed = num.toFixed(6);\n    return parseFloat(fixed).toString();\n  }\n  \n  // For extremely small amounts\n  return \"<0.000001\";\n}\n\nexport function calculateUSDValue(balance: string, symbol: string, prices: PriceData): number {\n  const numBalance = parseFloat(balance);\n  if (isNaN(numBalance) || !prices[symbol]) {\n    return 0;\n  }\n  return numBalance * prices[symbol];\n}\n\nexport interface TopAsset extends CryptoAsset {\n  currentPrice: number;\n  priceChangePercentage24h: number;\n  image: string;\n}\n\nlet cachedTopAssets: TopAsset[] = [];\nlet lastTopAssetsFetchTime = 0;\nconst TOP_ASSETS_CACHE_DURATION = 5 * 60 * 1000;\n\nexport async function fetchTopAssets(limit: number = 50): Promise<TopAsset[]> {\n  const now = Date.now();\n  if (now - lastTopAssetsFetchTime < TOP_ASSETS_CACHE_DURATION && cachedTopAssets.length > 0) {\n    return cachedTopAssets.slice(0, limit);\n  }\n\n  // Use DefiLlama for prices (CORS-enabled) combined with fallback asset list\n  try {\n    const prices = await fetchPrices();\n    \n    const assets: TopAsset[] = FALLBACK_TOP_ASSETS.slice(0, limit).map((asset) => ({\n      ...asset,\n      currentPrice: prices[asset.symbol] || FALLBACK_PRICES[asset.symbol] || 0,\n      priceChangePercentage24h: 0,\n      image: asset.image || \"\",\n    }));\n    cachedTopAssets = assets;\n    lastTopAssetsFetchTime = now;\n    return assets;\n  } catch {\n    return getFallbackTopAssets(limit);\n  }\n}\n\nfunction getFallbackTopAssets(limit: number): TopAsset[] {\n  if (cachedTopAssets.length > 0) {\n    return cachedTopAssets.slice(0, limit);\n  }\n\n  const fallbackPrices: Record<string, number> = {\n    BTC: 100000,\n    ETH: 3500,\n    USDT: 1,\n    BNB: 600,\n    SOL: 180,\n    USDC: 1,\n    XRP: 2.2,\n    STETH: 3500,\n    DOGE: 0.35,\n    ADA: 0.95,\n    TRX: 0.25,\n    AVAX: 35,\n    SHIB: 0.000025,\n    LINK: 22,\n    WBTC: 100000,\n    DOT: 7.5,\n    BCH: 450,\n    MATIC: 0.85,\n    LTC: 105,\n    UNI: 13,\n  };\n\n  return FALLBACK_TOP_ASSETS.map((asset) => ({\n    ...asset,\n    currentPrice: fallbackPrices[asset.symbol] || 0,\n    priceChangePercentage24h: 0,\n    image: asset.image || \"\",\n  }));\n}\n","path":null,"size_bytes":6351,"size_tokens":null},"client/src/lib/hardware-wallet.ts":{"content":"import \"./polyfills\";\nimport TransportWebHID from \"@ledgerhq/hw-transport-webhid\";\nimport Eth from \"@ledgerhq/hw-app-eth\";\nimport { ethers } from \"ethers\";\nimport { piWallet, type StoredChainPreference } from \"./pi-wallet\";\nimport { clientStorage } from \"./client-storage\";\nimport { mobileUsbSerial, isMobileWithUsbSupport } from \"./mobile-usb-serial\";\nimport { \n  signNonEvmTransaction, \n  type NonEvmTransactionParams,\n  type SignedTransaction \n} from \"./non-evm-chains\";\n\nexport type HardwareWalletType = \"ledger\" | \"simulated\" | \"raspberry_pi\" | null;\nexport type ConnectionStatus = \"disconnected\" | \"connecting\" | \"connected\" | \"locked\" | \"unlocked\";\n\nexport interface HardwareWalletState {\n  type: HardwareWalletType;\n  status: ConnectionStatus;\n  deviceName: string | null;\n  error: string | null;\n}\n\nexport interface DerivedAddress {\n  path: string;\n  address: string;\n  chainId: number;\n}\n\nconst BIP44_PATHS = {\n  ethereum: \"44'/60'/0'/0/0\",\n  bitcoin: \"44'/0'/0'/0/0\",\n};\n\nclass HardwareWalletService {\n  private transport: TransportWebHID | null = null;\n  private ethApp: Eth | null = null;\n  private state: HardwareWalletState = {\n    type: null,\n    status: \"disconnected\",\n    deviceName: null,\n    error: null,\n  };\n  private listeners: Set<(state: HardwareWalletState) => void> = new Set();\n  private simulatedSeedPhrase: string | null = null;\n  private simulatedPinHash: string | null = null;\n  private sessionTimeout: ReturnType<typeof setTimeout> | null = null;\n  private sessionTimeoutMs: number = 5 * 60 * 1000; // 5 minutes default\n\n  private async hashPin(pin: string, salt?: string): Promise<string> {\n    const encoder = new TextEncoder();\n    const data = encoder.encode(pin + (salt || \"securevault-salt\"));\n    const hashBuffer = await crypto.subtle.digest(\"SHA-256\", data);\n    const hashArray = Array.from(new Uint8Array(hashBuffer));\n    return hashArray.map(b => b.toString(16).padStart(2, \"0\")).join(\"\");\n  }\n\n  private generateSalt(): string {\n    const array = new Uint8Array(16);\n    crypto.getRandomValues(array);\n    return Array.from(array).map(b => b.toString(16).padStart(2, \"0\")).join(\"\");\n  }\n\n  private async encryptSeed(seed: string, pin: string): Promise<string> {\n    const encoder = new TextEncoder();\n    const keyMaterial = await crypto.subtle.importKey(\n      \"raw\",\n      encoder.encode(pin),\n      { name: \"PBKDF2\" },\n      false,\n      [\"deriveBits\", \"deriveKey\"]\n    );\n    const key = await crypto.subtle.deriveKey(\n      { name: \"PBKDF2\", salt: encoder.encode(\"hardwallet-salt\"), iterations: 100000, hash: \"SHA-256\" },\n      keyMaterial,\n      { name: \"AES-GCM\", length: 256 },\n      false,\n      [\"encrypt\"]\n    );\n    const iv = crypto.getRandomValues(new Uint8Array(12));\n    const encrypted = await crypto.subtle.encrypt(\n      { name: \"AES-GCM\", iv },\n      key,\n      encoder.encode(seed)\n    );\n    const combined = new Uint8Array(iv.length + new Uint8Array(encrypted).length);\n    combined.set(iv);\n    combined.set(new Uint8Array(encrypted), iv.length);\n    return btoa(String.fromCharCode(...combined));\n  }\n\n  private async decryptSeed(encryptedSeed: string, pin: string): Promise<string | null> {\n    try {\n      const encoder = new TextEncoder();\n      const combined = new Uint8Array(atob(encryptedSeed).split(\"\").map(c => c.charCodeAt(0)));\n      const iv = combined.slice(0, 12);\n      const encrypted = combined.slice(12);\n      const keyMaterial = await crypto.subtle.importKey(\n        \"raw\",\n        encoder.encode(pin),\n        { name: \"PBKDF2\" },\n        false,\n        [\"deriveBits\", \"deriveKey\"]\n      );\n      const key = await crypto.subtle.deriveKey(\n        { name: \"PBKDF2\", salt: encoder.encode(\"hardwallet-salt\"), iterations: 100000, hash: \"SHA-256\" },\n        keyMaterial,\n        { name: \"AES-GCM\", length: 256 },\n        false,\n        [\"decrypt\"]\n      );\n      const decrypted = await crypto.subtle.decrypt(\n        { name: \"AES-GCM\", iv },\n        key,\n        encrypted\n      );\n      return new TextDecoder().decode(decrypted);\n    } catch {\n      return null;\n    }\n  }\n\n  getState(): HardwareWalletState {\n    return { ...this.state };\n  }\n\n  subscribe(listener: (state: HardwareWalletState) => void): () => void {\n    this.listeners.add(listener);\n    return () => this.listeners.delete(listener);\n  }\n\n  private setState(updates: Partial<HardwareWalletState>) {\n    this.state = { ...this.state, ...updates };\n    this.listeners.forEach(listener => listener(this.getState()));\n  }\n\n  isMobileDevice(): boolean {\n    if (typeof navigator === \"undefined\") return false;\n    return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) ||\n      (navigator.maxTouchPoints > 0 && /Mobile|Tablet/i.test(navigator.userAgent));\n  }\n\n  isWebHIDSupported(): boolean {\n    return typeof navigator !== \"undefined\" && \"hid\" in navigator;\n  }\n\n  isWebSerialSupported(): boolean {\n    return piWallet.isWebSerialSupported();\n  }\n\n  private picoHasWallet: boolean = false;\n\n  hasWalletOnDevice(): boolean {\n    return this.picoHasWallet;\n  }\n\n  setHasWalletOnDevice(hasWallet: boolean): void {\n    this.picoHasWallet = hasWallet;\n  }\n\n  private usingMobileUsb = false;\n\n  async connectRaspberryPi(): Promise<boolean> {\n    console.log(\"[HardwareWallet] connectRaspberryPi() called\");\n    \n    // Try mobile USB serial first on Android\n    if (isMobileWithUsbSupport()) {\n      console.log(\"[HardwareWallet] Trying mobile USB serial...\");\n      try {\n        const mobileAvailable = await mobileUsbSerial.isAvailable();\n        if (mobileAvailable) {\n          return await this.connectViaMobileUsb();\n        }\n      } catch (e) {\n        console.log(\"[HardwareWallet] Mobile USB not available:\", e);\n      }\n    }\n    \n    if (!this.isWebSerialSupported()) {\n      console.log(\"[HardwareWallet] WebSerial not supported\");\n      const isMobile = this.isMobileDevice();\n      this.setState({ \n        error: isMobile \n          ? \"No Pico detected via USB. Connect your Pico using an OTG cable or use the Mobile Bridge.\"\n          : \"WebSerial is not supported in this browser. Please use Chrome or Edge on desktop.\",\n        status: \"disconnected\"\n      });\n      return false;\n    }\n\n    try {\n      this.setState({ status: \"connecting\", error: null });\n      console.log(\"[HardwareWallet] Status set to 'connecting'\");\n\n      const connected = await piWallet.connect();\n      console.log(\"[HardwareWallet] piWallet.connect() result:\", connected);\n      if (!connected) {\n        throw new Error(\"Failed to connect to Raspberry Pi\");\n      }\n\n      const pong = await piWallet.ping();\n      console.log(\"[HardwareWallet] piWallet.ping() result:\", pong);\n      if (!pong) {\n        throw new Error(\"Device not responding\");\n      }\n\n      const status = await piWallet.getStatus();\n      console.log(\"[HardwareWallet] piWallet.getStatus() result:\", status);\n      \n      this.picoHasWallet = status?.has_seed === true;\n      console.log(\"[HardwareWallet] Device has wallet:\", this.picoHasWallet);\n      this.usingMobileUsb = false;\n      \n      // SECURITY: Always require PIN entry on connection, even if device reports unlocked\n      // This prevents cached session from bypassing PIN verification\n      this.setState({\n        type: \"raspberry_pi\",\n        status: \"connected\",  // Always start as connected, require PIN to unlock\n        deviceName: status?.device_name || \"Raspberry Pi Wallet\",\n        error: null,\n      });\n      console.log(\"[HardwareWallet] Final state:\", this.getState());\n\n      return true;\n    } catch (error: any) {\n      let errorMessage = \"Failed to connect to Raspberry Pi wallet\";\n      \n      if (error.message?.includes(\"No device selected\")) {\n        errorMessage = \"No device selected. Please try again.\";\n      } else if (error.message) {\n        errorMessage = error.message;\n      }\n\n      this.setState({\n        type: null,\n        status: \"disconnected\",\n        deviceName: null,\n        error: errorMessage,\n      });\n      return false;\n    }\n  }\n\n  private async connectViaMobileUsb(): Promise<boolean> {\n    try {\n      this.setState({ status: \"connecting\", error: null });\n      console.log(\"[HardwareWallet] Connecting via mobile USB...\");\n\n      const connected = await mobileUsbSerial.connect();\n      if (!connected) {\n        throw new Error(\"Failed to connect via mobile USB\");\n      }\n\n      const pong = await mobileUsbSerial.ping();\n      if (!pong) {\n        throw new Error(\"Device not responding\");\n      }\n\n      const status = await mobileUsbSerial.getStatus();\n      \n      this.picoHasWallet = status?.has_seed === true;\n      this.usingMobileUsb = true;\n      \n      this.setState({\n        type: \"raspberry_pi\",\n        status: \"connected\",\n        deviceName: status?.device_name || \"Pico Wallet (USB OTG)\",\n        error: null,\n      });\n\n      return true;\n    } catch (error: any) {\n      console.log(\"[HardwareWallet] Mobile USB connection failed:\", error);\n      this.setState({\n        type: null,\n        status: \"disconnected\",\n        deviceName: null,\n        error: error.message || \"Failed to connect via USB\",\n      });\n      return false;\n    }\n  }\n\n  isUsingMobileUsb(): boolean {\n    return this.usingMobileUsb;\n  }\n\n  async connectLedger(): Promise<boolean> {\n    if (!this.isWebHIDSupported()) {\n      this.setState({ \n        error: \"WebHID is not supported in this browser. Please use Chrome, Edge, or Opera.\",\n        status: \"disconnected\"\n      });\n      return false;\n    }\n\n    try {\n      this.setState({ status: \"connecting\", error: null });\n\n      this.transport = await TransportWebHID.create() as TransportWebHID;\n      this.ethApp = new Eth(this.transport as any);\n\n      const config = await this.ethApp.getAppConfiguration();\n      \n      this.setState({\n        type: \"ledger\",\n        status: \"connected\",\n        deviceName: `Ledger (Ethereum App v${config.version})`,\n        error: null,\n      });\n\n      if (this.transport) {\n        this.transport.on(\"disconnect\", () => {\n          this.handleDisconnect();\n        });\n      }\n\n      return true;\n    } catch (error: any) {\n      let errorMessage = \"Failed to connect to Ledger device\";\n      \n      if (error.name === \"TransportOpenUserCancelled\") {\n        errorMessage = \"Connection cancelled by user\";\n      } else if (error.message?.includes(\"No device selected\")) {\n        errorMessage = \"No device selected. Please try again.\";\n      } else if (error.statusCode === 0x6700) {\n        errorMessage = \"Please open the Ethereum app on your Ledger\";\n      } else if (error.statusCode === 0x6e00) {\n        errorMessage = \"App not open. Please open the Ethereum app on your Ledger\";\n      }\n\n      this.setState({\n        type: null,\n        status: \"disconnected\",\n        deviceName: null,\n        error: errorMessage,\n      });\n      return false;\n    }\n  }\n\n  async connectSimulated(seedPhrase: string, pin?: string): Promise<boolean> {\n    try {\n      this.setState({ status: \"connecting\", error: null });\n\n      const words = seedPhrase.trim().split(/\\s+/);\n      if (words.length !== 12 && words.length !== 24) {\n        throw new Error(\"Seed phrase must be 12 or 24 words\");\n      }\n\n      try {\n        ethers.Mnemonic.fromPhrase(seedPhrase);\n      } catch {\n        throw new Error(\"Invalid seed phrase\");\n      }\n\n      this.simulatedSeedPhrase = seedPhrase;\n      \n      if (pin) {\n        const salt = this.generateSalt();\n        this.simulatedPinHash = await this.hashPin(pin, salt);\n        const encryptedSeed = await this.encryptSeed(seedPhrase, pin);\n        await clientStorage.saveHardWalletEncryptedSeed(encryptedSeed, this.simulatedPinHash, salt);\n      }\n\n      this.setState({\n        type: \"simulated\",\n        status: \"connected\",\n        deviceName: \"Simulated Hardware Wallet\",\n        error: null,\n      });\n\n      return true;\n    } catch (error: any) {\n      this.setState({\n        type: null,\n        status: \"disconnected\",\n        deviceName: null,\n        error: error.message || \"Failed to create simulated wallet\",\n      });\n      return false;\n    }\n  }\n\n  async setPin(pin: string): Promise<boolean> {\n    if (pin.length < 4 || pin.length > 6 || !/^\\d+$/.test(pin)) {\n      this.setState({ error: \"PIN must be 4-6 digits\" });\n      return false;\n    }\n    const salt = this.generateSalt();\n    this.simulatedPinHash = await this.hashPin(pin, salt);\n    if (this.simulatedSeedPhrase) {\n      const encryptedSeed = await this.encryptSeed(this.simulatedSeedPhrase, pin);\n      await clientStorage.saveHardWalletEncryptedSeed(encryptedSeed, this.simulatedPinHash, salt);\n    }\n    return true;\n  }\n\n  async unlock(pin: string): Promise<boolean> {\n    if (this.state.type === \"raspberry_pi\") {\n      try {\n        if (this.usingMobileUsb) {\n          await mobileUsbSerial.unlock(pin);\n        } else {\n          await piWallet.unlock(pin);\n        }\n        this.setState({ status: \"unlocked\" });\n        this.startSessionTimeout();\n        return true;\n      } catch (error: any) {\n        this.setState({ error: error.message || \"Failed to unlock\" });\n        return false;\n      }\n    }\n\n    if (this.state.type === \"simulated\") {\n      if (pin.length < 4 || pin.length > 6 || !/^\\d+$/.test(pin)) {\n        this.setState({ error: \"PIN must be 4-6 digits\" });\n        return false;\n      }\n      \n      const storedPinHash = await clientStorage.getHardWalletPinHash();\n      const storedSalt = await clientStorage.getHardWalletPinSalt();\n      const encryptedSeed = await clientStorage.getHardWalletEncryptedSeed();\n      \n      if (storedPinHash && storedSalt && encryptedSeed) {\n        const inputHash = await this.hashPin(pin, storedSalt);\n        if (inputHash !== storedPinHash) {\n          this.setState({ error: \"Incorrect PIN\" });\n          return false;\n        }\n        const decryptedSeed = await this.decryptSeed(encryptedSeed, pin);\n        if (!decryptedSeed) {\n          this.setState({ error: \"Failed to decrypt wallet\" });\n          return false;\n        }\n        this.simulatedSeedPhrase = decryptedSeed;\n        this.simulatedPinHash = storedPinHash;\n      } else if (this.simulatedPinHash) {\n        const inputHash = await this.hashPin(pin);\n        if (inputHash !== this.simulatedPinHash) {\n          this.setState({ error: \"Incorrect PIN\" });\n          return false;\n        }\n      } else {\n        const salt = this.generateSalt();\n        this.simulatedPinHash = await this.hashPin(pin, salt);\n        if (this.simulatedSeedPhrase) {\n          const encrypted = await this.encryptSeed(this.simulatedSeedPhrase, pin);\n          await clientStorage.saveHardWalletEncryptedSeed(encrypted, this.simulatedPinHash, salt);\n        }\n      }\n      \n      this.setState({ status: \"unlocked\" });\n      this.startSessionTimeout();\n      return true;\n    }\n\n    if (this.state.type === \"ledger\" && this.state.status === \"connected\") {\n      this.setState({ status: \"unlocked\" });\n      this.startSessionTimeout();\n      return true;\n    }\n\n    return false;\n  }\n\n  async getAddress(chainId: number = 1): Promise<string | null> {\n    if (this.state.status !== \"unlocked\") {\n      this.setState({ error: \"Device is locked. Please unlock first.\" });\n      return null;\n    }\n\n    try {\n      if (this.state.type === \"raspberry_pi\") {\n        if (this.usingMobileUsb) {\n          return await mobileUsbSerial.getAddress(chainId);\n        }\n        return await piWallet.getAddress(chainId);\n      }\n\n      if (this.state.type === \"ledger\" && this.ethApp) {\n        const path = BIP44_PATHS.ethereum;\n        const result = await this.ethApp.getAddress(path);\n        return result.address;\n      }\n\n      if (this.state.type === \"simulated\" && this.simulatedSeedPhrase) {\n        const mnemonic = ethers.Mnemonic.fromPhrase(this.simulatedSeedPhrase);\n        const hdNode = ethers.HDNodeWallet.fromMnemonic(mnemonic, \"m/44'/60'/0'/0/0\");\n        return hdNode.address;\n      }\n\n      return null;\n    } catch (error: any) {\n      this.setState({ error: error.message || \"Failed to get address\" });\n      return null;\n    }\n  }\n\n  async getMultipleAddresses(chainIds: number[]): Promise<DerivedAddress[]> {\n    if (this.state.status !== \"unlocked\") {\n      return [];\n    }\n\n    const addresses: DerivedAddress[] = [];\n\n    try {\n      if (this.state.type === \"raspberry_pi\") {\n        if (this.usingMobileUsb) {\n          const mobileAddresses = await mobileUsbSerial.getAddresses(chainIds);\n          return mobileAddresses.map(addr => ({\n            path: addr.path,\n            address: addr.address,\n            chainId: addr.chainId,\n          }));\n        }\n        const piAddresses = await piWallet.getAddresses(chainIds);\n        return piAddresses.map(addr => ({\n          path: addr.path,\n          address: addr.address,\n          chainId: addr.chainId,\n        }));\n      }\n\n      if (this.state.type === \"simulated\" && this.simulatedSeedPhrase) {\n        const mnemonic = ethers.Mnemonic.fromPhrase(this.simulatedSeedPhrase);\n        \n        for (const chainId of chainIds) {\n          const path = \"m/44'/60'/0'/0/0\";\n          const hdNode = ethers.HDNodeWallet.fromMnemonic(mnemonic, path);\n          addresses.push({\n            path,\n            address: hdNode.address,\n            chainId,\n          });\n        }\n      }\n\n      if (this.state.type === \"ledger\" && this.ethApp) {\n        const path = BIP44_PATHS.ethereum;\n        const result = await this.ethApp.getAddress(path);\n        \n        for (const chainId of chainIds) {\n          addresses.push({\n            path,\n            address: result.address,\n            chainId,\n          });\n        }\n      }\n    } catch (error: any) {\n      this.setState({ error: error.message || \"Failed to derive addresses\" });\n    }\n\n    return addresses;\n  }\n\n  async signTransaction(unsignedTx: ethers.TransactionRequest): Promise<string | null> {\n    if (this.state.status !== \"unlocked\") {\n      this.setState({ error: \"Device is locked\" });\n      return null;\n    }\n\n    try {\n      if (this.state.type === \"raspberry_pi\") {\n        const txData = {\n          to: unsignedTx.to as string,\n          value: unsignedTx.value?.toString() || \"0\",\n          data: unsignedTx.data as string,\n          nonce: Number(unsignedTx.nonce),\n          gasLimit: unsignedTx.gasLimit?.toString() || \"21000\",\n          gasPrice: unsignedTx.gasPrice?.toString(),\n          maxFeePerGas: unsignedTx.maxFeePerGas?.toString(),\n          maxPriorityFeePerGas: unsignedTx.maxPriorityFeePerGas?.toString(),\n          chainId: Number(unsignedTx.chainId) || 1,\n        };\n        if (this.usingMobileUsb) {\n          return await mobileUsbSerial.signTransaction(txData);\n        }\n        return await piWallet.signTransaction(txData);\n      }\n\n      if (this.state.type === \"simulated\") {\n        if (!this.simulatedSeedPhrase) {\n          const encryptedSeed = await clientStorage.getHardWalletEncryptedSeed();\n          if (encryptedSeed && this.simulatedPinHash) {\n            this.setState({ error: \"Wallet needs to be unlocked again\" });\n            return null;\n          }\n          this.setState({ error: \"No seed phrase available for signing\" });\n          return null;\n        }\n        const mnemonic = ethers.Mnemonic.fromPhrase(this.simulatedSeedPhrase);\n        const hdNode = ethers.HDNodeWallet.fromMnemonic(mnemonic, \"m/44'/60'/0'/0/0\");\n        const signedTx = await hdNode.signTransaction(unsignedTx);\n        return signedTx;\n      }\n\n      if (this.state.type === \"ledger\" && this.ethApp) {\n        const path = BIP44_PATHS.ethereum;\n        \n        const baseTx: ethers.TransactionLike = {\n          to: unsignedTx.to as string,\n          value: unsignedTx.value,\n          data: unsignedTx.data as string,\n          nonce: unsignedTx.nonce,\n          gasLimit: unsignedTx.gasLimit,\n          gasPrice: unsignedTx.gasPrice,\n          chainId: unsignedTx.chainId,\n        };\n\n        const serialized = ethers.Transaction.from(baseTx).unsignedSerialized;\n        const rawTxHex = serialized.slice(2);\n\n        const signature = await this.ethApp.signTransaction(path, rawTxHex);\n\n        const signedTx = ethers.Transaction.from({\n          ...baseTx,\n          signature: {\n            r: \"0x\" + signature.r,\n            s: \"0x\" + signature.s,\n            v: parseInt(signature.v, 16),\n          },\n        });\n\n        return signedTx.serialized;\n      }\n\n      return null;\n    } catch (error: any) {\n      this.setState({ error: error.message || \"Failed to sign transaction\" });\n      return null;\n    }\n  }\n\n  async signNonEvmTransaction(params: NonEvmTransactionParams): Promise<SignedTransaction | null> {\n    if (this.state.status !== \"unlocked\") {\n      this.setState({ error: \"Device is locked\" });\n      return null;\n    }\n\n    try {\n      if (this.state.type === \"simulated\" && this.simulatedSeedPhrase) {\n        const result = await signNonEvmTransaction(params, this.simulatedSeedPhrase);\n        if (!result) {\n          this.setState({ error: \"Failed to sign non-EVM transaction\" });\n          return null;\n        }\n        return result;\n      }\n\n      if (this.state.type === \"raspberry_pi\") {\n        // For non-EVM chains, we use the cached seed from Pico for client-side signing\n        // The seed is securely stored on Pico and only accessible when unlocked with PIN\n        let seedPhrase: string | null = null;\n        \n        if (this.usingMobileUsb) {\n          seedPhrase = mobileUsbSerial.getSeedPhrase();\n          // If not cached, try to fetch it\n          if (!seedPhrase) {\n            seedPhrase = await mobileUsbSerial.ensureSeedCached();\n          }\n        } else {\n          seedPhrase = piWallet.getSeedPhrase();\n        }\n        \n        if (!seedPhrase) {\n          this.setState({ error: \"Wallet seed not available. Please reconnect and unlock.\" });\n          return null;\n        }\n        \n        const result = await signNonEvmTransaction(params, seedPhrase);\n        if (!result) {\n          this.setState({ error: \"Failed to sign non-EVM transaction\" });\n          return null;\n        }\n        return result;\n      }\n\n      if (this.state.type === \"ledger\") {\n        this.setState({ error: \"Non-EVM signing on Ledger is not yet supported\" });\n        return null;\n      }\n\n      return null;\n    } catch (error: any) {\n      this.setState({ error: error.message || \"Failed to sign non-EVM transaction\" });\n      return null;\n    }\n  }\n\n  async signMessage(message: string): Promise<string | null> {\n    if (this.state.status !== \"unlocked\") {\n      this.setState({ error: \"Device is locked\" });\n      return null;\n    }\n\n    try {\n      if (this.state.type === \"raspberry_pi\") {\n        if (this.usingMobileUsb) {\n          return await mobileUsbSerial.signMessage(message);\n        }\n        return await piWallet.signMessage(message);\n      }\n\n      if (this.state.type === \"simulated\" && this.simulatedSeedPhrase) {\n        const mnemonic = ethers.Mnemonic.fromPhrase(this.simulatedSeedPhrase);\n        const hdNode = ethers.HDNodeWallet.fromMnemonic(mnemonic, \"m/44'/60'/0'/0/0\");\n        return await hdNode.signMessage(message);\n      }\n\n      if (this.state.type === \"ledger\" && this.ethApp) {\n        const path = BIP44_PATHS.ethereum;\n        const messageBuffer = Buffer.from(message);\n        const signature = await this.ethApp.signPersonalMessage(path, messageBuffer as any);\n        \n        const vNum = typeof signature.v === 'string' ? Number.parseInt(signature.v, 16) : signature.v;\n        const sig = ethers.Signature.from({\n          r: \"0x\" + signature.r,\n          s: \"0x\" + signature.s,\n          v: vNum,\n        } as any);\n        return sig.serialized;\n      }\n\n      return null;\n    } catch (error: any) {\n      this.setState({ error: error.message || \"Failed to sign message\" });\n      return null;\n    }\n  }\n\n  private handleDisconnect() {\n    this.transport = null;\n    this.ethApp = null;\n    this.setState({\n      type: null,\n      status: \"disconnected\",\n      deviceName: null,\n      error: \"Device disconnected\",\n    });\n  }\n\n  async disconnect(): Promise<void> {\n    this.clearSessionTimeout();\n    if (this.state.type === \"raspberry_pi\") {\n      if (this.usingMobileUsb) {\n        await mobileUsbSerial.disconnect();\n      } else {\n        await piWallet.disconnect();\n      }\n    }\n    if (this.transport) {\n      await this.transport.close();\n    }\n    this.transport = null;\n    this.ethApp = null;\n    this.simulatedSeedPhrase = null;\n    this.simulatedPinHash = null;\n    this.picoHasWallet = false;\n    this.usingMobileUsb = false;\n    this.setState({\n      type: null,\n      status: \"disconnected\",\n      deviceName: null,\n      error: null,\n    });\n  }\n\n  async lock(): Promise<void> {\n    if (this.state.status === \"unlocked\") {\n      this.clearSessionTimeout();\n      if (this.state.type === \"raspberry_pi\") {\n        if (this.usingMobileUsb) {\n          await mobileUsbSerial.lock();\n        } else {\n          await piWallet.lock();\n        }\n      }\n      this.setState({ status: \"connected\" });\n    }\n  }\n\n  private startSessionTimeout(): void {\n    this.clearSessionTimeout();\n    this.sessionTimeout = setTimeout(() => {\n      if (this.state.status === \"unlocked\") {\n        this.lock();\n      }\n    }, this.sessionTimeoutMs);\n  }\n\n  private clearSessionTimeout(): void {\n    if (this.sessionTimeout) {\n      clearTimeout(this.sessionTimeout);\n      this.sessionTimeout = null;\n    }\n  }\n\n  resetSessionTimeout(): void {\n    if (this.state.status === \"unlocked\") {\n      this.startSessionTimeout();\n    }\n  }\n\n  setSessionTimeoutMs(ms: number): void {\n    this.sessionTimeoutMs = ms;\n    if (this.state.status === \"unlocked\") {\n      this.startSessionTimeout();\n    }\n  }\n\n  getSessionTimeoutMs(): number {\n    return this.sessionTimeoutMs;\n  }\n\n  getSeedPhrase(): string | null {\n    if (this.state.type === \"simulated\" && this.simulatedSeedPhrase) {\n      return this.simulatedSeedPhrase;\n    }\n    return null;\n  }\n\n  async getSeedPhraseFromDevice(): Promise<string | null> {\n    if (this.state.type === \"raspberry_pi\") {\n      try {\n        if (this.usingMobileUsb) {\n          return await mobileUsbSerial.getSeedPhrase();\n        }\n        return await piWallet.getSeedPhrase();\n      } catch (error) {\n        console.error(\"Failed to get seed phrase from device:\", error);\n        return null;\n      }\n    }\n    return this.getSeedPhrase();\n  }\n\n  async hasStoredHardWallet(): Promise<boolean> {\n    return await clientStorage.hasHardWalletEncryptedSeed();\n  }\n\n  async reconnectFromStorage(): Promise<boolean> {\n    const hasStored = await clientStorage.hasHardWalletEncryptedSeed();\n    if (!hasStored) {\n      return false;\n    }\n    this.setState({\n      type: \"simulated\",\n      status: \"connected\",\n      deviceName: \"Simulated Hardware Wallet\",\n      error: null,\n    });\n    return true;\n  }\n\n  async saveChainPreferences(chains: StoredChainPreference[]): Promise<boolean> {\n    if (this.state.type === \"raspberry_pi\" && this.state.status === \"unlocked\") {\n      try {\n        const saved = this.usingMobileUsb \n          ? await mobileUsbSerial.saveChains(chains)\n          : await piWallet.saveChains(chains);\n        if (saved) {\n          console.log(\"[HardwareWallet] Chain preferences saved to hardware\");\n          return true;\n        }\n        console.log(\"[HardwareWallet] Hardware doesn't support chain storage, using fallback\");\n        await clientStorage.saveHardWalletChainPreferences(chains);\n        return true;\n      } catch (error) {\n        console.error(\"[HardwareWallet] Failed to save chains to hardware:\", error);\n        await clientStorage.saveHardWalletChainPreferences(chains);\n        return true;\n      }\n    }\n    await clientStorage.saveHardWalletChainPreferences(chains);\n    return true;\n  }\n\n  async getChainPreferences(): Promise<StoredChainPreference[] | null> {\n    if (this.state.type === \"raspberry_pi\" && this.state.status === \"unlocked\") {\n      try {\n        const chains = this.usingMobileUsb\n          ? await mobileUsbSerial.getChains()\n          : await piWallet.getChains();\n        if (chains !== null) {\n          console.log(\"[HardwareWallet] Chain preferences loaded from hardware:\", chains);\n          return chains;\n        }\n        console.log(\"[HardwareWallet] Hardware doesn't support chain storage, using fallback\");\n        return await clientStorage.getHardWalletChainPreferences();\n      } catch (error) {\n        console.error(\"[HardwareWallet] Failed to load chains from hardware:\", error);\n        return await clientStorage.getHardWalletChainPreferences();\n      }\n    }\n    return await clientStorage.getHardWalletChainPreferences();\n  }\n\n  async setupWallet(pin: string, seedPhrase: string): Promise<boolean> {\n    console.log(\"[HardwareWallet] setupWallet called, usingMobileUsb:\", this.usingMobileUsb);\n    try {\n      if (this.usingMobileUsb) {\n        console.log(\"[HardwareWallet] Setting up via mobile USB...\");\n        return await mobileUsbSerial.setupWallet(pin, seedPhrase);\n      } else {\n        console.log(\"[HardwareWallet] Setting up via desktop serial...\");\n        return await piWallet.setupWallet(pin, seedPhrase);\n      }\n    } catch (error) {\n      console.error(\"[HardwareWallet] setupWallet failed:\", error);\n      throw error;\n    }\n  }\n}\n\nexport const hardwareWallet = new HardwareWalletService();\n","path":null,"size_bytes":29330,"size_tokens":null},"client/src/pages/not-found.tsx":{"content":"import { Card, CardContent } from \"@/components/ui/card\";\nimport { AlertCircle } from \"lucide-react\";\n\nexport default function NotFound() {\n  return (\n    <div className=\"min-h-screen w-full flex items-center justify-center bg-gray-50\">\n      <Card className=\"w-full max-w-md mx-4\">\n        <CardContent className=\"pt-6\">\n          <div className=\"flex mb-4 gap-2\">\n            <AlertCircle className=\"h-8 w-8 text-red-500\" />\n            <h1 className=\"text-2xl font-bold text-gray-900\">404 Page Not Found</h1>\n          </div>\n\n          <p className=\"mt-4 text-sm text-gray-600\">\n            Did you forget to add the page to the router?\n          </p>\n        </CardContent>\n      </Card>\n    </div>\n  );\n}\n","path":null,"size_bytes":711,"size_tokens":null},"client/src/hooks/use-toast.ts":{"content":"import * as React from \"react\"\n\nimport type {\n  ToastActionElement,\n  ToastProps,\n} from \"@/components/ui/toast\"\n\nconst TOAST_LIMIT = 1\nconst TOAST_REMOVE_DELAY = 1000000\n\ntype ToasterToast = ToastProps & {\n  id: string\n  title?: React.ReactNode\n  description?: React.ReactNode\n  action?: ToastActionElement\n}\n\nconst actionTypes = {\n  ADD_TOAST: \"ADD_TOAST\",\n  UPDATE_TOAST: \"UPDATE_TOAST\",\n  DISMISS_TOAST: \"DISMISS_TOAST\",\n  REMOVE_TOAST: \"REMOVE_TOAST\",\n} as const\n\nlet count = 0\n\nfunction genId() {\n  count = (count + 1) % Number.MAX_SAFE_INTEGER\n  return count.toString()\n}\n\ntype ActionType = typeof actionTypes\n\ntype Action =\n  | {\n      type: ActionType[\"ADD_TOAST\"]\n      toast: ToasterToast\n    }\n  | {\n      type: ActionType[\"UPDATE_TOAST\"]\n      toast: Partial<ToasterToast>\n    }\n  | {\n      type: ActionType[\"DISMISS_TOAST\"]\n      toastId?: ToasterToast[\"id\"]\n    }\n  | {\n      type: ActionType[\"REMOVE_TOAST\"]\n      toastId?: ToasterToast[\"id\"]\n    }\n\ninterface State {\n  toasts: ToasterToast[]\n}\n\nconst toastTimeouts = new Map<string, ReturnType<typeof setTimeout>>()\n\nconst addToRemoveQueue = (toastId: string) => {\n  if (toastTimeouts.has(toastId)) {\n    return\n  }\n\n  const timeout = setTimeout(() => {\n    toastTimeouts.delete(toastId)\n    dispatch({\n      type: \"REMOVE_TOAST\",\n      toastId: toastId,\n    })\n  }, TOAST_REMOVE_DELAY)\n\n  toastTimeouts.set(toastId, timeout)\n}\n\nexport const reducer = (state: State, action: Action): State => {\n  switch (action.type) {\n    case \"ADD_TOAST\":\n      return {\n        ...state,\n        toasts: [action.toast, ...state.toasts].slice(0, TOAST_LIMIT),\n      }\n\n    case \"UPDATE_TOAST\":\n      return {\n        ...state,\n        toasts: state.toasts.map((t) =>\n          t.id === action.toast.id ? { ...t, ...action.toast } : t\n        ),\n      }\n\n    case \"DISMISS_TOAST\": {\n      const { toastId } = action\n\n      // ! Side effects ! - This could be extracted into a dismissToast() action,\n      // but I'll keep it here for simplicity\n      if (toastId) {\n        addToRemoveQueue(toastId)\n      } else {\n        state.toasts.forEach((toast) => {\n          addToRemoveQueue(toast.id)\n        })\n      }\n\n      return {\n        ...state,\n        toasts: state.toasts.map((t) =>\n          t.id === toastId || toastId === undefined\n            ? {\n                ...t,\n                open: false,\n              }\n            : t\n        ),\n      }\n    }\n    case \"REMOVE_TOAST\":\n      if (action.toastId === undefined) {\n        return {\n          ...state,\n          toasts: [],\n        }\n      }\n      return {\n        ...state,\n        toasts: state.toasts.filter((t) => t.id !== action.toastId),\n      }\n  }\n}\n\nconst listeners: Array<(state: State) => void> = []\n\nlet memoryState: State = { toasts: [] }\n\nfunction dispatch(action: Action) {\n  memoryState = reducer(memoryState, action)\n  listeners.forEach((listener) => {\n    listener(memoryState)\n  })\n}\n\ntype Toast = Omit<ToasterToast, \"id\">\n\nfunction toast({ ...props }: Toast) {\n  const id = genId()\n\n  const update = (props: ToasterToast) =>\n    dispatch({\n      type: \"UPDATE_TOAST\",\n      toast: { ...props, id },\n    })\n  const dismiss = () => dispatch({ type: \"DISMISS_TOAST\", toastId: id })\n\n  dispatch({\n    type: \"ADD_TOAST\",\n    toast: {\n      ...props,\n      id,\n      open: true,\n      onOpenChange: (open) => {\n        if (!open) dismiss()\n      },\n    },\n  })\n\n  return {\n    id: id,\n    dismiss,\n    update,\n  }\n}\n\nfunction useToast() {\n  const [state, setState] = React.useState<State>(memoryState)\n\n  React.useEffect(() => {\n    listeners.push(setState)\n    return () => {\n      const index = listeners.indexOf(setState)\n      if (index > -1) {\n        listeners.splice(index, 1)\n      }\n    }\n  }, [state])\n\n  return {\n    ...state,\n    toast,\n    dismiss: (toastId?: string) => dispatch({ type: \"DISMISS_TOAST\", toastId }),\n  }\n}\n\nexport { useToast, toast }\n","path":null,"size_bytes":3895,"size_tokens":null},"server/static.ts":{"content":"import express, { type Express } from \"express\";\nimport fs from \"fs\";\nimport path from \"path\";\n\nexport function serveStatic(app: Express) {\n  const distPath = path.resolve(__dirname, \"public\");\n  if (!fs.existsSync(distPath)) {\n    throw new Error(\n      `Could not find the build directory: ${distPath}, make sure to build the client first`,\n    );\n  }\n\n  app.use(express.static(distPath));\n\n  // fall through to index.html if the file doesn't exist\n  app.use(\"*\", (_req, res) => {\n    res.sendFile(path.resolve(distPath, \"index.html\"));\n  });\n}\n","path":null,"size_bytes":547,"size_tokens":null},"client/src/lib/walletconnect-service.ts":{"content":"import { Core } from \"@walletconnect/core\";\nimport { Web3Wallet, type Web3WalletTypes, type IWeb3Wallet } from \"@walletconnect/web3wallet\";\nimport { buildApprovedNamespaces, getSdkError } from \"@walletconnect/utils\";\nimport type { SessionTypes, SignClientTypes } from \"@walletconnect/types\";\nimport { ethers } from \"ethers\";\nimport { hardwareWallet } from \"./hardware-wallet\";\n\nconst PROJECT_ID = \"59ef03ea6a2c984a562c685b4bb055c8\";\n\nexport interface DAppSession {\n  topic: string;\n  name: string;\n  url: string;\n  icon?: string;\n  chains: string[];\n  accounts: string[];\n  expiry: number;\n}\n\nexport interface PendingRequest {\n  id: number;\n  topic: string;\n  method: string;\n  params: any;\n  chainId: string;\n  dappName: string;\n  dappIcon?: string;\n}\n\nexport interface SessionProposal {\n  id: number;\n  proposer: {\n    name: string;\n    description: string;\n    url: string;\n    icons: string[];\n  };\n  requiredChains: string[];\n  optionalChains: string[];\n  requiredMethods: string[];\n  optionalMethods: string[];\n  rawProposal: Web3WalletTypes.SessionProposal;\n}\n\ntype SessionRequestHandler = (request: PendingRequest) => void;\ntype SessionProposalHandler = (proposal: SessionProposal) => void;\ntype SessionUpdateHandler = () => void;\n\nclass WalletConnectService {\n  private web3wallet: IWeb3Wallet | null = null;\n  private initialized = false;\n  private initPromise: Promise<void> | null = null;\n  private sessionRequestHandlers: SessionRequestHandler[] = [];\n  private sessionProposalHandlers: SessionProposalHandler[] = [];\n  private sessionUpdateHandlers: SessionUpdateHandler[] = [];\n\n  async init(): Promise<void> {\n    if (this.initialized) return;\n    if (this.initPromise) return this.initPromise;\n\n    this.initPromise = this._doInit();\n    return this.initPromise;\n  }\n\n  private async _doInit(): Promise<void> {\n    try {\n      const core = new Core({\n        projectId: PROJECT_ID,\n      });\n\n      this.web3wallet = await Web3Wallet.init({\n        core,\n        metadata: {\n          name: \"Vault Key\",\n          description: \"Secure Hardware Wallet\",\n          url: \"https://vaultkey.app\",\n          icons: [\"https://vaultkey.app/icon.png\"],\n        },\n      });\n\n      this.setupEventListeners();\n      this.initialized = true;\n    } catch (error) {\n      console.error(\"Failed to initialize WalletConnect:\", error);\n      throw error;\n    }\n  }\n\n  private setupEventListeners(): void {\n    if (!this.web3wallet) return;\n\n    this.web3wallet.on(\"session_proposal\", this.handleSessionProposal.bind(this));\n    this.web3wallet.on(\"session_request\", this.handleSessionRequest.bind(this));\n    this.web3wallet.on(\"session_delete\", () => {\n      this.notifySessionUpdate();\n    });\n  }\n\n  private async handleSessionProposal(proposal: Web3WalletTypes.SessionProposal): Promise<void> {\n    const { requiredNamespaces, optionalNamespaces } = proposal.params;\n    \n    const extractChains = (namespaces: Record<string, any> | undefined): string[] => {\n      if (!namespaces) return [];\n      return Object.values(namespaces).flatMap((ns: any) => ns.chains || []);\n    };\n    \n    const extractMethods = (namespaces: Record<string, any> | undefined): string[] => {\n      if (!namespaces) return [];\n      return Object.values(namespaces).flatMap((ns: any) => ns.methods || []);\n    };\n\n    const sessionProposal: SessionProposal = {\n      id: proposal.id,\n      proposer: {\n        name: proposal.params.proposer.metadata.name,\n        description: proposal.params.proposer.metadata.description,\n        url: proposal.params.proposer.metadata.url,\n        icons: proposal.params.proposer.metadata.icons,\n      },\n      requiredChains: extractChains(requiredNamespaces),\n      optionalChains: extractChains(optionalNamespaces),\n      requiredMethods: extractMethods(requiredNamespaces),\n      optionalMethods: extractMethods(optionalNamespaces),\n      rawProposal: proposal,\n    };\n\n    this.sessionProposalHandlers.forEach(handler => handler(sessionProposal));\n  }\n\n  private async handleSessionRequest(event: Web3WalletTypes.SessionRequest): Promise<void> {\n    const { topic, params, id } = event;\n    const { request, chainId } = params;\n    \n    const session = this.web3wallet?.engine.signClient.session.get(topic);\n    const dappName = session?.peer.metadata.name || \"Unknown DApp\";\n    const dappIcon = session?.peer.metadata.icons?.[0];\n\n    const pendingRequest: PendingRequest = {\n      id,\n      topic,\n      method: request.method,\n      params: request.params,\n      chainId,\n      dappName,\n      dappIcon,\n    };\n\n    this.sessionRequestHandlers.forEach(handler => handler(pendingRequest));\n  }\n\n  private notifySessionUpdate(): void {\n    this.sessionUpdateHandlers.forEach(handler => handler());\n  }\n\n  onSessionRequest(handler: SessionRequestHandler): () => void {\n    this.sessionRequestHandlers.push(handler);\n    return () => {\n      const index = this.sessionRequestHandlers.indexOf(handler);\n      if (index > -1) this.sessionRequestHandlers.splice(index, 1);\n    };\n  }\n\n  onSessionProposal(handler: SessionProposalHandler): () => void {\n    this.sessionProposalHandlers.push(handler);\n    return () => {\n      const index = this.sessionProposalHandlers.indexOf(handler);\n      if (index > -1) this.sessionProposalHandlers.splice(index, 1);\n    };\n  }\n\n  onSessionUpdate(handler: SessionUpdateHandler): () => void {\n    this.sessionUpdateHandlers.push(handler);\n    return () => {\n      const index = this.sessionUpdateHandlers.indexOf(handler);\n      if (index > -1) this.sessionUpdateHandlers.splice(index, 1);\n    };\n  }\n\n  async pair(uri: string): Promise<void> {\n    if (!this.web3wallet) {\n      await this.init();\n    }\n    await this.web3wallet!.core.pairing.pair({ uri });\n  }\n\n  async approveSession(\n    proposal: Web3WalletTypes.SessionProposal,\n    accounts: string[],\n    chainIds: number[] = [1, 56, 137, 43114, 42161]\n  ): Promise<SessionTypes.Struct> {\n    if (!this.web3wallet) throw new Error(\"WalletConnect not initialized\");\n\n    const chains = chainIds.map(id => `eip155:${id}`);\n    const formattedAccounts: string[] = [];\n    for (const account of accounts) {\n      for (const chainId of chainIds) {\n        formattedAccounts.push(`eip155:${chainId}:${account}`);\n      }\n    }\n\n    const namespaces = buildApprovedNamespaces({\n      proposal: proposal.params,\n      supportedNamespaces: {\n        eip155: {\n          chains,\n          methods: [\n            \"eth_sendTransaction\",\n            \"eth_signTransaction\", \n            \"eth_sign\",\n            \"personal_sign\",\n            \"eth_signTypedData\",\n            \"eth_signTypedData_v4\",\n          ],\n          events: [\"chainChanged\", \"accountsChanged\"],\n          accounts: formattedAccounts,\n        },\n      },\n    });\n\n    const session = await this.web3wallet.approveSession({\n      id: proposal.id,\n      namespaces,\n    });\n\n    this.notifySessionUpdate();\n    return session;\n  }\n\n  async rejectSession(proposalId: number): Promise<void> {\n    if (!this.web3wallet) throw new Error(\"WalletConnect not initialized\");\n\n    await this.web3wallet.rejectSession({\n      id: proposalId,\n      reason: getSdkError(\"USER_REJECTED\"),\n    });\n  }\n\n  async approveRequest(topic: string, id: number, result: any): Promise<void> {\n    if (!this.web3wallet) throw new Error(\"WalletConnect not initialized\");\n\n    await this.web3wallet.respondSessionRequest({\n      topic,\n      response: {\n        id,\n        jsonrpc: \"2.0\",\n        result,\n      },\n    });\n  }\n\n  async rejectRequest(topic: string, id: number): Promise<void> {\n    if (!this.web3wallet) throw new Error(\"WalletConnect not initialized\");\n\n    await this.web3wallet.respondSessionRequest({\n      topic,\n      response: {\n        id,\n        jsonrpc: \"2.0\",\n        error: getSdkError(\"USER_REJECTED\"),\n      },\n    });\n  }\n\n  async disconnectSession(topic: string): Promise<void> {\n    if (!this.web3wallet) throw new Error(\"WalletConnect not initialized\");\n\n    await this.web3wallet.disconnectSession({\n      topic,\n      reason: getSdkError(\"USER_DISCONNECTED\"),\n    });\n\n    this.notifySessionUpdate();\n  }\n\n  getSessions(): DAppSession[] {\n    if (!this.web3wallet) return [];\n\n    const sessions = this.web3wallet.getActiveSessions();\n    return Object.values(sessions).map((session) => ({\n      topic: session.topic,\n      name: session.peer.metadata.name,\n      url: session.peer.metadata.url,\n      icon: session.peer.metadata.icons?.[0],\n      chains: Object.keys(session.namespaces).flatMap(\n        (ns) => session.namespaces[ns].chains || []\n      ),\n      accounts: Object.keys(session.namespaces).flatMap(\n        (ns) => session.namespaces[ns].accounts || []\n      ),\n      expiry: session.expiry,\n    }));\n  }\n\n  isWalletUnlocked(): boolean {\n    return hardwareWallet.getState().status === \"unlocked\";\n  }\n\n  async handleSignRequest(request: PendingRequest): Promise<string | null> {\n    if (!this.isWalletUnlocked()) {\n      throw new Error(\"Wallet is locked. Please unlock first.\");\n    }\n\n    const { method, params } = request;\n\n    switch (method) {\n      case \"personal_sign\": {\n        const [message] = params;\n        const decodedMessage = message.startsWith(\"0x\")\n          ? Buffer.from(message.slice(2), \"hex\").toString(\"utf8\")\n          : message;\n        return await hardwareWallet.signMessage(decodedMessage);\n      }\n\n      case \"eth_sign\": {\n        const [, message] = params;\n        return await hardwareWallet.signMessage(message);\n      }\n\n      case \"eth_signTypedData\":\n      case \"eth_signTypedData_v4\": {\n        const [, typedData] = params;\n        const data = typeof typedData === \"string\" ? JSON.parse(typedData) : typedData;\n        const messageHash = this.hashTypedData(data);\n        return await hardwareWallet.signMessage(messageHash);\n      }\n\n      case \"eth_sendTransaction\":\n      case \"eth_signTransaction\": {\n        const [txParams] = params;\n        const chainId = parseInt(request.chainId.split(\":\")[1]) || 1;\n        return await hardwareWallet.signTransaction({\n          to: txParams.to,\n          value: txParams.value || \"0x0\",\n          data: txParams.data || \"0x\",\n          nonce: txParams.nonce ? parseInt(txParams.nonce, 16) : undefined,\n          gasLimit: txParams.gas || txParams.gasLimit,\n          gasPrice: txParams.gasPrice,\n          maxFeePerGas: txParams.maxFeePerGas,\n          maxPriorityFeePerGas: txParams.maxPriorityFeePerGas,\n          chainId,\n        });\n      }\n\n      default:\n        console.warn(\"Unsupported method:\", method);\n        return null;\n    }\n  }\n\n  private hashTypedData(typedData: any): string {\n    const { domain, types, primaryType, message } = typedData;\n    const filtered = { ...types };\n    delete filtered.EIP712Domain;\n    return ethers.TypedDataEncoder.hash(domain, filtered, message);\n  }\n\n  getWeb3Wallet(): IWeb3Wallet | null {\n    return this.web3wallet;\n  }\n\n  isInitialized(): boolean {\n    return this.initialized;\n  }\n}\n\nexport const walletConnectService = new WalletConnectService();\n","path":null,"size_bytes":10989,"size_tokens":null},"client/src/components/ui/hover-card.tsx":{"content":"\"use client\"\n\nimport * as React from \"react\"\nimport * as HoverCardPrimitive from \"@radix-ui/react-hover-card\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst HoverCard = HoverCardPrimitive.Root\n\nconst HoverCardTrigger = HoverCardPrimitive.Trigger\n\nconst HoverCardContent = React.forwardRef<\n  React.ElementRef<typeof HoverCardPrimitive.Content>,\n  React.ComponentPropsWithoutRef<typeof HoverCardPrimitive.Content>\n>(({ className, align = \"center\", sideOffset = 4, ...props }, ref) => (\n  <HoverCardPrimitive.Content\n    ref={ref}\n    align={align}\n    sideOffset={sideOffset}\n    className={cn(\n      \"z-50 w-64 rounded-md border bg-popover p-4 text-popover-foreground shadow-md outline-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 origin-[--radix-hover-card-content-transform-origin]\",\n      className\n    )}\n    {...props}\n  />\n))\nHoverCardContent.displayName = HoverCardPrimitive.Content.displayName\n\nexport { HoverCard, HoverCardTrigger, HoverCardContent }\n","path":null,"size_bytes":1251,"size_tokens":null},"client/src/components/ui/toggle.tsx":{"content":"import * as React from \"react\"\nimport * as TogglePrimitive from \"@radix-ui/react-toggle\"\nimport { cva, type VariantProps } from \"class-variance-authority\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst toggleVariants = cva(\n  \"inline-flex items-center justify-center rounded-md text-sm font-medium ring-offset-background transition-colors hover:bg-muted hover:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 data-[state=on]:bg-accent data-[state=on]:text-accent-foreground [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0 gap-2\",\n  {\n    variants: {\n      variant: {\n        default: \"bg-transparent\",\n        outline:\n          \"border border-input bg-transparent hover:bg-accent hover:text-accent-foreground\",\n      },\n      size: {\n        default: \"h-10 px-3 min-w-10\",\n        sm: \"h-9 px-2.5 min-w-9\",\n        lg: \"h-11 px-5 min-w-11\",\n      },\n    },\n    defaultVariants: {\n      variant: \"default\",\n      size: \"default\",\n    },\n  }\n)\n\nconst Toggle = React.forwardRef<\n  React.ElementRef<typeof TogglePrimitive.Root>,\n  React.ComponentPropsWithoutRef<typeof TogglePrimitive.Root> &\n    VariantProps<typeof toggleVariants>\n>(({ className, variant, size, ...props }, ref) => (\n  <TogglePrimitive.Root\n    ref={ref}\n    className={cn(toggleVariants({ variant, size, className }))}\n    {...props}\n  />\n))\n\nToggle.displayName = TogglePrimitive.Root.displayName\n\nexport { Toggle, toggleVariants }\n","path":null,"size_bytes":1527,"size_tokens":null},"client/src/components/ui/command.tsx":{"content":"import * as React from \"react\"\nimport { type DialogProps } from \"@radix-ui/react-dialog\"\nimport { Command as CommandPrimitive } from \"cmdk\"\nimport { Search } from \"lucide-react\"\n\nimport { cn } from \"@/lib/utils\"\nimport { Dialog, DialogContent } from \"@/components/ui/dialog\"\n\nconst Command = React.forwardRef<\n  React.ElementRef<typeof CommandPrimitive>,\n  React.ComponentPropsWithoutRef<typeof CommandPrimitive>\n>(({ className, ...props }, ref) => (\n  <CommandPrimitive\n    ref={ref}\n    className={cn(\n      \"flex h-full w-full flex-col overflow-hidden rounded-md bg-popover text-popover-foreground\",\n      className\n    )}\n    {...props}\n  />\n))\nCommand.displayName = CommandPrimitive.displayName\n\nconst CommandDialog = ({ children, ...props }: DialogProps) => {\n  return (\n    <Dialog {...props}>\n      <DialogContent className=\"overflow-hidden p-0 shadow-lg\">\n        <Command className=\"[&_[cmdk-group-heading]]:px-2 [&_[cmdk-group-heading]]:font-medium [&_[cmdk-group-heading]]:text-muted-foreground [&_[cmdk-group]:not([hidden])_~[cmdk-group]]:pt-0 [&_[cmdk-group]]:px-2 [&_[cmdk-input-wrapper]_svg]:h-5 [&_[cmdk-input-wrapper]_svg]:w-5 [&_[cmdk-input]]:h-12 [&_[cmdk-item]]:px-2 [&_[cmdk-item]]:py-3 [&_[cmdk-item]_svg]:h-5 [&_[cmdk-item]_svg]:w-5\">\n          {children}\n        </Command>\n      </DialogContent>\n    </Dialog>\n  )\n}\n\nconst CommandInput = React.forwardRef<\n  React.ElementRef<typeof CommandPrimitive.Input>,\n  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Input>\n>(({ className, ...props }, ref) => (\n  <div className=\"flex items-center border-b px-3\" cmdk-input-wrapper=\"\">\n    <Search className=\"mr-2 h-4 w-4 shrink-0 opacity-50\" />\n    <CommandPrimitive.Input\n      ref={ref}\n      className={cn(\n        \"flex h-11 w-full rounded-md bg-transparent py-3 text-sm outline-none placeholder:text-muted-foreground disabled:cursor-not-allowed disabled:opacity-50\",\n        className\n      )}\n      {...props}\n    />\n  </div>\n))\n\nCommandInput.displayName = CommandPrimitive.Input.displayName\n\nconst CommandList = React.forwardRef<\n  React.ElementRef<typeof CommandPrimitive.List>,\n  React.ComponentPropsWithoutRef<typeof CommandPrimitive.List>\n>(({ className, ...props }, ref) => (\n  <CommandPrimitive.List\n    ref={ref}\n    className={cn(\"max-h-[300px] overflow-y-auto overflow-x-hidden\", className)}\n    {...props}\n  />\n))\n\nCommandList.displayName = CommandPrimitive.List.displayName\n\nconst CommandEmpty = React.forwardRef<\n  React.ElementRef<typeof CommandPrimitive.Empty>,\n  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Empty>\n>((props, ref) => (\n  <CommandPrimitive.Empty\n    ref={ref}\n    className=\"py-6 text-center text-sm\"\n    {...props}\n  />\n))\n\nCommandEmpty.displayName = CommandPrimitive.Empty.displayName\n\nconst CommandGroup = React.forwardRef<\n  React.ElementRef<typeof CommandPrimitive.Group>,\n  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Group>\n>(({ className, ...props }, ref) => (\n  <CommandPrimitive.Group\n    ref={ref}\n    className={cn(\n      \"overflow-hidden p-1 text-foreground [&_[cmdk-group-heading]]:px-2 [&_[cmdk-group-heading]]:py-1.5 [&_[cmdk-group-heading]]:text-xs [&_[cmdk-group-heading]]:font-medium [&_[cmdk-group-heading]]:text-muted-foreground\",\n      className\n    )}\n    {...props}\n  />\n))\n\nCommandGroup.displayName = CommandPrimitive.Group.displayName\n\nconst CommandSeparator = React.forwardRef<\n  React.ElementRef<typeof CommandPrimitive.Separator>,\n  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Separator>\n>(({ className, ...props }, ref) => (\n  <CommandPrimitive.Separator\n    ref={ref}\n    className={cn(\"-mx-1 h-px bg-border\", className)}\n    {...props}\n  />\n))\nCommandSeparator.displayName = CommandPrimitive.Separator.displayName\n\nconst CommandItem = React.forwardRef<\n  React.ElementRef<typeof CommandPrimitive.Item>,\n  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Item>\n>(({ className, ...props }, ref) => (\n  <CommandPrimitive.Item\n    ref={ref}\n    className={cn(\n      \"relative flex cursor-default gap-2 select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none data-[disabled=true]:pointer-events-none data-[selected='true']:bg-accent data-[selected=true]:text-accent-foreground data-[disabled=true]:opacity-50 [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0\",\n      className\n    )}\n    {...props}\n  />\n))\n\nCommandItem.displayName = CommandPrimitive.Item.displayName\n\nconst CommandShortcut = ({\n  className,\n  ...props\n}: React.HTMLAttributes<HTMLSpanElement>) => {\n  return (\n    <span\n      className={cn(\n        \"ml-auto text-xs tracking-widest text-muted-foreground\",\n        className\n      )}\n      {...props}\n    />\n  )\n}\nCommandShortcut.displayName = \"CommandShortcut\"\n\nexport {\n  Command,\n  CommandDialog,\n  CommandInput,\n  CommandList,\n  CommandEmpty,\n  CommandGroup,\n  CommandItem,\n  CommandShortcut,\n  CommandSeparator,\n}\n","path":null,"size_bytes":4885,"size_tokens":null},"client/src/pages/dapp-browser.tsx":{"content":"import { useState, useEffect, useRef } from \"react\";\nimport { ExternalLink, ChevronDown, Globe, RefreshCw, X } from \"lucide-react\";\nimport { BackButton } from \"@/components/back-button\";\nimport { Card, CardContent } from \"@/components/ui/card\";\nimport { Button } from \"@/components/ui/button\";\nimport { Input } from \"@/components/ui/input\";\nimport {\n  DropdownMenu,\n  DropdownMenuContent,\n  DropdownMenuItem,\n  DropdownMenuTrigger,\n} from \"@/components/ui/dropdown-menu\";\nimport { useWallet } from \"@/lib/wallet-context\";\nimport { useToast } from \"@/hooks/use-toast\";\nimport { ChainIcon } from \"@/components/chain-icon\";\nimport { useLocation, Link } from \"wouter\";\nimport { DEFAULT_CHAINS } from \"@shared/schema\";\n\nconst EVM_CHAINS = DEFAULT_CHAINS.filter(c => c.chainId > 0);\n\nexport default function DAppBrowser() {\n  const { isConnected, isUnlocked, wallets, chains } = useWallet();\n  const { toast } = useToast();\n  const [location, setLocation] = useLocation();\n  const [url, setUrl] = useState(\"\");\n  const [currentUrl, setCurrentUrl] = useState(\"\");\n  const [selectedChainId, setSelectedChainId] = useState<number>(1);\n  const [isLoading, setIsLoading] = useState(false);\n  const [iframeError, setIframeError] = useState(false);\n  const iframeRef = useRef<HTMLIFrameElement>(null);\n\n  const urlParams = new URLSearchParams(location.split(\"?\")[1] || \"\");\n  const initialUrl = urlParams.get(\"url\");\n\n  useEffect(() => {\n    if (initialUrl) {\n      const decodedUrl = decodeURIComponent(initialUrl);\n      setUrl(decodedUrl);\n      setCurrentUrl(decodedUrl);\n    }\n  }, [initialUrl]);\n\n  const selectedChain = EVM_CHAINS.find(c => c.chainId === selectedChainId) || EVM_CHAINS[0];\n  const currentWallet = wallets.find(w => {\n    const chain = chains.find(c => c.id === w.chainId);\n    return chain?.chainId === selectedChainId;\n  }) || wallets[0];\n\n  const handleNavigate = () => {\n    if (!url.trim()) return;\n    let formattedUrl = url.trim();\n    if (!formattedUrl.startsWith(\"http://\") && !formattedUrl.startsWith(\"https://\")) {\n      formattedUrl = \"https://\" + formattedUrl;\n    }\n    setCurrentUrl(formattedUrl);\n    setIframeError(false);\n    setIsLoading(true);\n  };\n\n  const handleRefresh = () => {\n    if (iframeRef.current && currentUrl) {\n      setIsLoading(true);\n      setIframeError(false);\n      iframeRef.current.src = currentUrl;\n    }\n  };\n\n  const handleIframeLoad = () => {\n    setIsLoading(false);\n  };\n\n  const handleIframeError = () => {\n    setIsLoading(false);\n    setIframeError(true);\n  };\n\n  const handleChainSwitch = (chainId: number) => {\n    setSelectedChainId(chainId);\n    toast({\n      title: \"Chain Switched\",\n      description: `Switched to ${EVM_CHAINS.find(c => c.chainId === chainId)?.name}`,\n    });\n  };\n\n  const openExternal = () => {\n    if (currentUrl) {\n      window.open(currentUrl, \"_blank\");\n    }\n  };\n\n  if (!isConnected || !isUnlocked) {\n    return (\n      <div className=\"p-6\">\n        <h1 className=\"mb-6 text-3xl font-bold\">DApp Browser</h1>\n        <Card>\n          <CardContent className=\"py-12 text-center\">\n            <Globe className=\"mx-auto h-12 w-12 text-muted-foreground/50 mb-4\" />\n            <p className=\"text-muted-foreground\">Connect your wallet to use the DApp browser</p>\n            <Button variant=\"outline\" className=\"mt-4\" asChild>\n              <Link href=\"/\">Go to Dashboard</Link>\n            </Button>\n          </CardContent>\n        </Card>\n      </div>\n    );\n  }\n\n  return (\n    <div className=\"flex flex-col h-full\">\n      <div className=\"border-b bg-background/95 backdrop-blur supports-[backdrop-filter]:bg-background/60\">\n        <div className=\"flex items-center gap-1.5 p-2\">\n          <BackButton fallbackPath=\"/dapps\" />\n\n          <div className=\"flex-1 flex items-center gap-1.5 bg-muted/50 rounded-lg px-2 py-1\">\n            <Input\n              value={url}\n              onChange={(e) => setUrl(e.target.value)}\n              onKeyDown={(e) => e.key === \"Enter\" && handleNavigate()}\n              placeholder=\"Enter URL...\"\n              className=\"flex-1 border-0 bg-transparent h-8 text-sm focus-visible:ring-0 px-1\"\n              data-testid=\"input-browser-url\"\n            />\n            <Button size=\"sm\" onClick={handleNavigate} className=\"h-7 px-3\" data-testid=\"button-go\">\n              Go\n            </Button>\n          </div>\n\n          <DropdownMenu>\n            <DropdownMenuTrigger asChild>\n              <Button variant=\"outline\" size=\"icon\" data-testid=\"button-chain-selector\">\n                <ChainIcon symbol={selectedChain.symbol} iconColor={selectedChain.iconColor} size=\"sm\" />\n              </Button>\n            </DropdownMenuTrigger>\n            <DropdownMenuContent align=\"end\" className=\"w-48\">\n              {EVM_CHAINS.map((chain) => (\n                <DropdownMenuItem\n                  key={chain.chainId}\n                  onClick={() => handleChainSwitch(chain.chainId)}\n                  className=\"gap-2\"\n                  data-testid={`menu-chain-${chain.symbol.toLowerCase()}`}\n                >\n                  <ChainIcon symbol={chain.symbol} iconColor={chain.iconColor} size=\"sm\" />\n                  {chain.name}\n                  {chain.chainId === selectedChainId && (\n                    <span className=\"ml-auto text-primary\">•</span>\n                  )}\n                </DropdownMenuItem>\n              ))}\n            </DropdownMenuContent>\n          </DropdownMenu>\n\n        </div>\n      </div>\n\n      <div className=\"flex-1 relative bg-muted/30\">\n        {!currentUrl ? (\n          <div className=\"absolute inset-0 flex items-center justify-center\">\n            <div className=\"text-center max-w-md p-6\">\n              <Globe className=\"mx-auto h-16 w-16 text-muted-foreground/30 mb-4\" />\n              <h2 className=\"text-xl font-semibold mb-2\">DApp Browser</h2>\n              <p className=\"text-muted-foreground mb-4\">\n                Enter a DApp URL above to browse decentralized applications with your connected wallet.\n              </p>\n              <div className=\"grid grid-cols-2 gap-2\">\n                {[\n                  { name: \"PancakeSwap\", url: \"pancakeswap.finance\" },\n                  { name: \"Uniswap\", url: \"app.uniswap.org\" },\n                  { name: \"Aave\", url: \"app.aave.com\" },\n                  { name: \"1inch\", url: \"app.1inch.io\" },\n                ].map((dapp) => (\n                  <Button\n                    key={dapp.name}\n                    variant=\"outline\"\n                    size=\"sm\"\n                    onClick={() => {\n                      setUrl(\"https://\" + dapp.url);\n                      setCurrentUrl(\"https://\" + dapp.url);\n                      setIsLoading(true);\n                    }}\n                    data-testid={`quick-${dapp.name.toLowerCase()}`}\n                  >\n                    {dapp.name}\n                  </Button>\n                ))}\n              </div>\n            </div>\n          </div>\n        ) : iframeError ? (\n          <div className=\"absolute inset-0 flex items-center justify-center\">\n            <div className=\"text-center max-w-md p-6\">\n              <X className=\"mx-auto h-16 w-16 text-destructive/50 mb-4\" />\n              <h2 className=\"text-xl font-semibold mb-2\">Cannot Load DApp</h2>\n              <p className=\"text-muted-foreground mb-4\">\n                This DApp cannot be embedded due to security restrictions. \n                Please open it in a new tab and use WalletConnect to connect.\n              </p>\n              <div className=\"flex gap-2 justify-center\">\n                <Button variant=\"outline\" onClick={openExternal}>\n                  <ExternalLink className=\"mr-2 h-4 w-4\" />\n                  Open in New Tab\n                </Button>\n                <Button variant=\"outline\" asChild>\n                  <Link href=\"/dapps\">\n                    Back to DApps\n                  </Link>\n                </Button>\n              </div>\n            </div>\n          </div>\n        ) : (\n          <>\n            {isLoading && (\n              <div className=\"absolute inset-0 flex items-center justify-center bg-background/80 z-10\">\n                <RefreshCw className=\"h-8 w-8 animate-spin text-muted-foreground\" />\n              </div>\n            )}\n            <iframe\n              ref={iframeRef}\n              src={currentUrl}\n              className=\"w-full h-full border-0\"\n              onLoad={handleIframeLoad}\n              onError={handleIframeError}\n              sandbox=\"allow-scripts allow-same-origin allow-forms allow-popups allow-popups-to-escape-sandbox\"\n              data-testid=\"iframe-dapp\"\n            />\n          </>\n        )}\n      </div>\n    </div>\n  );\n}\n","path":null,"size_bytes":8665,"size_tokens":null},"client/src/components/ui/textarea.tsx":{"content":"import * as React from \"react\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst Textarea = React.forwardRef<\n  HTMLTextAreaElement,\n  React.ComponentProps<\"textarea\">\n>(({ className, ...props }, ref) => {\n  return (\n    <textarea\n      className={cn(\n        \"flex min-h-[80px] w-full rounded-md border border-input bg-background px-3 py-2 text-base ring-offset-background placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 md:text-sm\",\n        className\n      )}\n      ref={ref}\n      {...props}\n    />\n  )\n})\nTextarea.displayName = \"Textarea\"\n\nexport { Textarea }\n","path":null,"size_bytes":689,"size_tokens":null},"server/vite.ts":{"content":"import { type Express } from \"express\";\nimport { createServer as createViteServer, createLogger } from \"vite\";\nimport { type Server } from \"http\";\nimport viteConfig from \"../vite.config\";\nimport fs from \"fs\";\nimport path from \"path\";\nimport { nanoid } from \"nanoid\";\n\nconst viteLogger = createLogger();\n\nexport async function setupVite(server: Server, app: Express) {\n  const serverOptions = {\n    middlewareMode: true,\n    hmr: { server, path: \"/vite-hmr\" },\n    allowedHosts: true as const,\n  };\n\n  const vite = await createViteServer({\n    ...viteConfig,\n    configFile: false,\n    customLogger: {\n      ...viteLogger,\n      error: (msg, options) => {\n        viteLogger.error(msg, options);\n        process.exit(1);\n      },\n    },\n    server: serverOptions,\n    appType: \"custom\",\n  });\n\n  app.use(vite.middlewares);\n\n  app.use(\"*\", async (req, res, next) => {\n    const url = req.originalUrl;\n\n    try {\n      const clientTemplate = path.resolve(\n        import.meta.dirname,\n        \"..\",\n        \"client\",\n        \"index.html\",\n      );\n\n      // always reload the index.html file from disk incase it changes\n      let template = await fs.promises.readFile(clientTemplate, \"utf-8\");\n      template = template.replace(\n        `src=\"/src/main.tsx\"`,\n        `src=\"/src/main.tsx?v=${nanoid()}\"`,\n      );\n      const page = await vite.transformIndexHtml(url, template);\n      res.status(200).set({ \"Content-Type\": \"text/html\" }).end(page);\n    } catch (e) {\n      vite.ssrFixStacktrace(e as Error);\n      next(e);\n    }\n  });\n}\n","path":null,"size_bytes":1534,"size_tokens":null},"client/src/components/ui/calendar.tsx":{"content":"import * as React from \"react\"\nimport { ChevronLeft, ChevronRight } from \"lucide-react\"\nimport { DayPicker } from \"react-day-picker\"\n\nimport { cn } from \"@/lib/utils\"\nimport { buttonVariants } from \"@/components/ui/button\"\n\nexport type CalendarProps = React.ComponentProps<typeof DayPicker>\n\nfunction Calendar({\n  className,\n  classNames,\n  showOutsideDays = true,\n  ...props\n}: CalendarProps) {\n  return (\n    <DayPicker\n      showOutsideDays={showOutsideDays}\n      className={cn(\"p-3\", className)}\n      classNames={{\n        months: \"flex flex-col sm:flex-row space-y-4 sm:space-x-4 sm:space-y-0\",\n        month: \"space-y-4\",\n        caption: \"flex justify-center pt-1 relative items-center\",\n        caption_label: \"text-sm font-medium\",\n        nav: \"space-x-1 flex items-center\",\n        nav_button: cn(\n          buttonVariants({ variant: \"outline\" }),\n          \"h-7 w-7 bg-transparent p-0 opacity-50 hover:opacity-100\"\n        ),\n        nav_button_previous: \"absolute left-1\",\n        nav_button_next: \"absolute right-1\",\n        table: \"w-full border-collapse space-y-1\",\n        head_row: \"flex\",\n        head_cell:\n          \"text-muted-foreground rounded-md w-9 font-normal text-[0.8rem]\",\n        row: \"flex w-full mt-2\",\n        cell: \"h-9 w-9 text-center text-sm p-0 relative [&:has([aria-selected].day-range-end)]:rounded-r-md [&:has([aria-selected].day-outside)]:bg-accent/50 [&:has([aria-selected])]:bg-accent first:[&:has([aria-selected])]:rounded-l-md last:[&:has([aria-selected])]:rounded-r-md focus-within:relative focus-within:z-20\",\n        day: cn(\n          buttonVariants({ variant: \"ghost\" }),\n          \"h-9 w-9 p-0 font-normal aria-selected:opacity-100\"\n        ),\n        day_range_end: \"day-range-end\",\n        day_selected:\n          \"bg-primary text-primary-foreground hover:bg-primary hover:text-primary-foreground focus:bg-primary focus:text-primary-foreground\",\n        day_today: \"bg-accent text-accent-foreground\",\n        day_outside:\n          \"day-outside text-muted-foreground aria-selected:bg-accent/50 aria-selected:text-muted-foreground\",\n        day_disabled: \"text-muted-foreground opacity-50\",\n        day_range_middle:\n          \"aria-selected:bg-accent aria-selected:text-accent-foreground\",\n        day_hidden: \"invisible\",\n        ...classNames,\n      }}\n      components={{\n        IconLeft: ({ className, ...props }) => (\n          <ChevronLeft className={cn(\"h-4 w-4\", className)} {...props} />\n        ),\n        IconRight: ({ className, ...props }) => (\n          <ChevronRight className={cn(\"h-4 w-4\", className)} {...props} />\n        ),\n      }}\n      {...props}\n    />\n  )\n}\nCalendar.displayName = \"Calendar\"\n\nexport { Calendar }\n","path":null,"size_bytes":2695,"size_tokens":null},"client/src/components/ui/checkbox.tsx":{"content":"import * as React from \"react\"\nimport * as CheckboxPrimitive from \"@radix-ui/react-checkbox\"\nimport { Check } from \"lucide-react\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst Checkbox = React.forwardRef<\n  React.ElementRef<typeof CheckboxPrimitive.Root>,\n  React.ComponentPropsWithoutRef<typeof CheckboxPrimitive.Root>\n>(({ className, ...props }, ref) => (\n  <CheckboxPrimitive.Root\n    ref={ref}\n    className={cn(\n      \"peer h-4 w-4 shrink-0 rounded-sm border border-primary ring-offset-background focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 data-[state=checked]:bg-primary data-[state=checked]:text-primary-foreground\",\n      className\n    )}\n    {...props}\n  >\n    <CheckboxPrimitive.Indicator\n      className={cn(\"flex items-center justify-center text-current\")}\n    >\n      <Check className=\"h-4 w-4\" />\n    </CheckboxPrimitive.Indicator>\n  </CheckboxPrimitive.Root>\n))\nCheckbox.displayName = CheckboxPrimitive.Root.displayName\n\nexport { Checkbox }\n","path":null,"size_bytes":1056,"size_tokens":null},"client/src/components/ui/label.tsx":{"content":"import * as React from \"react\"\nimport * as LabelPrimitive from \"@radix-ui/react-label\"\nimport { cva, type VariantProps } from \"class-variance-authority\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst labelVariants = cva(\n  \"text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70\"\n)\n\nconst Label = React.forwardRef<\n  React.ElementRef<typeof LabelPrimitive.Root>,\n  React.ComponentPropsWithoutRef<typeof LabelPrimitive.Root> &\n    VariantProps<typeof labelVariants>\n>(({ className, ...props }, ref) => (\n  <LabelPrimitive.Root\n    ref={ref}\n    className={cn(labelVariants(), className)}\n    {...props}\n  />\n))\nLabel.displayName = LabelPrimitive.Root.displayName\n\nexport { Label }\n","path":null,"size_bytes":710,"size_tokens":null},"client/src/lib/explorer-service.ts":{"content":"import { ethers } from \"ethers\";\nimport { clientStorage, type StoredTransaction } from \"./client-storage\";\n\nexport interface ExplorerTransaction {\n  hash: string;\n  from: string;\n  to: string;\n  value: string;\n  timeStamp: string;\n  isError: string;\n  blockNumber: string;\n  gasUsed: string;\n}\n\nexport interface TokenTransfer {\n  hash: string;\n  from: string;\n  to: string;\n  value: string;\n  timeStamp: string;\n  tokenName: string;\n  tokenSymbol: string;\n  tokenDecimal: string;\n  contractAddress: string;\n}\n\nexport interface ParsedTransaction {\n  id: string;\n  txHash: string;\n  fromAddress: string;\n  toAddress: string;\n  amount: string;\n  timestamp: string;\n  type: \"send\" | \"receive\";\n  status: \"confirmed\" | \"failed\";\n  chainId: string;\n  tokenSymbol: string;\n  walletId: string;\n  isTokenTransfer?: boolean;\n  contractAddress?: string;\n}\n\nconst CHAIN_SYMBOLS: Record<number, string> = {\n  1: \"ETH\",\n  56: \"BNB\",\n  137: \"MATIC\",\n  43114: \"AVAX\",\n  42161: \"ETH\",\n  10: \"ETH\",\n};\n\nconst BLOCKSCOUT_APIS: Record<number, string> = {\n  1: \"https://eth.blockscout.com/api\",\n  137: \"https://polygon.blockscout.com/api\",\n  42161: \"https://arbitrum.blockscout.com/api\",\n  10: \"https://optimism.blockscout.com/api\",\n};\n\nconst PUBLIC_RPC_ENDPOINTS: Record<number, string> = {\n  56: \"https://bsc-mainnet.public.blastapi.io\",\n  43114: \"https://api.avax.network/ext/bc/C/rpc\",\n};\n\nconst ERC20_TRANSFER_TOPIC = \"0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef\";\n\nlet fetchCache: Map<string, { data: ParsedTransaction[]; timestamp: number }> = new Map();\nconst CACHE_DURATION = 60000;\n\nasync function fetchTokenTransfersViaRpc(\n  address: string,\n  chainId: number,\n  walletId: string,\n  walletChainId: string\n): Promise<ParsedTransaction[]> {\n  const rpcUrl = PUBLIC_RPC_ENDPOINTS[chainId];\n  if (!rpcUrl) return [];\n\n  try {\n    const provider = new ethers.JsonRpcProvider(rpcUrl);\n    const currentBlock = await provider.getBlockNumber();\n    \n    const paddedAddress = \"0x\" + address.slice(2).toLowerCase().padStart(64, \"0\");\n    const transactions: ParsedTransaction[] = [];\n    const lowerAddress = address.toLowerCase();\n    \n    const blockRange = 2000;\n    const iterations = 5;\n    \n    for (let i = 0; i < iterations; i++) {\n      const toBlock = currentBlock - (i * blockRange);\n      const fromBlock = toBlock - blockRange + 1;\n      if (fromBlock < 0) break;\n\n      try {\n        const [receivedLogs, sentLogs] = await Promise.all([\n          provider.getLogs({\n            fromBlock,\n            toBlock,\n            topics: [ERC20_TRANSFER_TOPIC, null, paddedAddress],\n          }),\n          provider.getLogs({\n            fromBlock,\n            toBlock,\n            topics: [ERC20_TRANSFER_TOPIC, paddedAddress, null],\n          }),\n        ]);\n\n        for (const log of [...receivedLogs, ...sentLogs]) {\n          const fromAddr = \"0x\" + log.topics[1]?.slice(26);\n          const toAddr = \"0x\" + log.topics[2]?.slice(26);\n          const isReceive = toAddr.toLowerCase() === lowerAddress;\n\n          let decimals = 18;\n          let symbol = \"TOKEN\";\n          try {\n            const erc20 = new ethers.Contract(log.address, [\n              \"function decimals() view returns (uint8)\",\n              \"function symbol() view returns (string)\",\n            ], provider);\n            [decimals, symbol] = await Promise.all([erc20.decimals(), erc20.symbol()]);\n          } catch {}\n\n          const amount = ethers.formatUnits(log.data, decimals);\n          const block = await provider.getBlock(log.blockNumber);\n\n          transactions.push({\n            id: `rpc-${log.transactionHash}-${log.index}`,\n            txHash: log.transactionHash,\n            fromAddress: fromAddr,\n            toAddress: toAddr,\n            amount,\n            timestamp: block?.timestamp ? new Date(block.timestamp * 1000).toISOString() : new Date().toISOString(),\n            type: isReceive ? \"receive\" : \"send\",\n            status: \"confirmed\",\n            chainId: walletChainId,\n            tokenSymbol: symbol,\n            walletId,\n            isTokenTransfer: true,\n            contractAddress: log.address,\n          });\n        }\n      } catch (e) {\n        console.error(`Error fetching block range ${fromBlock}-${toBlock}:`, e);\n      }\n    }\n\n    return transactions.sort((a, b) => \n      new Date(b.timestamp).getTime() - new Date(a.timestamp).getTime()\n    ).slice(0, 50);\n  } catch (error) {\n    console.error(\"Error fetching via RPC:\", error);\n    return [];\n  }\n}\n\nasync function fetchFromExplorerApi(\n  address: string,\n  chainId: number,\n  walletId: string,\n  walletChainId: string,\n  chainSymbol: string\n): Promise<ParsedTransaction[]> {\n  const apiUrl = BLOCKSCOUT_APIS[chainId];\n  if (!apiUrl) return [];\n\n  try {\n    const url = `${apiUrl}?module=account&action=txlist&address=${address}&startblock=0&endblock=99999999&page=1&offset=50&sort=desc`;\n    const response = await fetch(url, { signal: AbortSignal.timeout(10000) });\n    \n    if (!response.ok) return [];\n    \n    const data = await response.json();\n    if (data.status !== \"1\" || !Array.isArray(data.result)) return [];\n\n    const lowerAddress = address.toLowerCase();\n    const symbol = CHAIN_SYMBOLS[chainId] || chainSymbol || \"ETH\";\n\n    return data.result.map((tx: ExplorerTransaction) => {\n      const isReceive = tx.to.toLowerCase() === lowerAddress;\n      const valueInEth = ethers.formatEther(tx.value || \"0\");\n      \n      return {\n        id: `explorer-${tx.hash}`,\n        txHash: tx.hash,\n        fromAddress: tx.from,\n        toAddress: tx.to,\n        amount: valueInEth,\n        timestamp: new Date(parseInt(tx.timeStamp) * 1000).toISOString(),\n        type: isReceive ? \"receive\" : \"send\",\n        status: tx.isError === \"0\" ? \"confirmed\" : \"failed\",\n        chainId: walletChainId,\n        tokenSymbol: symbol,\n        walletId: walletId,\n        isTokenTransfer: false,\n      };\n    });\n  } catch {\n    return [];\n  }\n}\n\nasync function fetchBtcTransactions(\n  address: string,\n  walletId: string,\n  walletChainId: string\n): Promise<ParsedTransaction[]> {\n  try {\n    const response = await fetch(\n      `https://blockstream.info/api/address/${address}/txs`,\n      { signal: AbortSignal.timeout(10000) }\n    );\n    if (!response.ok) return [];\n    \n    const txs = await response.json();\n    if (!Array.isArray(txs)) return [];\n\n    return txs.slice(0, 50).map((tx: any) => {\n      const isReceive = tx.vout?.some((out: any) => \n        out.scriptpubkey_address === address\n      );\n      \n      let amount = 0;\n      if (isReceive) {\n        amount = tx.vout\n          .filter((out: any) => out.scriptpubkey_address === address)\n          .reduce((sum: number, out: any) => sum + (out.value || 0), 0) / 100000000;\n      } else {\n        amount = tx.vin?.reduce((sum: number, input: any) => {\n          if (input.prevout?.scriptpubkey_address === address) {\n            return sum + (input.prevout.value || 0);\n          }\n          return sum;\n        }, 0) / 100000000 || 0;\n      }\n\n      return {\n        id: `btc-${tx.txid}`,\n        txHash: tx.txid,\n        fromAddress: isReceive ? \"Unknown\" : address,\n        toAddress: isReceive ? address : \"Unknown\",\n        amount: amount.toString(),\n        timestamp: tx.status?.block_time \n          ? new Date(tx.status.block_time * 1000).toISOString()\n          : new Date().toISOString(),\n        type: isReceive ? \"receive\" : \"send\",\n        status: tx.status?.confirmed ? \"confirmed\" : \"failed\",\n        chainId: walletChainId,\n        tokenSymbol: \"BTC\",\n        walletId: walletId,\n        isTokenTransfer: false,\n      };\n    });\n  } catch {\n    return [];\n  }\n}\n\nexport async function fetchTransactionHistory(\n  address: string,\n  chainId: number,\n  walletId: string,\n  walletChainId: string,\n  chainSymbol: string,\n  blockExplorerUrl?: string\n): Promise<ParsedTransaction[]> {\n  const cacheKey = `native-${address}-${chainId}-${chainSymbol}`;\n  const cached = fetchCache.get(cacheKey);\n\n  if (cached && Date.now() - cached.timestamp < CACHE_DURATION) {\n    return cached.data;\n  }\n\n  let transactions: ParsedTransaction[] = [];\n\n  if (chainId === 0) {\n    switch (chainSymbol.toUpperCase()) {\n      case 'BTC':\n        transactions = await fetchBtcTransactions(address, walletId, walletChainId);\n        break;\n      default:\n        transactions = [];\n    }\n  } else {\n    transactions = await fetchFromExplorerApi(address, chainId, walletId, walletChainId, chainSymbol);\n  }\n\n  if (transactions.length > 0) {\n    fetchCache.set(cacheKey, { data: transactions, timestamp: Date.now() });\n  }\n\n  return transactions;\n}\n\nexport async function fetchTokenTransfers(\n  address: string,\n  chainId: number,\n  walletId: string,\n  walletChainId: string,\n  blockExplorerUrl?: string\n): Promise<ParsedTransaction[]> {\n  if (chainId === 0) return [];\n\n  const cacheKey = `tokens-${address}-${chainId}`;\n  const cached = fetchCache.get(cacheKey);\n\n  if (cached && Date.now() - cached.timestamp < CACHE_DURATION) {\n    return cached.data;\n  }\n\n  const apiUrl = BLOCKSCOUT_APIS[chainId];\n  \n  if (PUBLIC_RPC_ENDPOINTS[chainId] && !apiUrl) {\n    const rpcTransactions = await fetchTokenTransfersViaRpc(address, chainId, walletId, walletChainId);\n    if (rpcTransactions.length > 0) {\n      fetchCache.set(cacheKey, { data: rpcTransactions, timestamp: Date.now() });\n    }\n    return rpcTransactions;\n  }\n  \n  if (!apiUrl) return [];\n\n  try {\n    const url = `${apiUrl}?module=account&action=tokentx&address=${address}&startblock=0&endblock=99999999&page=1&offset=50&sort=desc`;\n    const response = await fetch(url, { signal: AbortSignal.timeout(10000) });\n\n    if (!response.ok) return [];\n\n    const data = await response.json();\n    if (data.status !== \"1\" || !Array.isArray(data.result)) return [];\n\n    const lowerAddress = address.toLowerCase();\n\n    const parsed: ParsedTransaction[] = data.result.map((tx: TokenTransfer) => {\n      const isReceive = tx.to.toLowerCase() === lowerAddress;\n      const decimals = parseInt(tx.tokenDecimal) || 18;\n      const amount = ethers.formatUnits(tx.value || \"0\", decimals);\n\n      return {\n        id: `token-${tx.hash}-${tx.contractAddress}`,\n        txHash: tx.hash,\n        fromAddress: tx.from,\n        toAddress: tx.to,\n        amount: amount,\n        timestamp: new Date(parseInt(tx.timeStamp) * 1000).toISOString(),\n        type: isReceive ? \"receive\" : \"send\",\n        status: \"confirmed\",\n        chainId: walletChainId,\n        tokenSymbol: tx.tokenSymbol || \"TOKEN\",\n        walletId: walletId,\n        isTokenTransfer: true,\n        contractAddress: tx.contractAddress,\n      };\n    });\n\n    fetchCache.set(cacheKey, { data: parsed, timestamp: Date.now() });\n    return parsed;\n  } catch {\n    return [];\n  }\n}\n\nfunction convertStoredToParesed(stored: StoredTransaction): ParsedTransaction {\n  return {\n    id: stored.id,\n    txHash: stored.txHash || '',\n    fromAddress: stored.fromAddress,\n    toAddress: stored.toAddress,\n    amount: stored.amount,\n    timestamp: stored.timestamp,\n    type: stored.type,\n    status: stored.status === 'pending' ? 'confirmed' : stored.status,\n    chainId: stored.chainId,\n    tokenSymbol: stored.tokenSymbol,\n    walletId: stored.walletId,\n    isTokenTransfer: stored.tokenSymbol !== 'ETH' && stored.tokenSymbol !== 'BNB' && \n                     stored.tokenSymbol !== 'MATIC' && stored.tokenSymbol !== 'AVAX' &&\n                     stored.tokenSymbol !== 'BTC' && stored.tokenSymbol !== 'SOL' &&\n                     stored.tokenSymbol !== 'TRX' && stored.tokenSymbol !== 'DOGE' &&\n                     stored.tokenSymbol !== 'LTC' && stored.tokenSymbol !== 'BCH' &&\n                     stored.tokenSymbol !== 'XRP',\n  };\n}\n\nexport async function fetchAllTransactions(\n  wallets: Array<{\n    id: string;\n    address: string;\n    chainId: string;\n    numericChainId: number;\n    chainSymbol: string;\n    blockExplorerUrl?: string;\n  }>\n): Promise<ParsedTransaction[]> {\n  const allTransactions: ParsedTransaction[] = [];\n\n  const results = await Promise.all(\n    wallets.flatMap((wallet) => {\n      return [\n        fetchTransactionHistory(\n          wallet.address,\n          wallet.numericChainId,\n          wallet.id,\n          wallet.chainId,\n          wallet.chainSymbol,\n          wallet.blockExplorerUrl\n        ),\n        wallet.numericChainId > 0\n          ? fetchTokenTransfers(\n              wallet.address,\n              wallet.numericChainId,\n              wallet.id,\n              wallet.chainId,\n              wallet.blockExplorerUrl\n            )\n          : Promise.resolve([]),\n      ];\n    })\n  );\n\n  for (const txs of results) {\n    allTransactions.push(...txs);\n  }\n\n  // Also fetch locally stored transactions (sent from our app)\n  try {\n    const localTxs = await clientStorage.getAllTransactions();\n    const relevantChainIds = new Set(wallets.map(w => w.chainId));\n    \n    for (const storedTx of localTxs) {\n      // Only include transactions for the chains we're querying\n      if (relevantChainIds.has(storedTx.chainId)) {\n        allTransactions.push(convertStoredToParesed(storedTx));\n      }\n    }\n  } catch (err) {\n    console.error(\"Failed to fetch local transactions:\", err);\n  }\n\n  // Deduplicate by txHash (prefer blockchain data over local)\n  const uniqueTxs = new Map<string, ParsedTransaction>();\n  for (const tx of allTransactions) {\n    // Use txHash for deduplication if available, otherwise use id\n    const key = tx.txHash || tx.id;\n    // Only add if not already present (first one wins - blockchain comes first)\n    if (!uniqueTxs.has(key)) {\n      uniqueTxs.set(key, tx);\n    }\n  }\n\n  const sortedTxs = Array.from(uniqueTxs.values()).sort(\n    (a, b) => new Date(b.timestamp).getTime() - new Date(a.timestamp).getTime()\n  );\n\n  return sortedTxs;\n}\n\nexport function clearExplorerCache() {\n  fetchCache.clear();\n}\n","path":null,"size_bytes":13808,"size_tokens":null},"client/src/pages/home.tsx":{"content":"import { Shield } from \"lucide-react\";\nimport { Button } from \"@/components/ui/button\";\nimport { Link } from \"wouter\";\n\nexport default function Home() {\n  return (\n    <div \n      className=\"min-h-screen flex flex-col items-center justify-center p-8 bg-background\"\n      data-testid=\"welcome-screen\"\n    >\n      <div className=\"flex flex-col items-center text-center animate-fade-in\">\n        <div className=\"flex items-center gap-3 mb-8\">\n          <Shield className=\"w-8 h-8 text-primary\" />\n          <span \n            className=\"text-2xl sm:text-3xl font-semibold tracking-wide text-foreground\"\n            data-testid=\"text-brand-name\"\n          >\n            VAULT KEY\n          </span>\n        </div>\n        \n        <h1 \n          className=\"text-5xl sm:text-6xl md:text-7xl font-bold text-foreground mb-6\"\n          data-testid=\"text-welcome\"\n        >\n          Welcome\n        </h1>\n        \n        <p \n          className=\"text-lg sm:text-xl text-muted-foreground mb-12\"\n          data-testid=\"text-tagline\"\n        >\n          Secure Hardware Wallet\n        </p>\n\n        <Link href=\"/wallet\">\n          <Button size=\"lg\" className=\"px-8\" data-testid=\"button-get-started\">\n            View Addresses\n          </Button>\n        </Link>\n      </div>\n    </div>\n  );\n}\n","path":null,"size_bytes":1283,"size_tokens":null},"client/src/pages/setup-guide.tsx":{"content":"import { useState } from \"react\";\nimport { \n  Terminal, \n  Usb, \n  Shield, \n  CheckCircle2, \n  Copy, \n  ChevronRight,\n  AlertTriangle,\n  Cpu,\n  Wifi,\n  Lock,\n} from \"lucide-react\";\nimport { BackButton } from \"@/components/back-button\";\nimport { Card, CardContent, CardHeader, CardTitle, CardDescription } from \"@/components/ui/card\";\nimport { Button } from \"@/components/ui/button\";\nimport { Badge } from \"@/components/ui/badge\";\nimport { Tabs, TabsContent, TabsList, TabsTrigger } from \"@/components/ui/tabs\";\nimport { useToast } from \"@/hooks/use-toast\";\n\nfunction CodeBlock({ code, language = \"bash\" }: { code: string; language?: string }) {\n  const { toast } = useToast();\n  \n  const copyCode = () => {\n    navigator.clipboard.writeText(code);\n    toast({\n      title: \"Copied\",\n      description: \"Command copied to clipboard\",\n    });\n  };\n  \n  return (\n    <div className=\"relative group\">\n      <pre className=\"bg-muted rounded-md p-4 overflow-x-auto text-sm font-mono\">\n        <code>{code}</code>\n      </pre>\n      <Button\n        size=\"icon\"\n        variant=\"ghost\"\n        className=\"absolute top-2 right-2 opacity-0 group-hover:opacity-100 transition-opacity\"\n        onClick={copyCode}\n        data-testid=\"button-copy-code\"\n      >\n        <Copy className=\"h-4 w-4\" />\n      </Button>\n    </div>\n  );\n}\n\nfunction StepCard({ \n  step, \n  title, \n  description, \n  children \n}: { \n  step: number; \n  title: string; \n  description: string; \n  children: React.ReactNode;\n}) {\n  return (\n    <Card className=\"mb-6\">\n      <CardHeader>\n        <div className=\"flex items-center gap-3\">\n          <div className=\"flex h-8 w-8 items-center justify-center rounded-full bg-primary text-primary-foreground text-sm font-bold\">\n            {step}\n          </div>\n          <div>\n            <CardTitle className=\"text-lg\">{title}</CardTitle>\n            <CardDescription>{description}</CardDescription>\n          </div>\n        </div>\n      </CardHeader>\n      <CardContent>{children}</CardContent>\n    </Card>\n  );\n}\n\nexport default function SetupGuide() {\n  const [activeTab, setActiveTab] = useState(\"overview\");\n\n  return (\n    <div className=\"p-6 max-w-4xl mx-auto\">\n      <div className=\"mb-8\">\n        <div className=\"flex items-center gap-3 mb-2\">\n          <BackButton />\n          <h1 className=\"text-3xl font-bold\">Hardware Wallet Setup Guide</h1>\n        </div>\n        <p className=\"text-muted-foreground\">\n          Build your own hardware wallet with Raspberry Pi Pico H ($8) or Raspberry Pi 4 ($50)\n        </p>\n      </div>\n\n      <Tabs value={activeTab} onValueChange={setActiveTab}>\n        <TabsList className=\"mb-6 flex-wrap\">\n          <TabsTrigger value=\"overview\" data-testid=\"tab-overview\">\n            <Cpu className=\"mr-2 h-4 w-4\" />\n            Overview\n          </TabsTrigger>\n          <TabsTrigger value=\"hardware\" data-testid=\"tab-hardware\">\n            <Usb className=\"mr-2 h-4 w-4\" />\n            Hardware\n          </TabsTrigger>\n          <TabsTrigger value=\"pico\" data-testid=\"tab-pico\">\n            <Cpu className=\"mr-2 h-4 w-4\" />\n            Pico Setup\n          </TabsTrigger>\n          <TabsTrigger value=\"setup\" data-testid=\"tab-setup\">\n            <Terminal className=\"mr-2 h-4 w-4\" />\n            Pi 4 Setup\n          </TabsTrigger>\n          <TabsTrigger value=\"security\" data-testid=\"tab-security\">\n            <Shield className=\"mr-2 h-4 w-4\" />\n            Security\n          </TabsTrigger>\n        </TabsList>\n\n        <TabsContent value=\"overview\">\n          <Card className=\"mb-6\">\n            <CardContent className=\"pt-6\">\n              <div className=\"grid gap-6 md:grid-cols-2\">\n                <div>\n                  <h2 className=\"text-xl font-semibold mb-4\">What You Get</h2>\n                  <ul className=\"space-y-3\">\n                    {[\n                      \"Air-gapped key storage on dedicated hardware\",\n                      \"BIP39/BIP44 standard seed phrase generation\",\n                      \"Multi-chain support (ETH, BSC, Polygon, custom)\",\n                      \"PIN-protected access with lockout protection\",\n                      \"USB connection to web app for signing\",\n                    ].map((item, i) => (\n                      <li key={i} className=\"flex items-start gap-2\">\n                        <CheckCircle2 className=\"h-5 w-5 text-green-500 mt-0.5 shrink-0\" />\n                        <span className=\"text-sm\">{item}</span>\n                      </li>\n                    ))}\n                  </ul>\n                </div>\n                <div>\n                  <h2 className=\"text-xl font-semibold mb-4\">How It Works</h2>\n                  <div className=\"space-y-4\">\n                    <div className=\"flex items-center gap-3 text-sm\">\n                      <Badge variant=\"outline\">1</Badge>\n                      <span>Pi stores encrypted seed phrase</span>\n                    </div>\n                    <ChevronRight className=\"h-4 w-4 text-muted-foreground mx-4\" />\n                    <div className=\"flex items-center gap-3 text-sm\">\n                      <Badge variant=\"outline\">2</Badge>\n                      <span>Web app sends transaction to sign</span>\n                    </div>\n                    <ChevronRight className=\"h-4 w-4 text-muted-foreground mx-4\" />\n                    <div className=\"flex items-center gap-3 text-sm\">\n                      <Badge variant=\"outline\">3</Badge>\n                      <span>Pi signs with your PIN confirmation</span>\n                    </div>\n                    <ChevronRight className=\"h-4 w-4 text-muted-foreground mx-4\" />\n                    <div className=\"flex items-center gap-3 text-sm\">\n                      <Badge variant=\"outline\">4</Badge>\n                      <span>Signature returned, transaction broadcast</span>\n                    </div>\n                  </div>\n                </div>\n              </div>\n            </CardContent>\n          </Card>\n\n          <Card>\n            <CardHeader>\n              <CardTitle className=\"flex items-center gap-2\">\n                <AlertTriangle className=\"h-5 w-5 text-amber-500\" />\n                Important Notes\n              </CardTitle>\n            </CardHeader>\n            <CardContent>\n              <ul className=\"space-y-2 text-sm text-muted-foreground\">\n                <li className=\"flex items-start gap-2\">\n                  <span className=\"text-foreground font-medium\">Seed phrase:</span>\n                  Write it down on paper. Never store digitally.\n                </li>\n                <li className=\"flex items-start gap-2\">\n                  <span className=\"text-foreground font-medium\">PIN:</span>\n                  Required for every transaction. 5 failed attempts = 5 min lockout.\n                </li>\n                <li className=\"flex items-start gap-2\">\n                  <span className=\"text-foreground font-medium\">Physical security:</span>\n                  Keep your Pi in a safe place. If stolen, PIN still protects the wallet.\n                </li>\n              </ul>\n            </CardContent>\n          </Card>\n        </TabsContent>\n\n        <TabsContent value=\"hardware\">\n          <Card className=\"mb-6\">\n            <CardHeader>\n              <CardTitle>Required Components</CardTitle>\n              <CardDescription>Total cost: approximately $50</CardDescription>\n            </CardHeader>\n            <CardContent>\n              <div className=\"overflow-x-auto\">\n                <table className=\"w-full text-sm\">\n                  <thead>\n                    <tr className=\"border-b\">\n                      <th className=\"text-left py-3 font-medium\">Component</th>\n                      <th className=\"text-left py-3 font-medium\">Description</th>\n                      <th className=\"text-right py-3 font-medium\">Cost</th>\n                    </tr>\n                  </thead>\n                  <tbody>\n                    <tr className=\"border-b\">\n                      <td className=\"py-3 font-medium\">Raspberry Pi 4</td>\n                      <td className=\"py-3 text-muted-foreground\">Any RAM size (1GB works fine)</td>\n                      <td className=\"py-3 text-right\">$35-75</td>\n                    </tr>\n                    <tr className=\"border-b\">\n                      <td className=\"py-3 font-medium\">MicroSD Card</td>\n                      <td className=\"py-3 text-muted-foreground\">32GB minimum, Class 10</td>\n                      <td className=\"py-3 text-right\">$8</td>\n                    </tr>\n                    <tr className=\"border-b\">\n                      <td className=\"py-3 font-medium\">USB-C Cable</td>\n                      <td className=\"py-3 text-muted-foreground\">Data + power capable</td>\n                      <td className=\"py-3 text-right\">$5</td>\n                    </tr>\n                    <tr>\n                      <td className=\"py-3 font-bold\">Total</td>\n                      <td className=\"py-3\"></td>\n                      <td className=\"py-3 text-right font-bold\">~$50</td>\n                    </tr>\n                  </tbody>\n                </table>\n              </div>\n            </CardContent>\n          </Card>\n\n          <Card>\n            <CardHeader>\n              <CardTitle>Optional Upgrades</CardTitle>\n            </CardHeader>\n            <CardContent>\n              <ul className=\"space-y-3 text-sm\">\n                <li className=\"flex items-start gap-3\">\n                  <Badge variant=\"secondary\">Case</Badge>\n                  <span>Aluminum case with heatsink for better cooling ($10-15)</span>\n                </li>\n                <li className=\"flex items-start gap-3\">\n                  <Badge variant=\"secondary\">Power</Badge>\n                  <span>Official Pi 4 power supply if not using USB-C from computer ($8)</span>\n                </li>\n              </ul>\n            </CardContent>\n          </Card>\n\n          <Card className=\"mt-6 border-primary\">\n            <CardHeader>\n              <CardTitle className=\"flex items-center gap-2\">\n                <Badge variant=\"default\">Recommended</Badge>\n                Raspberry Pi Pico H - Budget Option\n              </CardTitle>\n              <CardDescription>The simplest and cheapest hardware wallet solution</CardDescription>\n            </CardHeader>\n            <CardContent>\n              <div className=\"overflow-x-auto\">\n                <table className=\"w-full text-sm\">\n                  <thead>\n                    <tr className=\"border-b\">\n                      <th className=\"text-left py-3 font-medium\">Component</th>\n                      <th className=\"text-left py-3 font-medium\">Description</th>\n                      <th className=\"text-right py-3 font-medium\">Cost</th>\n                    </tr>\n                  </thead>\n                  <tbody>\n                    <tr className=\"border-b\">\n                      <td className=\"py-3 font-medium\">Raspberry Pi Pico H</td>\n                      <td className=\"py-3 text-muted-foreground\">With pre-soldered headers</td>\n                      <td className=\"py-3 text-right\">$5</td>\n                    </tr>\n                    <tr className=\"border-b\">\n                      <td className=\"py-3 font-medium\">Micro USB Cable</td>\n                      <td className=\"py-3 text-muted-foreground\">Data cable (not charge-only)</td>\n                      <td className=\"py-3 text-right\">$3</td>\n                    </tr>\n                    <tr>\n                      <td className=\"py-3 font-bold\">Total</td>\n                      <td className=\"py-3\"></td>\n                      <td className=\"py-3 text-right font-bold text-green-600\">~$8</td>\n                    </tr>\n                  </tbody>\n                </table>\n              </div>\n              <p className=\"text-sm text-muted-foreground mt-4\">\n                The Pico H is the recommended choice for beginners. No SD card, no OS installation - just plug and play!\n              </p>\n            </CardContent>\n          </Card>\n        </TabsContent>\n\n        <TabsContent value=\"pico\">\n          <Card className=\"mb-6 border-green-500\">\n            <CardHeader>\n              <CardTitle className=\"flex items-center gap-2\">\n                <CheckCircle2 className=\"h-5 w-5 text-green-500\" />\n                Easiest Setup - Just 3 Steps\n              </CardTitle>\n              <CardDescription>Get your hardware wallet running in under 5 minutes</CardDescription>\n            </CardHeader>\n            <CardContent>\n              <p className=\"text-sm text-muted-foreground\">\n                The Raspberry Pi Pico H is a microcontroller that runs MicroPython. It's the simplest \n                way to create a hardware wallet - no operating system, no SD card, no network.\n              </p>\n            </CardContent>\n          </Card>\n\n          <StepCard\n            step={1}\n            title=\"Install MicroPython on your Pico\"\n            description=\"Flash the MicroPython firmware\"\n          >\n            <ol className=\"space-y-4 text-sm\">\n              <li className=\"flex items-start gap-3\">\n                <Badge variant=\"outline\">A</Badge>\n                <div>\n                  <p className=\"mb-2\">Download MicroPython from <a href=\"https://micropython.org/download/RPI_PICO/\" target=\"_blank\" rel=\"noopener\" className=\"text-primary underline\">micropython.org</a></p>\n                  <p className=\"text-muted-foreground\">Get the latest .uf2 file for Raspberry Pi Pico</p>\n                </div>\n              </li>\n              <li className=\"flex items-start gap-3\">\n                <Badge variant=\"outline\">B</Badge>\n                <div>\n                  <p>Hold the BOOTSEL button on your Pico and plug it into USB</p>\n                  <p className=\"text-muted-foreground\">The Pico will appear as a USB drive called \"RPI-RP2\"</p>\n                </div>\n              </li>\n              <li className=\"flex items-start gap-3\">\n                <Badge variant=\"outline\">C</Badge>\n                <div>\n                  <p>Drag and drop the .uf2 file onto the RPI-RP2 drive</p>\n                  <p className=\"text-muted-foreground\">The Pico will reboot automatically with MicroPython installed</p>\n                </div>\n              </li>\n            </ol>\n          </StepCard>\n\n          <StepCard\n            step={2}\n            title=\"Upload the Wallet Firmware\"\n            description=\"Copy the wallet code to your Pico\"\n          >\n            <ol className=\"space-y-4 text-sm\">\n              <li className=\"flex items-start gap-3\">\n                <Badge variant=\"outline\">A</Badge>\n                <div>\n                  <p className=\"mb-2\">Download and install <a href=\"https://thonny.org/\" target=\"_blank\" rel=\"noopener\" className=\"text-primary underline\">Thonny IDE</a></p>\n                  <p className=\"text-muted-foreground\">Free Python IDE that works great with Pico</p>\n                </div>\n              </li>\n              <li className=\"flex items-start gap-3\">\n                <Badge variant=\"outline\">B</Badge>\n                <div>\n                  <p>In Thonny, go to Tools, then Options, then Interpreter</p>\n                  <p className=\"text-muted-foreground\">Select \"MicroPython (Raspberry Pi Pico)\" and your port</p>\n                </div>\n              </li>\n              <li className=\"flex items-start gap-3\">\n                <Badge variant=\"outline\">C</Badge>\n                <div>\n                  <p>Open the file <code className=\"bg-muted px-1 rounded\">pico_wallet/main.py</code> from this project</p>\n                </div>\n              </li>\n              <li className=\"flex items-start gap-3\">\n                <Badge variant=\"outline\">D</Badge>\n                <div>\n                  <p>Save it to the Pico as <code className=\"bg-muted px-1 rounded\">main.py</code></p>\n                  <p className=\"text-muted-foreground\">File, then Save As, then select \"Raspberry Pi Pico\", name it main.py</p>\n                </div>\n              </li>\n            </ol>\n          </StepCard>\n\n          <StepCard\n            step={3}\n            title=\"Connect to SecureVault\"\n            description=\"Use your new hardware wallet\"\n          >\n            <ol className=\"space-y-3 text-sm\">\n              <li className=\"flex items-start gap-3\">\n                <Badge variant=\"outline\">1</Badge>\n                <span>Make sure your Pico is connected via USB (you can close Thonny now)</span>\n              </li>\n              <li className=\"flex items-start gap-3\">\n                <Badge variant=\"outline\">2</Badge>\n                <span>Open SecureVault in Chrome or Edge (Web Serial requires these browsers)</span>\n              </li>\n              <li className=\"flex items-start gap-3\">\n                <Badge variant=\"outline\">3</Badge>\n                <span>Go to Dashboard and click \"Create Wallet\"</span>\n              </li>\n              <li className=\"flex items-start gap-3\">\n                <Badge variant=\"outline\">4</Badge>\n                <span>Select the \"Raspberry Pi\" tab</span>\n              </li>\n              <li className=\"flex items-start gap-3\">\n                <Badge variant=\"outline\">5</Badge>\n                <span>Click \"Connect Raspberry Pi\" and select your Pico from the list</span>\n              </li>\n              <li className=\"flex items-start gap-3\">\n                <Badge variant=\"outline\">6</Badge>\n                <span>Set your 4-6 digit PIN</span>\n              </li>\n              <li className=\"flex items-start gap-3\">\n                <Badge variant=\"outline\">7</Badge>\n                <span className=\"font-semibold\">Write down your 24-word seed phrase on paper!</span>\n              </li>\n            </ol>\n          </StepCard>\n\n          <Card className=\"border-amber-500\">\n            <CardHeader>\n              <CardTitle className=\"flex items-center gap-2\">\n                <AlertTriangle className=\"h-5 w-5 text-amber-500\" />\n                Troubleshooting\n              </CardTitle>\n            </CardHeader>\n            <CardContent>\n              <ul className=\"space-y-3 text-sm text-muted-foreground\">\n                <li className=\"flex items-start gap-2\">\n                  <span className=\"text-foreground font-medium\">Pico not detected:</span>\n                  Make sure Thonny is closed - only one app can use the serial port at a time\n                </li>\n                <li className=\"flex items-start gap-2\">\n                  <span className=\"text-foreground font-medium\">Web Serial not available:</span>\n                  Use Chrome or Edge browser, Firefox doesn't support Web Serial API\n                </li>\n                <li className=\"flex items-start gap-2\">\n                  <span className=\"text-foreground font-medium\">Connection timeout:</span>\n                  Unplug and replug the Pico, then try again\n                </li>\n              </ul>\n            </CardContent>\n          </Card>\n        </TabsContent>\n\n        <TabsContent value=\"setup\">\n          <StepCard\n            step={1}\n            title=\"Flash Raspberry Pi OS\"\n            description=\"Download and install the operating system\"\n          >\n            <ol className=\"space-y-4 text-sm\">\n              <li className=\"flex items-start gap-3\">\n                <Badge variant=\"outline\">A</Badge>\n                <div>\n                  <p className=\"mb-2\">Download <a href=\"https://www.raspberrypi.com/software/\" target=\"_blank\" rel=\"noopener\" className=\"text-primary underline\">Raspberry Pi Imager</a></p>\n                </div>\n              </li>\n              <li className=\"flex items-start gap-3\">\n                <Badge variant=\"outline\">B</Badge>\n                <div>\n                  <p>Select \"Raspberry Pi OS Lite (64-bit)\" - no desktop needed</p>\n                </div>\n              </li>\n              <li className=\"flex items-start gap-3\">\n                <Badge variant=\"outline\">C</Badge>\n                <div>\n                  <p className=\"mb-2\">Click the gear icon to configure:</p>\n                  <ul className=\"list-disc list-inside text-muted-foreground ml-2\">\n                    <li>Enable SSH</li>\n                    <li>Set username: <code className=\"bg-muted px-1 rounded\">pi</code></li>\n                    <li>Set a strong password</li>\n                    <li>Configure WiFi (optional, for initial setup only)</li>\n                  </ul>\n                </div>\n              </li>\n              <li className=\"flex items-start gap-3\">\n                <Badge variant=\"outline\">D</Badge>\n                <div>\n                  <p>Flash to your MicroSD card</p>\n                </div>\n              </li>\n            </ol>\n          </StepCard>\n\n          <StepCard\n            step={2}\n            title=\"Copy Wallet Files\"\n            description=\"Transfer the wallet software to your Pi\"\n          >\n            <p className=\"text-sm text-muted-foreground mb-4\">\n              From your computer, run this command to copy the wallet files:\n            </p>\n            <CodeBlock code=\"scp -r raspberry_pi_wallet/ pi@raspberrypi.local:~/\" />\n            <p className=\"text-sm text-muted-foreground mt-4\">\n              If <code className=\"bg-muted px-1 rounded\">raspberrypi.local</code> doesn't work, use the Pi's IP address.\n            </p>\n          </StepCard>\n\n          <StepCard\n            step={3}\n            title=\"Run Setup Script\"\n            description=\"Install dependencies and configure USB mode\"\n          >\n            <p className=\"text-sm text-muted-foreground mb-4\">\n              SSH into your Pi and run the setup:\n            </p>\n            <CodeBlock code={`ssh pi@raspberrypi.local\ncd raspberry_pi_wallet\nchmod +x setup_pi.sh\n./setup_pi.sh`} />\n            <p className=\"text-sm text-muted-foreground mt-4\">\n              The script will install Python packages and configure USB gadget mode. Reboot when prompted.\n            </p>\n          </StepCard>\n\n          <StepCard\n            step={4}\n            title=\"Start the Wallet\"\n            description=\"Launch the wallet service\"\n          >\n            <p className=\"text-sm text-muted-foreground mb-4\">\n              After reboot, start the wallet manually:\n            </p>\n            <CodeBlock code={`source ~/wallet_env/bin/activate\ncd ~/raspberry_pi_wallet\npython main.py`} />\n            <p className=\"text-sm text-muted-foreground mt-4 mb-4\">\n              Or enable auto-start on boot:\n            </p>\n            <CodeBlock code={`sudo systemctl enable pi-wallet\nsudo systemctl start pi-wallet`} />\n          </StepCard>\n\n          <StepCard\n            step={5}\n            title=\"Connect to Web App\"\n            description=\"Link your Pi wallet to SecureVault\"\n          >\n            <ol className=\"space-y-3 text-sm\">\n              <li className=\"flex items-start gap-3\">\n                <Badge variant=\"outline\">1</Badge>\n                <span>Connect Pi to your computer via USB-C (use the USB-C port, not micro-USB power)</span>\n              </li>\n              <li className=\"flex items-start gap-3\">\n                <Badge variant=\"outline\">2</Badge>\n                <span>Open SecureVault web app in your browser</span>\n              </li>\n              <li className=\"flex items-start gap-3\">\n                <Badge variant=\"outline\">3</Badge>\n                <span>Go to Dashboard and click \"Create Wallet\"</span>\n              </li>\n              <li className=\"flex items-start gap-3\">\n                <Badge variant=\"outline\">4</Badge>\n                <span>Select the \"Raspberry Pi\" tab</span>\n              </li>\n              <li className=\"flex items-start gap-3\">\n                <Badge variant=\"outline\">5</Badge>\n                <span>Click \"Connect Raspberry Pi\" and allow USB access</span>\n              </li>\n              <li className=\"flex items-start gap-3\">\n                <Badge variant=\"outline\">6</Badge>\n                <span>Set your 4-6 digit PIN</span>\n              </li>\n              <li className=\"flex items-start gap-3\">\n                <Badge variant=\"outline\">7</Badge>\n                <span className=\"font-semibold\">Write down your 24-word seed phrase on paper!</span>\n              </li>\n            </ol>\n          </StepCard>\n        </TabsContent>\n\n        <TabsContent value=\"security\">\n          <div className=\"grid gap-6 md:grid-cols-2\">\n            <Card>\n              <CardHeader>\n                <CardTitle className=\"flex items-center gap-2\">\n                  <Lock className=\"h-5 w-5\" />\n                  What's Protected\n                </CardTitle>\n              </CardHeader>\n              <CardContent>\n                <ul className=\"space-y-3 text-sm\">\n                  <li className=\"flex items-start gap-2\">\n                    <CheckCircle2 className=\"h-4 w-4 text-green-500 mt-0.5\" />\n                    <span>Private keys never leave the Pi</span>\n                  </li>\n                  <li className=\"flex items-start gap-2\">\n                    <CheckCircle2 className=\"h-4 w-4 text-green-500 mt-0.5\" />\n                    <span>Seed phrase encrypted with your PIN</span>\n                  </li>\n                  <li className=\"flex items-start gap-2\">\n                    <CheckCircle2 className=\"h-4 w-4 text-green-500 mt-0.5\" />\n                    <span>Every transaction requires PIN confirmation</span>\n                  </li>\n                  <li className=\"flex items-start gap-2\">\n                    <CheckCircle2 className=\"h-4 w-4 text-green-500 mt-0.5\" />\n                    <span>Lockout after 5 failed PIN attempts</span>\n                  </li>\n                  <li className=\"flex items-start gap-2\">\n                    <CheckCircle2 className=\"h-4 w-4 text-green-500 mt-0.5\" />\n                    <span>Auto-lock after 5 minutes of inactivity</span>\n                  </li>\n                </ul>\n              </CardContent>\n            </Card>\n\n            <Card>\n              <CardHeader>\n                <CardTitle className=\"flex items-center gap-2\">\n                  <Wifi className=\"h-5 w-5\" />\n                  Extra Security Steps\n                </CardTitle>\n              </CardHeader>\n              <CardContent>\n                <ul className=\"space-y-3 text-sm\">\n                  <li className=\"flex items-start gap-2\">\n                    <Shield className=\"h-4 w-4 text-primary mt-0.5\" />\n                    <span>Disable WiFi after initial setup for air-gap</span>\n                  </li>\n                  <li className=\"flex items-start gap-2\">\n                    <Shield className=\"h-4 w-4 text-primary mt-0.5\" />\n                    <span>Disable Bluetooth in /boot/config.txt</span>\n                  </li>\n                  <li className=\"flex items-start gap-2\">\n                    <Shield className=\"h-4 w-4 text-primary mt-0.5\" />\n                    <span>Store Pi in a secure location</span>\n                  </li>\n                  <li className=\"flex items-start gap-2\">\n                    <Shield className=\"h-4 w-4 text-primary mt-0.5\" />\n                    <span>Keep backup of seed phrase in fireproof safe</span>\n                  </li>\n                </ul>\n              </CardContent>\n            </Card>\n          </div>\n\n          <Card className=\"mt-6\">\n            <CardHeader>\n              <CardTitle className=\"flex items-center gap-2\">\n                <AlertTriangle className=\"h-5 w-5 text-amber-500\" />\n                Limitations\n              </CardTitle>\n            </CardHeader>\n            <CardContent>\n              <ul className=\"space-y-3 text-sm text-muted-foreground\">\n                <li className=\"flex items-start gap-2\">\n                  <span className=\"text-foreground\">No physical button:</span>\n                  Unlike commercial hardware wallets, confirmation is via PIN only\n                </li>\n                <li className=\"flex items-start gap-2\">\n                  <span className=\"text-foreground\">No display:</span>\n                  You cannot verify transaction details on the Pi itself\n                </li>\n                <li className=\"flex items-start gap-2\">\n                  <span className=\"text-foreground\">SD card theft:</span>\n                  If someone steals the SD card, they still need your PIN to access funds\n                </li>\n                <li className=\"flex items-start gap-2\">\n                  <span className=\"text-foreground\">Not FIDO certified:</span>\n                  This is a DIY solution, not a certified security device\n                </li>\n              </ul>\n            </CardContent>\n          </Card>\n\n          <Card className=\"mt-6\">\n            <CardHeader>\n              <CardTitle>Disabling WiFi/Bluetooth (Recommended)</CardTitle>\n            </CardHeader>\n            <CardContent>\n              <p className=\"text-sm text-muted-foreground mb-4\">\n                After initial setup, disable wireless for maximum security:\n              </p>\n              <CodeBlock code={`# Add to /boot/config.txt\ndtoverlay=disable-wifi\ndtoverlay=disable-bt`} />\n              <p className=\"text-sm text-muted-foreground mt-4\">\n                Then reboot. Your Pi will only communicate via USB.\n              </p>\n            </CardContent>\n          </Card>\n        </TabsContent>\n      </Tabs>\n    </div>\n  );\n}\n","path":null,"size_bytes":29261,"size_tokens":null},"client/src/components/ui/skeleton.tsx":{"content":"import { cn } from \"@/lib/utils\"\n\nfunction Skeleton({\n  className,\n  ...props\n}: React.HTMLAttributes<HTMLDivElement>) {\n  return (\n    <div\n      className={cn(\"animate-pulse rounded-md bg-muted\", className)}\n      {...props}\n    />\n  )\n}\n\nexport { Skeleton }\n","path":null,"size_bytes":261,"size_tokens":null},"client/src/lib/client-storage.ts":{"content":"const DB_NAME = \"SecureVaultDB\";\nconst DB_VERSION = 1;\n\nexport interface StoredWallet {\n  id: string;\n  address: string;\n  chainId: string;\n  chainName: string;\n  chainSymbol: string;\n  balance: string;\n  path: string;\n  lastUpdated: string;\n  accountIndex: number; // Wallet index for multi-wallet support\n  label?: string; // Optional user-defined label\n  walletGroupId?: string; // Unique ID for independent seed group (undefined = uses primary seed)\n}\n\n// Encrypted seed storage for each wallet group (independent seeds)\nexport interface StoredWalletSeed {\n  walletGroupId: string;\n  encryptedSeed: string;\n  pinHash: string;\n  pinSalt: string;\n  createdAt: string;\n}\n\nexport interface StoredTransaction {\n  id: string;\n  walletId: string;\n  chainId: string;\n  type: \"send\" | \"receive\";\n  status: \"pending\" | \"confirmed\" | \"failed\";\n  amount: string;\n  tokenSymbol: string;\n  toAddress: string;\n  fromAddress: string;\n  txHash?: string;\n  gasUsed?: string;\n  timestamp: string;\n}\n\nexport interface WalletProfile {\n  id: string;\n  name: string;\n  createdAt: string;\n  wallets: StoredWallet[];\n  lastAccessed: string;\n}\n\nexport interface CustomToken {\n  id: string;\n  chainId: string;\n  chainType: 'evm' | 'tron';\n  contractAddress: string;\n  name: string;\n  symbol: string;\n  decimals: number;\n  evmChainId?: number;\n  rpcUrl?: string;\n  image?: string; // Optional token logo URL\n  addedAt: string;\n  walletId: string; // Required - token is associated with specific wallet\n}\n\nexport interface CustomChain {\n  id: string;\n  name: string;\n  symbol: string;\n  rpcUrl: string;\n  chainId: number;\n  blockExplorer?: string;\n  decimals: number;\n  iconColor?: string;\n  addedAt: string;\n}\n\nexport interface CachedBalance {\n  address: string;\n  chainSymbol: string;\n  chainId: number;\n  balance: string;\n  timestamp: number;\n  isStale?: boolean;\n}\n\nexport interface BalanceCacheEntry {\n  balances: Record<string, CachedBalance>;\n  lastFullRefresh: number;\n}\n\nclass ClientStorage {\n  private db: IDBDatabase | null = null;\n\n  async init(): Promise<void> {\n    return new Promise((resolve, reject) => {\n      const request = indexedDB.open(DB_NAME, DB_VERSION);\n\n      request.onerror = () => reject(request.error);\n      request.onsuccess = () => {\n        this.db = request.result;\n        resolve();\n      };\n\n      request.onupgradeneeded = (event) => {\n        const db = (event.target as IDBOpenDBRequest).result;\n\n        if (!db.objectStoreNames.contains(\"profiles\")) {\n          const profileStore = db.createObjectStore(\"profiles\", { keyPath: \"id\" });\n          profileStore.createIndex(\"name\", \"name\", { unique: false });\n        }\n\n        if (!db.objectStoreNames.contains(\"wallets\")) {\n          const walletStore = db.createObjectStore(\"wallets\", { keyPath: \"id\" });\n          walletStore.createIndex(\"address\", \"address\", { unique: false });\n          walletStore.createIndex(\"chainId\", \"chainId\", { unique: false });\n        }\n\n        if (!db.objectStoreNames.contains(\"transactions\")) {\n          const txStore = db.createObjectStore(\"transactions\", { keyPath: \"id\" });\n          txStore.createIndex(\"walletId\", \"walletId\", { unique: false });\n          txStore.createIndex(\"timestamp\", \"timestamp\", { unique: false });\n        }\n\n        if (!db.objectStoreNames.contains(\"settings\")) {\n          db.createObjectStore(\"settings\", { keyPath: \"key\" });\n        }\n      };\n    });\n  }\n\n  private getStore(storeName: string, mode: IDBTransactionMode = \"readonly\"): IDBObjectStore {\n    if (!this.db) throw new Error(\"Database not initialized\");\n    const transaction = this.db.transaction(storeName, mode);\n    return transaction.objectStore(storeName);\n  }\n\n  async saveProfile(profile: WalletProfile): Promise<void> {\n    return new Promise((resolve, reject) => {\n      const store = this.getStore(\"profiles\", \"readwrite\");\n      const request = store.put(profile);\n      request.onerror = () => reject(request.error);\n      request.onsuccess = () => resolve();\n    });\n  }\n\n  async getProfile(id: string): Promise<WalletProfile | null> {\n    return new Promise((resolve, reject) => {\n      const store = this.getStore(\"profiles\");\n      const request = store.get(id);\n      request.onerror = () => reject(request.error);\n      request.onsuccess = () => resolve(request.result || null);\n    });\n  }\n\n  async getAllProfiles(): Promise<WalletProfile[]> {\n    return new Promise((resolve, reject) => {\n      const store = this.getStore(\"profiles\");\n      const request = store.getAll();\n      request.onerror = () => reject(request.error);\n      request.onsuccess = () => resolve(request.result);\n    });\n  }\n\n  async deleteProfile(id: string): Promise<void> {\n    return new Promise((resolve, reject) => {\n      const store = this.getStore(\"profiles\", \"readwrite\");\n      const request = store.delete(id);\n      request.onerror = () => reject(request.error);\n      request.onsuccess = () => resolve();\n    });\n  }\n\n  async saveWallet(wallet: StoredWallet): Promise<void> {\n    return new Promise((resolve, reject) => {\n      const store = this.getStore(\"wallets\", \"readwrite\");\n      const request = store.put(wallet);\n      request.onerror = () => reject(request.error);\n      request.onsuccess = () => resolve();\n    });\n  }\n\n  async getWallet(id: string): Promise<StoredWallet | null> {\n    return new Promise((resolve, reject) => {\n      const store = this.getStore(\"wallets\");\n      const request = store.get(id);\n      request.onerror = () => reject(request.error);\n      request.onsuccess = () => resolve(request.result || null);\n    });\n  }\n\n  async getWalletsByAddress(address: string): Promise<StoredWallet[]> {\n    return new Promise((resolve, reject) => {\n      const store = this.getStore(\"wallets\");\n      const index = store.index(\"address\");\n      const request = index.getAll(address);\n      request.onerror = () => reject(request.error);\n      request.onsuccess = () => resolve(request.result);\n    });\n  }\n\n  async getAllWallets(): Promise<StoredWallet[]> {\n    return new Promise((resolve, reject) => {\n      const store = this.getStore(\"wallets\");\n      const request = store.getAll();\n      request.onerror = () => reject(request.error);\n      request.onsuccess = () => resolve(request.result);\n    });\n  }\n\n  async deleteWallet(id: string): Promise<void> {\n    return new Promise((resolve, reject) => {\n      const store = this.getStore(\"wallets\", \"readwrite\");\n      const request = store.delete(id);\n      request.onerror = () => reject(request.error);\n      request.onsuccess = () => resolve();\n    });\n  }\n\n  async saveTransaction(tx: StoredTransaction): Promise<void> {\n    return new Promise((resolve, reject) => {\n      const store = this.getStore(\"transactions\", \"readwrite\");\n      const request = store.put(tx);\n      request.onerror = () => reject(request.error);\n      request.onsuccess = () => resolve();\n    });\n  }\n\n  async getTransactionsByWallet(walletId: string): Promise<StoredTransaction[]> {\n    return new Promise((resolve, reject) => {\n      const store = this.getStore(\"transactions\");\n      const index = store.index(\"walletId\");\n      const request = index.getAll(walletId);\n      request.onerror = () => reject(request.error);\n      request.onsuccess = () => resolve(request.result);\n    });\n  }\n\n  async getAllTransactions(): Promise<StoredTransaction[]> {\n    return new Promise((resolve, reject) => {\n      const store = this.getStore(\"transactions\");\n      const request = store.getAll();\n      request.onerror = () => reject(request.error);\n      request.onsuccess = () => resolve(request.result);\n    });\n  }\n\n  async deleteTransaction(id: string): Promise<void> {\n    return new Promise((resolve, reject) => {\n      const store = this.getStore(\"transactions\", \"readwrite\");\n      const request = store.delete(id);\n      request.onerror = () => reject(request.error);\n      request.onsuccess = () => resolve();\n    });\n  }\n\n  async deleteTransactionsByWallet(walletId: string): Promise<void> {\n    const transactions = await this.getTransactionsByWallet(walletId);\n    for (const tx of transactions) {\n      await this.deleteTransaction(tx.id);\n    }\n  }\n\n  async saveSetting(key: string, value: any): Promise<void> {\n    return new Promise((resolve, reject) => {\n      const store = this.getStore(\"settings\", \"readwrite\");\n      const request = store.put({ key, value });\n      request.onerror = () => reject(request.error);\n      request.onsuccess = () => resolve();\n    });\n  }\n\n  async getSetting<T>(key: string): Promise<T | null> {\n    return new Promise((resolve, reject) => {\n      const store = this.getStore(\"settings\");\n      const request = store.get(key);\n      request.onerror = () => reject(request.error);\n      request.onsuccess = () => resolve(request.result?.value || null);\n    });\n  }\n\n  async deleteSetting(key: string): Promise<void> {\n    return new Promise((resolve, reject) => {\n      const store = this.getStore(\"settings\", \"readwrite\");\n      const request = store.delete(key);\n      request.onerror = () => reject(request.error);\n      request.onsuccess = () => resolve();\n    });\n  }\n\n  async clearAll(): Promise<void> {\n    const stores = [\"profiles\", \"wallets\", \"transactions\", \"settings\"];\n    for (const storeName of stores) {\n      await new Promise<void>((resolve, reject) => {\n        const store = this.getStore(storeName, \"readwrite\");\n        const request = store.clear();\n        request.onerror = () => reject(request.error);\n        request.onsuccess = () => resolve();\n      });\n    }\n  }\n\n  // Enabled assets management - stores Set of asset IDs that are enabled\n  private readonly ENABLED_ASSETS_KEY = \"enabledAssets\";\n\n  async getEnabledAssets(): Promise<Set<string>> {\n    const stored = await this.getSetting<string[]>(this.ENABLED_ASSETS_KEY);\n    if (stored && Array.isArray(stored)) {\n      return new Set(stored);\n    }\n    return new Set(); // Empty means use defaults (all enabled)\n  }\n\n  async setEnabledAssets(assetIds: Set<string>): Promise<void> {\n    await this.saveSetting(this.ENABLED_ASSETS_KEY, Array.from(assetIds));\n  }\n\n  async toggleAsset(assetId: string, enabled: boolean): Promise<Set<string>> {\n    const current = await this.getEnabledAssets();\n    if (enabled) {\n      current.add(assetId);\n    } else {\n      current.delete(assetId);\n    }\n    await this.setEnabledAssets(current);\n    return current;\n  }\n\n  async isAssetEnabled(assetId: string): Promise<boolean> {\n    const enabled = await this.getEnabledAssets();\n    // If no preferences saved yet, all are enabled by default\n    if (enabled.size === 0) {\n      return true;\n    }\n    return enabled.has(assetId);\n  }\n\n  async hasEnabledAssetsPreference(): Promise<boolean> {\n    const stored = await this.getSetting<string[]>(this.ENABLED_ASSETS_KEY);\n    return stored !== null && Array.isArray(stored);\n  }\n\n  // Mode-specific wallet setup tracking\n  private readonly SOFT_WALLET_SETUP_KEY = \"softWalletSetup\";\n  private readonly HARD_WALLET_SETUP_KEY = \"hardWalletSetup\";\n  private readonly SOFT_WALLET_DATA_KEY = \"softWalletData\";\n  private readonly HARD_WALLET_DATA_KEY = \"hardWalletData\";\n\n  async isSoftWalletSetup(): Promise<boolean> {\n    const stored = await this.getSetting<boolean>(this.SOFT_WALLET_SETUP_KEY);\n    return stored === true;\n  }\n\n  async isHardWalletSetup(): Promise<boolean> {\n    const stored = await this.getSetting<boolean>(this.HARD_WALLET_SETUP_KEY);\n    return stored === true;\n  }\n\n  async setSoftWalletSetup(isSetup: boolean): Promise<void> {\n    await this.saveSetting(this.SOFT_WALLET_SETUP_KEY, isSetup);\n  }\n\n  async setHardWalletSetup(isSetup: boolean): Promise<void> {\n    await this.saveSetting(this.HARD_WALLET_SETUP_KEY, isSetup);\n  }\n\n  async saveSoftWalletData(wallets: StoredWallet[]): Promise<void> {\n    await this.saveSetting(this.SOFT_WALLET_DATA_KEY, wallets);\n  }\n\n  async saveHardWalletData(wallets: StoredWallet[]): Promise<void> {\n    await this.saveSetting(this.HARD_WALLET_DATA_KEY, wallets);\n  }\n\n  async getSoftWalletData(): Promise<StoredWallet[]> {\n    const stored = await this.getSetting<StoredWallet[]>(this.SOFT_WALLET_DATA_KEY);\n    return stored || [];\n  }\n\n  async getHardWalletData(): Promise<StoredWallet[]> {\n    const stored = await this.getSetting<StoredWallet[]>(this.HARD_WALLET_DATA_KEY);\n    return stored || [];\n  }\n\n  async clearSoftWallet(): Promise<void> {\n    await this.deleteSetting(this.SOFT_WALLET_SETUP_KEY);\n    await this.deleteSetting(this.SOFT_WALLET_DATA_KEY);\n  }\n\n  async clearHardWallet(): Promise<void> {\n    await this.deleteSetting(this.HARD_WALLET_SETUP_KEY);\n    await this.deleteSetting(this.HARD_WALLET_DATA_KEY);\n    await this.clearHardWalletEncryptedSeed();\n  }\n\n  // Encrypted seed phrase storage for soft wallet (like MetaMask/Trust Wallet)\n  private readonly SOFT_WALLET_ENCRYPTED_SEED_KEY = \"softWalletEncryptedSeed\";\n  private readonly SOFT_WALLET_PIN_HASH_KEY = \"softWalletPinHash\";\n  private readonly SOFT_WALLET_PIN_SALT_KEY = \"softWalletPinSalt\";\n\n  async saveEncryptedSeed(encryptedSeed: string, pinHash: string, pinSalt: string): Promise<void> {\n    await this.saveSetting(this.SOFT_WALLET_ENCRYPTED_SEED_KEY, encryptedSeed);\n    await this.saveSetting(this.SOFT_WALLET_PIN_HASH_KEY, pinHash);\n    await this.saveSetting(this.SOFT_WALLET_PIN_SALT_KEY, pinSalt);\n  }\n\n  async getEncryptedSeed(): Promise<string | null> {\n    return await this.getSetting<string>(this.SOFT_WALLET_ENCRYPTED_SEED_KEY);\n  }\n\n  async getPinHash(): Promise<string | null> {\n    return await this.getSetting<string>(this.SOFT_WALLET_PIN_HASH_KEY);\n  }\n\n  async getPinSalt(): Promise<string | null> {\n    return await this.getSetting<string>(this.SOFT_WALLET_PIN_SALT_KEY);\n  }\n\n  async hasEncryptedSeed(): Promise<boolean> {\n    const seed = await this.getEncryptedSeed();\n    return seed !== null && seed.length > 0;\n  }\n\n  async clearEncryptedSeed(): Promise<void> {\n    await this.deleteSetting(this.SOFT_WALLET_ENCRYPTED_SEED_KEY);\n    await this.deleteSetting(this.SOFT_WALLET_PIN_HASH_KEY);\n    await this.deleteSetting(this.SOFT_WALLET_PIN_SALT_KEY);\n  }\n\n  // Encrypted seed phrase storage for hardware wallet (simulated mode)\n  private readonly HARD_WALLET_ENCRYPTED_SEED_KEY = \"hardWalletEncryptedSeed\";\n  private readonly HARD_WALLET_PIN_HASH_KEY = \"hardWalletPinHash\";\n  private readonly HARD_WALLET_PIN_SALT_KEY = \"hardWalletPinSalt\";\n\n  async saveHardWalletEncryptedSeed(encryptedSeed: string, pinHash: string, pinSalt: string): Promise<void> {\n    await this.saveSetting(this.HARD_WALLET_ENCRYPTED_SEED_KEY, encryptedSeed);\n    await this.saveSetting(this.HARD_WALLET_PIN_HASH_KEY, pinHash);\n    await this.saveSetting(this.HARD_WALLET_PIN_SALT_KEY, pinSalt);\n  }\n\n  async getHardWalletEncryptedSeed(): Promise<string | null> {\n    return await this.getSetting<string>(this.HARD_WALLET_ENCRYPTED_SEED_KEY);\n  }\n\n  async getHardWalletPinHash(): Promise<string | null> {\n    return await this.getSetting<string>(this.HARD_WALLET_PIN_HASH_KEY);\n  }\n\n  async getHardWalletPinSalt(): Promise<string | null> {\n    return await this.getSetting<string>(this.HARD_WALLET_PIN_SALT_KEY);\n  }\n\n  async hasHardWalletEncryptedSeed(): Promise<boolean> {\n    const seed = await this.getHardWalletEncryptedSeed();\n    return seed !== null && seed.length > 0;\n  }\n\n  async clearHardWalletEncryptedSeed(): Promise<void> {\n    await this.deleteSetting(this.HARD_WALLET_ENCRYPTED_SEED_KEY);\n    await this.deleteSetting(this.HARD_WALLET_PIN_HASH_KEY);\n    await this.deleteSetting(this.HARD_WALLET_PIN_SALT_KEY);\n  }\n\n  // Hardware wallet chain preferences (fallback storage when device doesn't support it)\n  private readonly HARD_WALLET_CHAIN_PREFS_KEY = \"hardWalletChainPreferences\";\n\n  async saveHardWalletChainPreferences(chains: { symbol: string; accountIndex: number; label?: string }[]): Promise<void> {\n    await this.saveSetting(this.HARD_WALLET_CHAIN_PREFS_KEY, chains);\n  }\n\n  async getHardWalletChainPreferences(): Promise<{ symbol: string; accountIndex: number; label?: string }[] | null> {\n    return await this.getSetting<{ symbol: string; accountIndex: number; label?: string }[]>(this.HARD_WALLET_CHAIN_PREFS_KEY);\n  }\n\n  async clearHardWalletChainPreferences(): Promise<void> {\n    await this.deleteSetting(this.HARD_WALLET_CHAIN_PREFS_KEY);\n  }\n\n  // Get the next available account index for creating additional wallets\n  getNextAccountIndex(wallets: StoredWallet[]): number {\n    if (wallets.length === 0) return 0;\n    const maxIndex = Math.max(...wallets.map(w => w.accountIndex ?? 0));\n    return maxIndex + 1;\n  }\n\n  // Multiple wallet seed storage (independent seeds per wallet group)\n  private readonly WALLET_SEEDS_KEY = \"walletSeeds\";\n\n  async saveWalletSeed(seed: StoredWalletSeed): Promise<void> {\n    const seeds = await this.getAllWalletSeeds();\n    const existingIndex = seeds.findIndex(s => s.walletGroupId === seed.walletGroupId);\n    if (existingIndex >= 0) {\n      seeds[existingIndex] = seed;\n    } else {\n      seeds.push(seed);\n    }\n    await this.saveSetting(this.WALLET_SEEDS_KEY, seeds);\n  }\n\n  async getWalletSeed(walletGroupId: string): Promise<StoredWalletSeed | null> {\n    const seeds = await this.getAllWalletSeeds();\n    return seeds.find(s => s.walletGroupId === walletGroupId) || null;\n  }\n\n  async getAllWalletSeeds(): Promise<StoredWalletSeed[]> {\n    const stored = await this.getSetting<StoredWalletSeed[]>(this.WALLET_SEEDS_KEY);\n    return stored || [];\n  }\n\n  async deleteWalletSeed(walletGroupId: string): Promise<void> {\n    const seeds = await this.getAllWalletSeeds();\n    const filtered = seeds.filter(s => s.walletGroupId !== walletGroupId);\n    await this.saveSetting(this.WALLET_SEEDS_KEY, filtered);\n  }\n\n  async clearAllWalletSeeds(): Promise<void> {\n    await this.deleteSetting(this.WALLET_SEEDS_KEY);\n  }\n\n  // Custom token management\n  private readonly CUSTOM_TOKENS_KEY = \"customTokens\";\n\n  async getCustomTokens(): Promise<CustomToken[]> {\n    const stored = await this.getSetting<CustomToken[]>(this.CUSTOM_TOKENS_KEY);\n    return stored || [];\n  }\n\n  async addCustomToken(token: Omit<CustomToken, 'id' | 'addedAt'>): Promise<CustomToken> {\n    const tokens = await this.getCustomTokens();\n    // Include walletId in the token ID to make tokens wallet-specific\n    const newToken: CustomToken = {\n      ...token,\n      id: `custom-${token.walletId}-${token.chainId}-${token.contractAddress.toLowerCase()}`,\n      addedAt: new Date().toISOString(),\n    };\n    \n    const existingIndex = tokens.findIndex(t => t.id === newToken.id);\n    if (existingIndex >= 0) {\n      tokens[existingIndex] = newToken;\n    } else {\n      tokens.push(newToken);\n    }\n    \n    await this.saveSetting(this.CUSTOM_TOKENS_KEY, tokens);\n    return newToken;\n  }\n\n  async removeCustomToken(id: string): Promise<void> {\n    const tokens = await this.getCustomTokens();\n    const filtered = tokens.filter(t => t.id !== id);\n    await this.saveSetting(this.CUSTOM_TOKENS_KEY, filtered);\n  }\n\n  async getCustomToken(id: string): Promise<CustomToken | null> {\n    const tokens = await this.getCustomTokens();\n    return tokens.find(t => t.id === id) || null;\n  }\n\n  async clearAllCustomTokens(): Promise<void> {\n    await this.deleteSetting(this.CUSTOM_TOKENS_KEY);\n  }\n\n  // Custom chain management\n  private readonly CUSTOM_CHAINS_KEY = \"customChains\";\n\n  async getCustomChains(): Promise<CustomChain[]> {\n    const stored = await this.getSetting<CustomChain[]>(this.CUSTOM_CHAINS_KEY);\n    return stored || [];\n  }\n\n  async addCustomChain(chain: Omit<CustomChain, 'id' | 'addedAt'>): Promise<CustomChain> {\n    const chains = await this.getCustomChains();\n    const newChain: CustomChain = {\n      ...chain,\n      id: `custom-chain-${chain.chainId}`,\n      addedAt: new Date().toISOString(),\n    };\n    \n    const existingIndex = chains.findIndex(c => c.id === newChain.id);\n    if (existingIndex >= 0) {\n      chains[existingIndex] = newChain;\n    } else {\n      chains.push(newChain);\n    }\n    \n    await this.saveSetting(this.CUSTOM_CHAINS_KEY, chains);\n    return newChain;\n  }\n\n  async removeCustomChain(id: string): Promise<void> {\n    const chains = await this.getCustomChains();\n    const filtered = chains.filter(c => c.id !== id);\n    await this.saveSetting(this.CUSTOM_CHAINS_KEY, filtered);\n  }\n\n  async getCustomChain(id: string): Promise<CustomChain | null> {\n    const chains = await this.getCustomChains();\n    return chains.find(c => c.id === id) || null;\n  }\n\n  async clearAllCustomChains(): Promise<void> {\n    await this.deleteSetting(this.CUSTOM_CHAINS_KEY);\n  }\n\n  private readonly BALANCE_CACHE_KEY = \"balanceCache\";\n  private readonly CACHE_STALE_THRESHOLD = 5 * 60 * 1000;\n  private readonly CACHE_EXPIRE_THRESHOLD = 30 * 60 * 1000;\n\n  private getBalanceCacheKey(address: string, chainSymbol: string): string {\n    return `${address.toLowerCase()}-${chainSymbol}`;\n  }\n\n  async getBalanceCache(): Promise<BalanceCacheEntry> {\n    const stored = await this.getSetting<BalanceCacheEntry>(this.BALANCE_CACHE_KEY);\n    return stored || { balances: {}, lastFullRefresh: 0 };\n  }\n\n  async getCachedBalance(address: string, chainSymbol: string): Promise<CachedBalance | null> {\n    const cache = await this.getBalanceCache();\n    const key = this.getBalanceCacheKey(address, chainSymbol);\n    const entry = cache.balances[key];\n    \n    if (!entry) return null;\n    \n    const now = Date.now();\n    const age = now - entry.timestamp;\n    \n    if (age > this.CACHE_EXPIRE_THRESHOLD) {\n      return null;\n    }\n    \n    return {\n      ...entry,\n      isStale: age > this.CACHE_STALE_THRESHOLD,\n    };\n  }\n\n  async setCachedBalance(address: string, chainSymbol: string, chainId: number, balance: string): Promise<void> {\n    const cache = await this.getBalanceCache();\n    const key = this.getBalanceCacheKey(address, chainSymbol);\n    \n    cache.balances[key] = {\n      address: address.toLowerCase(),\n      chainSymbol,\n      chainId,\n      balance,\n      timestamp: Date.now(),\n    };\n    \n    await this.saveSetting(this.BALANCE_CACHE_KEY, cache);\n  }\n\n  async setCachedBalances(balances: Array<{ address: string; chainSymbol: string; chainId: number; balance: string }>): Promise<void> {\n    const cache = await this.getBalanceCache();\n    const now = Date.now();\n    \n    for (const b of balances) {\n      const key = this.getBalanceCacheKey(b.address, b.chainSymbol);\n      cache.balances[key] = {\n        address: b.address.toLowerCase(),\n        chainSymbol: b.chainSymbol,\n        chainId: b.chainId,\n        balance: b.balance,\n        timestamp: now,\n      };\n    }\n    \n    cache.lastFullRefresh = now;\n    await this.saveSetting(this.BALANCE_CACHE_KEY, cache);\n  }\n\n  async getAllCachedBalances(): Promise<CachedBalance[]> {\n    const cache = await this.getBalanceCache();\n    const now = Date.now();\n    \n    return Object.values(cache.balances).map(entry => ({\n      ...entry,\n      isStale: (now - entry.timestamp) > this.CACHE_STALE_THRESHOLD,\n    })).filter(entry => (now - entry.timestamp) <= this.CACHE_EXPIRE_THRESHOLD);\n  }\n\n  async getLastFullRefresh(): Promise<number> {\n    const cache = await this.getBalanceCache();\n    return cache.lastFullRefresh;\n  }\n\n  async clearBalanceCache(): Promise<void> {\n    await this.deleteSetting(this.BALANCE_CACHE_KEY);\n  }\n\n  isCacheStale(timestamp: number): boolean {\n    return (Date.now() - timestamp) > this.CACHE_STALE_THRESHOLD;\n  }\n\n  getCacheAge(timestamp: number): string {\n    const age = Date.now() - timestamp;\n    const minutes = Math.floor(age / 60000);\n    if (minutes < 1) return \"just now\";\n    if (minutes === 1) return \"1 min ago\";\n    if (minutes < 60) return `${minutes} mins ago`;\n    const hours = Math.floor(minutes / 60);\n    if (hours === 1) return \"1 hour ago\";\n    return `${hours} hours ago`;\n  }\n}\n\nexport const clientStorage = new ClientStorage();\n","path":null,"size_bytes":23793,"size_tokens":null},"client/src/components/ui/card.tsx":{"content":"import * as React from \"react\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst Card = React.forwardRef<\n  HTMLDivElement,\n  React.HTMLAttributes<HTMLDivElement>\n>(({ className, ...props }, ref) => (\n  <div\n    ref={ref}\n    className={cn(\n      \"shadcn-card rounded-xl border bg-card border-card-border text-card-foreground shadow-sm\",\n      className\n    )}\n    {...props}\n  />\n));\nCard.displayName = \"Card\"\n\nconst CardHeader = React.forwardRef<\n  HTMLDivElement,\n  React.HTMLAttributes<HTMLDivElement>\n>(({ className, ...props }, ref) => (\n  <div\n    ref={ref}\n    className={cn(\"flex flex-col space-y-1.5 p-6\", className)}\n    {...props}\n  />\n));\nCardHeader.displayName = \"CardHeader\"\n\nconst CardTitle = React.forwardRef<\n  HTMLDivElement,\n  React.HTMLAttributes<HTMLDivElement>\n>(({ className, ...props }, ref) => (\n  <div\n    ref={ref}\n    className={cn(\n      \"text-2xl font-semibold leading-none tracking-tight\",\n      className\n    )}\n    {...props}\n  />\n))\nCardTitle.displayName = \"CardTitle\"\n\nconst CardDescription = React.forwardRef<\n  HTMLDivElement,\n  React.HTMLAttributes<HTMLDivElement>\n>(({ className, ...props }, ref) => (\n  <div\n    ref={ref}\n    className={cn(\"text-sm text-muted-foreground\", className)}\n    {...props}\n  />\n));\nCardDescription.displayName = \"CardDescription\"\n\nconst CardContent = React.forwardRef<\n  HTMLDivElement,\n  React.HTMLAttributes<HTMLDivElement>\n>(({ className, ...props }, ref) => (\n  <div ref={ref} className={cn(\"p-6 pt-0\", className)} {...props} />\n))\nCardContent.displayName = \"CardContent\"\n\nconst CardFooter = React.forwardRef<\n  HTMLDivElement,\n  React.HTMLAttributes<HTMLDivElement>\n>(({ className, ...props }, ref) => (\n  <div\n    ref={ref}\n    className={cn(\"flex items-center p-6 pt-0\", className)}\n    {...props}\n  />\n))\nCardFooter.displayName = \"CardFooter\"\nexport {\n  Card,\n  CardHeader,\n  CardFooter,\n  CardTitle,\n  CardDescription,\n  CardContent,\n}\n","path":null,"size_bytes":1904,"size_tokens":null},"client/src/components/ui/badge.tsx":{"content":"import * as React from \"react\"\nimport { cva, type VariantProps } from \"class-variance-authority\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst badgeVariants = cva(\n  // Whitespace-nowrap: Badges should never wrap.\n  \"whitespace-nowrap inline-flex items-center rounded-md border px-2.5 py-0.5 text-xs font-semibold transition-colors focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2\" +\n  \" hover-elevate \" ,\n  {\n    variants: {\n      variant: {\n        default:\n          \"border-transparent bg-primary text-primary-foreground shadow-xs\",\n        secondary: \"border-transparent bg-secondary text-secondary-foreground\",\n        destructive:\n          \"border-transparent bg-destructive text-destructive-foreground shadow-xs\",\n\n        outline: \" border [border-color:var(--badge-outline)] shadow-xs\",\n      },\n    },\n    defaultVariants: {\n      variant: \"default\",\n    },\n  },\n)\n\nexport interface BadgeProps\n  extends React.HTMLAttributes<HTMLDivElement>,\n    VariantProps<typeof badgeVariants> {}\n\nfunction Badge({ className, variant, ...props }: BadgeProps) {\n  return (\n    <div className={cn(badgeVariants({ variant }), className)} {...props} />\n  );\n}\n\nexport { Badge, badgeVariants }\n","path":null,"size_bytes":1202,"size_tokens":null},"vite.config.ts":{"content":"import { defineConfig } from \"vite\";\nimport react from \"@vitejs/plugin-react\";\nimport path from \"path\";\nimport runtimeErrorOverlay from \"@replit/vite-plugin-runtime-error-modal\";\n\nexport default defineConfig({\n  plugins: [\n    react(),\n    runtimeErrorOverlay(),\n    ...(process.env.NODE_ENV !== \"production\" &&\n    process.env.REPL_ID !== undefined\n      ? [\n          await import(\"@replit/vite-plugin-cartographer\").then((m) =>\n            m.cartographer(),\n          ),\n          await import(\"@replit/vite-plugin-dev-banner\").then((m) =>\n            m.devBanner(),\n          ),\n        ]\n      : []),\n  ],\n  resolve: {\n    alias: {\n      \"@\": path.resolve(import.meta.dirname, \"client\", \"src\"),\n      \"@shared\": path.resolve(import.meta.dirname, \"shared\"),\n      \"@assets\": path.resolve(import.meta.dirname, \"attached_assets\"),\n    },\n  },\n  root: path.resolve(import.meta.dirname, \"client\"),\n  build: {\n    outDir: path.resolve(import.meta.dirname, \"dist/public\"),\n    emptyOutDir: true,\n  },\n  server: {\n    fs: {\n      strict: true,\n      deny: [\"**/.*\"],\n    },\n  },\n});\n","path":null,"size_bytes":1080,"size_tokens":null},"client/src/components/ui/separator.tsx":{"content":"import * as React from \"react\"\nimport * as SeparatorPrimitive from \"@radix-ui/react-separator\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst Separator = React.forwardRef<\n  React.ElementRef<typeof SeparatorPrimitive.Root>,\n  React.ComponentPropsWithoutRef<typeof SeparatorPrimitive.Root>\n>(\n  (\n    { className, orientation = \"horizontal\", decorative = true, ...props },\n    ref\n  ) => (\n    <SeparatorPrimitive.Root\n      ref={ref}\n      decorative={decorative}\n      orientation={orientation}\n      className={cn(\n        \"shrink-0 bg-border\",\n        orientation === \"horizontal\" ? \"h-[1px] w-full\" : \"h-full w-[1px]\",\n        className\n      )}\n      {...props}\n    />\n  )\n)\nSeparator.displayName = SeparatorPrimitive.Root.displayName\n\nexport { Separator }\n","path":null,"size_bytes":756,"size_tokens":null},"client/src/lib/non-evm-chains.ts":{"content":"import * as bip39 from \"bip39\";\nimport bs58 from \"bs58\";\nimport { ethers } from \"ethers\";\nimport nacl from \"tweetnacl\";\nimport { blake2b } from \"blakejs\";\n\nexport const DERIVATION_PATHS = {\n  bitcoin: \"m/84'/0'/0'/0/0\",\n  ethereum: \"m/44'/60'/0'/0/0\",\n  solana: \"m/44'/501'/0'/0'\",\n  tron: \"m/44'/195'/0'/0/0\",\n};\n\nexport const RPC_ENDPOINTS = {\n  bitcoin: \"https://blockstream.info/api\",\n  solana: \"https://api.mainnet-beta.solana.com\",\n  tron: \"https://api.trongrid.io\",\n};\n\nexport interface NonEvmTransactionParams {\n  chainType: \"bitcoin\" | \"solana\" | \"tron\";\n  from: string;\n  to: string;\n  amount: string;\n  tokenAddress?: string;\n  isNativeToken?: boolean;\n}\n\nexport interface SignedTransaction {\n  chainType: string;\n  signedTx: string;\n  txHash?: string;\n}\n\nfunction sha256Hash(data: Uint8Array): Uint8Array {\n  return ethers.getBytes(ethers.sha256(data));\n}\n\nfunction ripemd160Hash(data: Uint8Array): Uint8Array {\n  return ethers.getBytes(ethers.ripemd160(data));\n}\n\nfunction base58CheckEncode(payload: Uint8Array): string {\n  const hash1 = sha256Hash(payload);\n  const hash2 = sha256Hash(hash1);\n  const checksum = hash2.slice(0, 4);\n  const addressBytes = new Uint8Array(payload.length + 4);\n  addressBytes.set(payload);\n  addressBytes.set(checksum, payload.length);\n  return bs58.encode(addressBytes);\n}\n\nfunction hash160(data: Uint8Array): Uint8Array {\n  return ripemd160Hash(sha256Hash(data));\n}\n\nexport function deriveBitcoinAddress(seedPhrase: string): { address: string; privateKey: string; publicKey: string } {\n  const hdNode = ethers.HDNodeWallet.fromPhrase(seedPhrase, undefined, DERIVATION_PATHS.bitcoin);\n  const publicKeyBytes = ethers.getBytes(hdNode.publicKey);\n  const pubKeyHash = hash160(publicKeyBytes);\n  const witnessProgram = new Uint8Array([0x00, 0x14, ...pubKeyHash]);\n  const scriptHash = hash160(witnessProgram);\n  const payload = new Uint8Array(21);\n  payload[0] = 0x05;\n  payload.set(scriptHash, 1);\n  const address = base58CheckEncode(payload);\n\n  return {\n    address,\n    privateKey: hdNode.privateKey,\n    publicKey: hdNode.publicKey,\n  };\n}\n\nexport function deriveBitcoinP2WPKHAddress(seedPhrase: string): { address: string; privateKey: string; publicKey: string } {\n  const hdNode = ethers.HDNodeWallet.fromPhrase(seedPhrase, undefined, DERIVATION_PATHS.bitcoin);\n  const publicKeyBytes = ethers.getBytes(hdNode.publicKey);\n  const pubKeyHash = hash160(publicKeyBytes);\n  const words = bech32ToWords(pubKeyHash);\n  const address = bech32Encode(\"bc\", [0, ...words]);\n\n  return {\n    address,\n    privateKey: hdNode.privateKey,\n    publicKey: hdNode.publicKey,\n  };\n}\n\nfunction bech32ToWords(data: Uint8Array): number[] {\n  const words: number[] = [];\n  let accumulator = 0;\n  let bits = 0;\n  \n  for (const byte of data) {\n    accumulator = (accumulator << 8) | byte;\n    bits += 8;\n    while (bits >= 5) {\n      bits -= 5;\n      words.push((accumulator >> bits) & 0x1f);\n    }\n  }\n  \n  if (bits > 0) {\n    words.push((accumulator << (5 - bits)) & 0x1f);\n  }\n  \n  return words;\n}\n\nfunction bech32Encode(hrp: string, data: number[]): string {\n  const CHARSET = \"qpzry9x8gf2tvdw0s3jn54khce6mua7l\";\n  \n  function polymod(values: number[]): number {\n    const GEN = [0x3b6a57b2, 0x26508e6d, 0x1ea119fa, 0x3d4233dd, 0x2a1462b3];\n    let chk = 1;\n    for (const v of values) {\n      const b = chk >> 25;\n      chk = ((chk & 0x1ffffff) << 5) ^ v;\n      for (let i = 0; i < 5; i++) {\n        if ((b >> i) & 1) {\n          chk ^= GEN[i];\n        }\n      }\n    }\n    return chk;\n  }\n  \n  function hrpExpand(hrp: string): number[] {\n    const ret: number[] = [];\n    for (const c of hrp) {\n      ret.push(c.charCodeAt(0) >> 5);\n    }\n    ret.push(0);\n    for (const c of hrp) {\n      ret.push(c.charCodeAt(0) & 31);\n    }\n    return ret;\n  }\n  \n  function createChecksum(hrp: string, data: number[]): number[] {\n    const values = [...hrpExpand(hrp), ...data, 0, 0, 0, 0, 0, 0];\n    const mod = polymod(values) ^ 1;\n    const ret: number[] = [];\n    for (let p = 0; p < 6; p++) {\n      ret.push((mod >> (5 * (5 - p))) & 31);\n    }\n    return ret;\n  }\n  \n  const checksum = createChecksum(hrp, data);\n  let result = hrp + \"1\";\n  for (const d of [...data, ...checksum]) {\n    result += CHARSET[d];\n  }\n  return result;\n}\n\nexport function deriveSolanaAddress(seedPhrase: string): { address: string; secretKey: Uint8Array; keypair: nacl.SignKeyPair } {\n  const seed = bip39.mnemonicToSeedSync(seedPhrase);\n  const derivedSeed = seed.slice(0, 32);\n  const keypair = nacl.sign.keyPair.fromSeed(derivedSeed);\n  const address = bs58.encode(keypair.publicKey);\n  \n  return {\n    address,\n    secretKey: keypair.secretKey,\n    keypair,\n  };\n}\n\nexport function deriveTronAddress(seedPhrase: string): { address: string; privateKey: string } {\n  const hdNode = ethers.HDNodeWallet.fromPhrase(seedPhrase, undefined, DERIVATION_PATHS.tron);\n  const signingKey = new ethers.SigningKey(hdNode.privateKey);\n  const publicKeyUncompressed = signingKey.publicKey;\n  const publicKeyWithoutPrefix = ethers.getBytes(publicKeyUncompressed).slice(1);\n  const addressHashHex = ethers.keccak256(publicKeyWithoutPrefix);\n  const addressHash = ethers.getBytes(addressHashHex);\n  const addressBytes = new Uint8Array(21);\n  addressBytes[0] = 0x41;\n  addressBytes.set(addressHash.slice(12), 1);\n  const firstHash = ethers.sha256(addressBytes);\n  const secondHash = ethers.sha256(ethers.getBytes(firstHash));\n  const checksum = ethers.getBytes(secondHash).slice(0, 4);\n  const addressWithChecksum = new Uint8Array(25);\n  addressWithChecksum.set(addressBytes);\n  addressWithChecksum.set(checksum, 21);\n  const address = bs58.encode(addressWithChecksum);\n\n  return {\n    address,\n    privateKey: hdNode.privateKey.slice(2),\n  };\n}\n\nexport function getNonEvmAddresses(seedPhrase: string): {\n  bitcoin: string;\n  solana: string;\n  tron: string;\n} {\n  const btc = deriveBitcoinP2WPKHAddress(seedPhrase);\n  const sol = deriveSolanaAddress(seedPhrase);\n  const trx = deriveTronAddress(seedPhrase);\n\n  return {\n    bitcoin: btc.address,\n    solana: sol.address,\n    tron: trx.address,\n  };\n}\n\nasync function fetchBitcoinUtxos(address: string): Promise<{ txid: string; vout: number; value: number }[]> {\n  try {\n    const response = await fetch(`${RPC_ENDPOINTS.bitcoin}/address/${address}/utxo`);\n    if (!response.ok) return [];\n    return await response.json();\n  } catch {\n    return [];\n  }\n}\n\nasync function fetchBitcoinFeeRate(): Promise<number> {\n  try {\n    const response = await fetch(`${RPC_ENDPOINTS.bitcoin}/fee-estimates`);\n    if (!response.ok) return 10;\n    const fees = await response.json();\n    return Math.ceil(fees[\"6\"] || 10);\n  } catch {\n    return 10;\n  }\n}\n\ninterface DecodedAddress {\n  type: \"p2wpkh\" | \"p2wsh\" | \"p2tr\" | \"p2pkh\" | \"p2sh\";\n  program: Uint8Array;\n  witnessVersion?: number;\n}\n\nfunction bech32Polymod(values: number[]): number {\n  const GEN = [0x3b6a57b2, 0x26508e6d, 0x1ea119fa, 0x3d4233dd, 0x2a1462b3];\n  let chk = 1;\n  for (const v of values) {\n    const b = chk >> 25;\n    chk = ((chk & 0x1ffffff) << 5) ^ v;\n    for (let i = 0; i < 5; i++) {\n      if ((b >> i) & 1) {\n        chk ^= GEN[i];\n      }\n    }\n  }\n  return chk;\n}\n\nfunction bech32HrpExpand(hrp: string): number[] {\n  const ret: number[] = [];\n  for (const c of hrp) {\n    ret.push(c.charCodeAt(0) >> 5);\n  }\n  ret.push(0);\n  for (const c of hrp) {\n    ret.push(c.charCodeAt(0) & 31);\n  }\n  return ret;\n}\n\nfunction verifyBech32Checksum(hrp: string, data: number[]): \"bech32\" | \"bech32m\" | null {\n  const BECH32_CONST = 1;\n  const BECH32M_CONST = 0x2bc830a3;\n  \n  const values = [...bech32HrpExpand(hrp), ...data];\n  const polymod = bech32Polymod(values);\n  \n  if (polymod === BECH32_CONST) return \"bech32\";\n  if (polymod === BECH32M_CONST) return \"bech32m\";\n  return null;\n}\n\nfunction decodeBech32Address(address: string): DecodedAddress | null {\n  const CHARSET = \"qpzry9x8gf2tvdw0s3jn54khce6mua7l\";\n  const pos = address.lastIndexOf(\"1\");\n  if (pos < 1 || pos + 7 > address.length) return null;\n  \n  const hrp = address.slice(0, pos).toLowerCase();\n  if (hrp !== \"bc\" && hrp !== \"tb\") return null;\n  \n  const data: number[] = [];\n  for (let i = pos + 1; i < address.length; i++) {\n    const idx = CHARSET.indexOf(address[i].toLowerCase());\n    if (idx === -1) return null;\n    data.push(idx);\n  }\n  \n  const encoding = verifyBech32Checksum(hrp, data);\n  if (!encoding) return null;\n  \n  const values = data.slice(0, -6);\n  if (values.length === 0 || values[0] > 16) return null;\n  \n  const witnessVersion = values[0];\n  \n  if (witnessVersion === 0 && encoding !== \"bech32\") return null;\n  if (witnessVersion >= 1 && encoding !== \"bech32m\") return null;\n  \n  const witness = values.slice(1);\n  let accumulator = 0;\n  let bits = 0;\n  const result: number[] = [];\n  \n  for (const value of witness) {\n    accumulator = (accumulator << 5) | value;\n    bits += 5;\n    while (bits >= 8) {\n      bits -= 8;\n      result.push((accumulator >> bits) & 0xff);\n    }\n  }\n  \n  const program = new Uint8Array(result);\n  \n  if (witnessVersion === 0 && program.length === 20) {\n    return { type: \"p2wpkh\", program, witnessVersion: 0 };\n  } else if (witnessVersion === 0 && program.length === 32) {\n    return { type: \"p2wsh\", program, witnessVersion: 0 };\n  } else if (witnessVersion === 1 && program.length === 32) {\n    return { type: \"p2tr\", program, witnessVersion: 1 };\n  }\n  \n  return null;\n}\n\nfunction decodeBase58Address(address: string): DecodedAddress | null {\n  try {\n    const decoded = bs58.decode(address);\n    if (decoded.length !== 25) return null;\n    \n    const payload = decoded.slice(0, 21);\n    const checksum = decoded.slice(21);\n    \n    const hash1 = sha256Hash(payload);\n    const hash2 = sha256Hash(hash1);\n    const expectedChecksum = hash2.slice(0, 4);\n    \n    for (let i = 0; i < 4; i++) {\n      if (checksum[i] !== expectedChecksum[i]) return null;\n    }\n    \n    const version = payload[0];\n    const hash = payload.slice(1);\n    \n    if (version === 0x00) {\n      return { type: \"p2pkh\", program: hash };\n    } else if (version === 0x05) {\n      return { type: \"p2sh\", program: hash };\n    }\n    \n    return null;\n  } catch {\n    return null;\n  }\n}\n\nfunction decodeAnyBitcoinAddress(address: string): DecodedAddress | null {\n  if (address.toLowerCase().startsWith(\"bc1\") || address.toLowerCase().startsWith(\"tb1\")) {\n    return decodeBech32Address(address);\n  }\n  return decodeBase58Address(address);\n}\n\nfunction createOutputScript(decoded: DecodedAddress): Uint8Array {\n  switch (decoded.type) {\n    case \"p2wpkh\":\n      return new Uint8Array([0x00, 0x14, ...decoded.program]);\n    case \"p2wsh\":\n      return new Uint8Array([0x00, 0x20, ...decoded.program]);\n    case \"p2tr\":\n      return new Uint8Array([0x51, 0x20, ...decoded.program]);\n    case \"p2pkh\":\n      return new Uint8Array([0x76, 0xa9, 0x14, ...decoded.program, 0x88, 0xac]);\n    case \"p2sh\":\n      return new Uint8Array([0xa9, 0x14, ...decoded.program, 0x87]);\n    default:\n      return new Uint8Array([0x00, 0x14, ...decoded.program]);\n  }\n}\n\nfunction writeVarInt(value: number): Uint8Array {\n  if (value < 0xfd) {\n    return new Uint8Array([value]);\n  } else if (value <= 0xffff) {\n    const buf = new Uint8Array(3);\n    buf[0] = 0xfd;\n    buf[1] = value & 0xff;\n    buf[2] = (value >> 8) & 0xff;\n    return buf;\n  } else {\n    const buf = new Uint8Array(5);\n    buf[0] = 0xfe;\n    buf[1] = value & 0xff;\n    buf[2] = (value >> 8) & 0xff;\n    buf[3] = (value >> 16) & 0xff;\n    buf[4] = (value >> 24) & 0xff;\n    return buf;\n  }\n}\n\nfunction reverseBytes(hex: string): Uint8Array {\n  const bytes = ethers.getBytes(\"0x\" + hex);\n  const reversed = new Uint8Array(bytes.length);\n  for (let i = 0; i < bytes.length; i++) {\n    reversed[i] = bytes[bytes.length - 1 - i];\n  }\n  return reversed;\n}\n\nfunction writeUint32LE(value: number): Uint8Array {\n  const buf = new Uint8Array(4);\n  buf[0] = value & 0xff;\n  buf[1] = (value >> 8) & 0xff;\n  buf[2] = (value >> 16) & 0xff;\n  buf[3] = (value >> 24) & 0xff;\n  return buf;\n}\n\nfunction writeUint64LE(value: bigint): Uint8Array {\n  const buf = new Uint8Array(8);\n  for (let i = 0; i < 8; i++) {\n    buf[i] = Number((value >> BigInt(i * 8)) & BigInt(0xff));\n  }\n  return buf;\n}\n\nfunction createP2WPKHScriptPubKey(pubKeyHash: Uint8Array): Uint8Array {\n  return new Uint8Array([0x00, 0x14, ...pubKeyHash]);\n}\n\nfunction createP2PKHScript(pubKeyHash: Uint8Array): Uint8Array {\n  return new Uint8Array([0x76, 0xa9, 0x14, ...pubKeyHash, 0x88, 0xac]);\n}\n\nexport async function buildBitcoinTransaction(\n  params: NonEvmTransactionParams,\n  seedPhrase: string\n): Promise<{ signedTx: string; txHash: string } | null> {\n  try {\n    const { address, privateKey, publicKey } = deriveBitcoinP2WPKHAddress(seedPhrase);\n    \n    if (params.from !== address) {\n      console.error(\"Address mismatch: expected\", address, \"got\", params.from);\n      return null;\n    }\n\n    const utxos = await fetchBitcoinUtxos(address);\n    if (utxos.length === 0) {\n      console.error(\"No UTXOs available\");\n      return null;\n    }\n\n    const feeRate = await fetchBitcoinFeeRate();\n    const amountSatoshis = BigInt(Math.floor(parseFloat(params.amount) * 100000000));\n    \n    const estimatedSize = 110 + (utxos.length * 68);\n    const fee = BigInt(feeRate * estimatedSize);\n    \n    let totalInput = BigInt(0);\n    const selectedUtxos: { txid: string; vout: number; value: number }[] = [];\n    \n    for (const utxo of utxos) {\n      selectedUtxos.push(utxo);\n      totalInput += BigInt(utxo.value);\n      if (totalInput >= amountSatoshis + fee) break;\n    }\n    \n    if (totalInput < amountSatoshis + fee) {\n      console.error(\"Insufficient funds\");\n      return null;\n    }\n\n    const change = totalInput - amountSatoshis - fee;\n    const publicKeyBytes = ethers.getBytes(publicKey);\n    const pubKeyHash = hash160(publicKeyBytes);\n    \n    const decodedRecipient = decodeAnyBitcoinAddress(params.to);\n    if (!decodedRecipient) {\n      console.error(\"Invalid recipient address\");\n      return null;\n    }\n\n    const version = new Uint8Array([0x01, 0x00, 0x00, 0x00]);\n    const marker = new Uint8Array([0x00]);\n    const flag = new Uint8Array([0x01]);\n    const inputCount = writeVarInt(selectedUtxos.length);\n    \n    const inputs: Uint8Array[] = [];\n    for (const utxo of selectedUtxos) {\n      const txidBytes = reverseBytes(utxo.txid);\n      const voutBytes = writeUint32LE(utxo.vout);\n      const scriptSig = new Uint8Array([0x00]);\n      const sequence = new Uint8Array([0xff, 0xff, 0xff, 0xff]);\n      \n      const input = new Uint8Array(txidBytes.length + voutBytes.length + scriptSig.length + sequence.length);\n      let offset = 0;\n      input.set(txidBytes, offset); offset += txidBytes.length;\n      input.set(voutBytes, offset); offset += voutBytes.length;\n      input.set(scriptSig, offset); offset += scriptSig.length;\n      input.set(sequence, offset);\n      inputs.push(input);\n    }\n    \n    const outputs: Uint8Array[] = [];\n    const outputScriptPubKey = createOutputScript(decodedRecipient);\n    const outputValue = writeUint64LE(amountSatoshis);\n    const outputScriptLen = writeVarInt(outputScriptPubKey.length);\n    \n    const output1 = new Uint8Array(outputValue.length + outputScriptLen.length + outputScriptPubKey.length);\n    let off = 0;\n    output1.set(outputValue, off); off += outputValue.length;\n    output1.set(outputScriptLen, off); off += outputScriptLen.length;\n    output1.set(outputScriptPubKey, off);\n    outputs.push(output1);\n    \n    let outputCount = 1;\n    if (change > BigInt(546)) {\n      outputCount = 2;\n      const changeScriptPubKey = createP2WPKHScriptPubKey(pubKeyHash);\n      const changeValue = writeUint64LE(change);\n      const changeScriptLen = writeVarInt(changeScriptPubKey.length);\n      \n      const output2 = new Uint8Array(changeValue.length + changeScriptLen.length + changeScriptPubKey.length);\n      let off2 = 0;\n      output2.set(changeValue, off2); off2 += changeValue.length;\n      output2.set(changeScriptLen, off2); off2 += changeScriptLen.length;\n      output2.set(changeScriptPubKey, off2);\n      outputs.push(output2);\n    }\n    \n    const outputCountBytes = writeVarInt(outputCount);\n    const locktime = new Uint8Array([0x00, 0x00, 0x00, 0x00]);\n    \n    const witnesses: Uint8Array[] = [];\n    const signingKey = new ethers.SigningKey(privateKey);\n    \n    for (let i = 0; i < selectedUtxos.length; i++) {\n      const utxo = selectedUtxos[i];\n      \n      const hashPrevouts = sha256Hash(sha256Hash((() => {\n        const parts: Uint8Array[] = [];\n        for (const u of selectedUtxos) {\n          parts.push(reverseBytes(u.txid));\n          parts.push(writeUint32LE(u.vout));\n        }\n        const total = parts.reduce((a, b) => a + b.length, 0);\n        const result = new Uint8Array(total);\n        let off = 0;\n        for (const p of parts) {\n          result.set(p, off);\n          off += p.length;\n        }\n        return result;\n      })()));\n      \n      const hashSequence = sha256Hash(sha256Hash((() => {\n        const seqs = new Uint8Array(selectedUtxos.length * 4);\n        for (let j = 0; j < selectedUtxos.length; j++) {\n          seqs.set([0xff, 0xff, 0xff, 0xff], j * 4);\n        }\n        return seqs;\n      })()));\n      \n      const hashOutputs = sha256Hash(sha256Hash((() => {\n        const total = outputs.reduce((a, b) => a + b.length, 0);\n        const result = new Uint8Array(total);\n        let off = 0;\n        for (const o of outputs) {\n          result.set(o, off);\n          off += o.length;\n        }\n        return result;\n      })()));\n      \n      const outpoint = new Uint8Array(36);\n      outpoint.set(reverseBytes(utxo.txid), 0);\n      outpoint.set(writeUint32LE(utxo.vout), 32);\n      \n      const scriptCode = createP2PKHScript(pubKeyHash);\n      const scriptCodeLen = writeVarInt(scriptCode.length);\n      const value = writeUint64LE(BigInt(utxo.value));\n      const sequence = new Uint8Array([0xff, 0xff, 0xff, 0xff]);\n      const sighashType = new Uint8Array([0x01, 0x00, 0x00, 0x00]);\n      \n      const preimageLen = 4 + hashPrevouts.length + hashSequence.length + 36 + \n                          scriptCodeLen.length + scriptCode.length + 8 + 4 + \n                          hashOutputs.length + 4 + 4;\n      const preimage = new Uint8Array(preimageLen);\n      let pOff = 0;\n      preimage.set(version, pOff); pOff += 4;\n      preimage.set(hashPrevouts, pOff); pOff += hashPrevouts.length;\n      preimage.set(hashSequence, pOff); pOff += hashSequence.length;\n      preimage.set(outpoint, pOff); pOff += 36;\n      preimage.set(scriptCodeLen, pOff); pOff += scriptCodeLen.length;\n      preimage.set(scriptCode, pOff); pOff += scriptCode.length;\n      preimage.set(value, pOff); pOff += 8;\n      preimage.set(sequence, pOff); pOff += 4;\n      preimage.set(hashOutputs, pOff); pOff += hashOutputs.length;\n      preimage.set(locktime, pOff); pOff += 4;\n      preimage.set(sighashType, pOff);\n      \n      const sigHash = sha256Hash(sha256Hash(preimage));\n      const sig = signingKey.sign(sigHash);\n      \n      const rBytes = ethers.getBytes(sig.r);\n      const sBytes = ethers.getBytes(sig.s);\n      \n      const rPadded = rBytes[0] >= 0x80 ? new Uint8Array([0x00, ...rBytes]) : rBytes;\n      const sPadded = sBytes[0] >= 0x80 ? new Uint8Array([0x00, ...sBytes]) : sBytes;\n      \n      const derSig = new Uint8Array([\n        0x30,\n        rPadded.length + sPadded.length + 4,\n        0x02,\n        rPadded.length,\n        ...rPadded,\n        0x02,\n        sPadded.length,\n        ...sPadded,\n        0x01\n      ]);\n      \n      const witness = new Uint8Array([\n        0x02,\n        derSig.length,\n        ...derSig,\n        publicKeyBytes.length,\n        ...publicKeyBytes\n      ]);\n      \n      witnesses.push(witness);\n    }\n    \n    let totalLen = version.length + marker.length + flag.length + inputCount.length;\n    for (const inp of inputs) totalLen += inp.length;\n    totalLen += outputCountBytes.length;\n    for (const out of outputs) totalLen += out.length;\n    for (const wit of witnesses) totalLen += wit.length;\n    totalLen += locktime.length;\n    \n    const signedTxBytes = new Uint8Array(totalLen);\n    let txOff = 0;\n    signedTxBytes.set(version, txOff); txOff += version.length;\n    signedTxBytes.set(marker, txOff); txOff += marker.length;\n    signedTxBytes.set(flag, txOff); txOff += flag.length;\n    signedTxBytes.set(inputCount, txOff); txOff += inputCount.length;\n    for (const inp of inputs) {\n      signedTxBytes.set(inp, txOff);\n      txOff += inp.length;\n    }\n    signedTxBytes.set(outputCountBytes, txOff); txOff += outputCountBytes.length;\n    for (const out of outputs) {\n      signedTxBytes.set(out, txOff);\n      txOff += out.length;\n    }\n    for (const wit of witnesses) {\n      signedTxBytes.set(wit, txOff);\n      txOff += wit.length;\n    }\n    signedTxBytes.set(locktime, txOff);\n    \n    const signedTx = ethers.hexlify(signedTxBytes).slice(2);\n    \n    let txForHash = version.length + inputCount.length;\n    for (const inp of inputs) txForHash += inp.length;\n    txForHash += outputCountBytes.length;\n    for (const out of outputs) txForHash += out.length;\n    txForHash += locktime.length;\n    \n    const txNoWitness = new Uint8Array(txForHash);\n    let nhOff = 0;\n    txNoWitness.set(version, nhOff); nhOff += version.length;\n    txNoWitness.set(inputCount, nhOff); nhOff += inputCount.length;\n    for (const inp of inputs) {\n      txNoWitness.set(inp, nhOff);\n      nhOff += inp.length;\n    }\n    txNoWitness.set(outputCountBytes, nhOff); nhOff += outputCountBytes.length;\n    for (const out of outputs) {\n      txNoWitness.set(out, nhOff);\n      nhOff += out.length;\n    }\n    txNoWitness.set(locktime, nhOff);\n    \n    const txHashBytes = sha256Hash(sha256Hash(txNoWitness));\n    const txHashReversed = new Uint8Array(txHashBytes.length);\n    for (let i = 0; i < txHashBytes.length; i++) {\n      txHashReversed[i] = txHashBytes[txHashBytes.length - 1 - i];\n    }\n    const txHash = ethers.hexlify(txHashReversed).slice(2);\n\n    return { signedTx, txHash };\n  } catch (error) {\n    console.error(\"Error building Bitcoin transaction:\", error);\n    return null;\n  }\n}\n\nexport async function buildSolanaTransaction(\n  params: NonEvmTransactionParams,\n  seedPhrase: string\n): Promise<{ signedTx: string; txHash: string } | null> {\n  try {\n    const { address, secretKey } = deriveSolanaAddress(seedPhrase);\n    \n    if (params.from !== address) {\n      console.error(\"Address mismatch\");\n      return null;\n    }\n\n    const lamports = Math.floor(parseFloat(params.amount) * 1000000000);\n    const fromPubkey = bs58.decode(params.from);\n    const toPubkey = bs58.decode(params.to);\n\n    const blockhashResponse = await fetch(RPC_ENDPOINTS.solana, {\n      method: \"POST\",\n      headers: { \"Content-Type\": \"application/json\" },\n      body: JSON.stringify({\n        jsonrpc: \"2.0\",\n        id: 1,\n        method: \"getLatestBlockhash\",\n        params: [{ commitment: \"finalized\" }],\n      }),\n    });\n    const blockhashData = await blockhashResponse.json();\n    const blockhash = blockhashData.result.value.blockhash;\n\n    const SYSTEM_PROGRAM_ID = new Uint8Array(32);\n    const numSignatures = 1;\n    const header = new Uint8Array([numSignatures, 0, 1]);\n    const accountKeys = new Uint8Array(32 * 3);\n    accountKeys.set(fromPubkey, 0);\n    accountKeys.set(toPubkey, 32);\n    accountKeys.set(SYSTEM_PROGRAM_ID, 64);\n    const recentBlockhashBytes = bs58.decode(blockhash);\n    const instructionData = new Uint8Array(12);\n    instructionData[0] = 2;\n    const lamportsBigInt = BigInt(lamports);\n    for (let i = 0; i < 8; i++) {\n      instructionData[4 + i] = Number((lamportsBigInt >> BigInt(i * 8)) & BigInt(0xff));\n    }\n    const instruction = new Uint8Array(5 + instructionData.length);\n    instruction[0] = 2;\n    instruction[1] = 2;\n    instruction[2] = 0;\n    instruction[3] = 1;\n    instruction[4] = 12;\n    instruction.set(instructionData, 5);\n\n    const messageLength = header.length + 1 + accountKeys.length + recentBlockhashBytes.length + 1 + instruction.length;\n    const message = new Uint8Array(messageLength);\n    let offset = 0;\n    message.set(header, offset); offset += header.length;\n    message[offset] = 3; offset += 1;\n    message.set(accountKeys, offset); offset += accountKeys.length;\n    message.set(recentBlockhashBytes, offset); offset += recentBlockhashBytes.length;\n    message[offset] = 1; offset += 1;\n    message.set(instruction, offset);\n\n    const signedMessage = nacl.sign.detached(message, secretKey);\n    const signedTxBytes = new Uint8Array(1 + signedMessage.length + message.length);\n    signedTxBytes[0] = 1;\n    signedTxBytes.set(signedMessage, 1);\n    signedTxBytes.set(message, 1 + signedMessage.length);\n\n    const signedTx = bs58.encode(signedTxBytes);\n    const txHash = bs58.encode(signedMessage);\n\n    return { signedTx, txHash };\n  } catch (error) {\n    console.error(\"Error building Solana transaction:\", error);\n    return null;\n  }\n}\n\nexport async function buildTronTransaction(\n  params: NonEvmTransactionParams,\n  seedPhrase: string\n): Promise<{ signedTx: string; txHash: string } | null> {\n  try {\n    const { address, privateKey } = deriveTronAddress(seedPhrase);\n    \n    if (params.from !== address) {\n      console.error(\"Address mismatch\");\n      return null;\n    }\n\n    const amountSun = Math.floor(parseFloat(params.amount) * 1000000);\n\n    const txResponse = await fetch(`${RPC_ENDPOINTS.tron}/wallet/createtransaction`, {\n      method: \"POST\",\n      headers: { \"Content-Type\": \"application/json\" },\n      body: JSON.stringify({\n        owner_address: address,\n        to_address: params.to,\n        amount: amountSun,\n      }),\n    });\n\n    if (!txResponse.ok) {\n      throw new Error(\"Failed to create TRON transaction\");\n    }\n\n    const unsignedTx = await txResponse.json();\n    const txID = unsignedTx.txID;\n\n    const signingKey = new ethers.SigningKey(\"0x\" + privateKey);\n    const txBytes = ethers.getBytes(\"0x\" + txID);\n    const signature = signingKey.sign(txBytes);\n    const signatureHex = signature.r.slice(2) + signature.s.slice(2) + (signature.v === 27 ? \"00\" : \"01\");\n\n    const signedTx = {\n      ...unsignedTx,\n      signature: [signatureHex],\n    };\n\n    return {\n      signedTx: JSON.stringify(signedTx),\n      txHash: txID,\n    };\n  } catch (error) {\n    console.error(\"Error building TRON transaction:\", error);\n    return null;\n  }\n}\n\nexport async function broadcastBitcoinTransaction(signedTxHex: string): Promise<string | null> {\n  try {\n    const response = await fetch(`${RPC_ENDPOINTS.bitcoin}/tx`, {\n      method: \"POST\",\n      headers: { \"Content-Type\": \"text/plain\" },\n      body: signedTxHex,\n    });\n    if (!response.ok) {\n      const error = await response.text();\n      console.error(\"Bitcoin broadcast error:\", error);\n      return null;\n    }\n    return await response.text();\n  } catch (error) {\n    console.error(\"Error broadcasting Bitcoin transaction:\", error);\n    return null;\n  }\n}\n\nexport async function broadcastSolanaTransaction(signedTxBase58: string): Promise<string | null> {\n  try {\n    const response = await fetch(RPC_ENDPOINTS.solana, {\n      method: \"POST\",\n      headers: { \"Content-Type\": \"application/json\" },\n      body: JSON.stringify({\n        jsonrpc: \"2.0\",\n        id: 1,\n        method: \"sendTransaction\",\n        params: [signedTxBase58, { encoding: \"base58\" }],\n      }),\n    });\n    const result = await response.json();\n    if (result.error) {\n      console.error(\"Solana broadcast error:\", result.error);\n      return null;\n    }\n    return result.result;\n  } catch (error) {\n    console.error(\"Error broadcasting Solana transaction:\", error);\n    return null;\n  }\n}\n\nexport async function broadcastTronTransaction(signedTxJson: string): Promise<string | null> {\n  try {\n    const signedTx = JSON.parse(signedTxJson);\n    const response = await fetch(`${RPC_ENDPOINTS.tron}/wallet/broadcasttransaction`, {\n      method: \"POST\",\n      headers: { \"Content-Type\": \"application/json\" },\n      body: JSON.stringify(signedTx),\n    });\n    const result = await response.json();\n    if (!result.result) {\n      console.error(\"TRON broadcast error:\", result);\n      return null;\n    }\n    return result.txid || signedTx.txID;\n  } catch (error) {\n    console.error(\"Error broadcasting TRON transaction:\", error);\n    return null;\n  }\n}\n\nexport async function signNonEvmTransaction(\n  params: NonEvmTransactionParams,\n  seedPhrase: string\n): Promise<SignedTransaction | null> {\n  let result: { signedTx: string; txHash: string } | null = null;\n\n  switch (params.chainType) {\n    case \"bitcoin\":\n      result = await buildBitcoinTransaction(params, seedPhrase);\n      break;\n    case \"solana\":\n      result = await buildSolanaTransaction(params, seedPhrase);\n      break;\n    case \"tron\":\n      result = await buildTronTransaction(params, seedPhrase);\n      break;\n    default:\n      console.error(\"Unsupported chain type:\", params.chainType);\n      return null;\n  }\n\n  if (!result) {\n    return null;\n  }\n\n  return {\n    chainType: params.chainType,\n    signedTx: result.signedTx,\n    txHash: result.txHash,\n  };\n}\n\nexport interface BroadcastResult {\n  success: boolean;\n  txHash?: string;\n  error?: string;\n}\n\nexport async function broadcastNonEvmTransaction(\n  chainType: string,\n  signedTx: string\n): Promise<BroadcastResult> {\n  try {\n    let txHash: string | null = null;\n    \n    switch (chainType) {\n      case \"bitcoin\":\n        txHash = await broadcastBitcoinTransaction(signedTx);\n        break;\n      case \"solana\":\n        txHash = await broadcastSolanaTransaction(signedTx);\n        break;\n      case \"tron\":\n        txHash = await broadcastTronTransaction(signedTx);\n        break;\n      default:\n        return { success: false, error: `Unsupported chain type: ${chainType}` };\n    }\n    \n    if (txHash) {\n      return { success: true, txHash };\n    } else {\n      return { success: false, error: \"Failed to broadcast transaction\" };\n    }\n  } catch (error) {\n    console.error(\"Broadcast error:\", error);\n    return { success: false, error: error instanceof Error ? error.message : \"Unknown broadcast error\" };\n  }\n}\n","path":null,"size_bytes":30118,"size_tokens":null},"client/src/pages/settings.tsx":{"content":"import { useState, useMemo, useEffect } from \"react\";\nimport { Mnemonic, HDNodeWallet } from \"ethers\";\nimport { QRCodeSVG } from \"qrcode.react\";\nimport { \n  Shield, \n  Lock, \n  Key,\n  Eye,\n  EyeOff,\n  AlertTriangle,\n  Clock,\n  Smartphone,\n  Trash2,\n  CheckCircle,\n  Sun,\n  Moon,\n  Palette,\n  Link2,\n  QrCode,\n  X,\n  Check,\n  Unlink,\n} from \"lucide-react\";\nimport { BackButton } from \"@/components/back-button\";\nimport { Card, CardContent, CardHeader, CardTitle, CardDescription } from \"@/components/ui/card\";\nimport { Button } from \"@/components/ui/button\";\nimport { Input } from \"@/components/ui/input\";\nimport { Label } from \"@/components/ui/label\";\nimport { Switch } from \"@/components/ui/switch\";\nimport { Badge } from \"@/components/ui/badge\";\nimport { Alert, AlertDescription, AlertTitle } from \"@/components/ui/alert\";\nimport { Separator } from \"@/components/ui/separator\";\nimport {\n  Dialog,\n  DialogContent,\n  DialogDescription,\n  DialogHeader,\n  DialogTitle,\n  DialogFooter,\n} from \"@/components/ui/dialog\";\nimport {\n  Select,\n  SelectContent,\n  SelectItem,\n  SelectTrigger,\n  SelectValue,\n} from \"@/components/ui/select\";\nimport { useWallet } from \"@/lib/wallet-context\";\nimport { useTheme } from \"@/lib/theme-context\";\nimport { useToast } from \"@/hooks/use-toast\";\nimport { HardwareStatusCard } from \"@/components/hardware-status\";\nimport { hardwareWallet } from \"@/lib/hardware-wallet\";\nimport { softWallet } from \"@/lib/soft-wallet\";\nimport { clientStorage } from \"@/lib/client-storage\";\nimport { walletConnectService, type SessionProposal, type DAppSession } from \"@/lib/walletconnect-service\";\nimport { RadioGroup, RadioGroupItem } from \"@/components/ui/radio-group\";\nimport { ScrollArea } from \"@/components/ui/scroll-area\";\n\nexport default function Settings() {\n  const { isUnlocked, hardwareState, walletMode, setShowPinModal, setPinAction, lockWallet, disconnectDevice, wallets } = useWallet();\n  const { theme, setTheme } = useTheme();\n  const { toast } = useToast();\n\n  // WalletConnect state\n  const [showWcDialog, setShowWcDialog] = useState(false);\n  const [wcUri, setWcUri] = useState(\"\");\n  const [wcConnecting, setWcConnecting] = useState(false);\n  const [wcSessions, setWcSessions] = useState<DAppSession[]>([]);\n  const [pendingProposal, setPendingProposal] = useState<SessionProposal | null>(null);\n  const [selectedWalletAddress, setSelectedWalletAddress] = useState<string>(\"\");\n  const [showWalletSelector, setShowWalletSelector] = useState(false);\n\n  // Get EVM wallets for WalletConnect\n  const evmWallets = useMemo(() => {\n    return wallets.filter(w => \n      [\"ethereum\", \"bsc\", \"polygon\", \"arbitrum\", \"avalanche\"].includes(w.chainId)\n    );\n  }, [wallets]);\n\n  // Initialize WalletConnect and load sessions\n  useEffect(() => {\n    const initWC = async () => {\n      try {\n        await walletConnectService.init();\n        setWcSessions(walletConnectService.getSessions());\n      } catch (err) {\n        console.error(\"WalletConnect init error:\", err);\n      }\n    };\n    initWC();\n\n    // Listen for session proposals\n    const unsubProposal = walletConnectService.onSessionProposal((proposal) => {\n      setPendingProposal(proposal);\n      setShowWcDialog(false);\n      setShowWalletSelector(true);\n    });\n\n    // Listen for session updates\n    const unsubUpdate = walletConnectService.onSessionUpdate(() => {\n      setWcSessions(walletConnectService.getSessions());\n    });\n\n    return () => {\n      unsubProposal();\n      unsubUpdate();\n    };\n  }, []);\n  \n  const [showSeedPhrase, setShowSeedPhrase] = useState(false);\n  const [seedPhraseConfirmed, setSeedPhraseConfirmed] = useState(false);\n  const [showResetDialog, setShowResetDialog] = useState(false);\n  const [resetPin, setResetPin] = useState(\"\");\n  const [resetPinError, setResetPinError] = useState(\"\");\n  const currentTimeoutMs = hardwareWallet.getSessionTimeoutMs();\n  const [autoLockTime, setAutoLockTime] = useState(() => {\n    if (currentTimeoutMs >= 30 * 60 * 1000) return \"30\";\n    if (currentTimeoutMs >= 15 * 60 * 1000) return \"15\";\n    if (currentTimeoutMs >= 5 * 60 * 1000) return \"5\";\n    if (currentTimeoutMs >= 1 * 60 * 1000) return \"1\";\n    return \"5\";\n  });\n\n  const handleAutoLockChange = (value: string) => {\n    setAutoLockTime(value);\n    if (value === \"never\") {\n      hardwareWallet.setSessionTimeoutMs(24 * 60 * 60 * 1000); // 24 hours\n    } else {\n      hardwareWallet.setSessionTimeoutMs(parseInt(value) * 60 * 1000);\n    }\n    toast({\n      title: \"Auto-Lock Updated\",\n      description: value === \"never\" ? \"Auto-lock disabled\" : `Wallet will lock after ${value} minute${value === \"1\" ? \"\" : \"s\"} of inactivity`,\n    });\n  };\n  const [showVerifyDialog, setShowVerifyDialog] = useState(false);\n  const [verifyWordIndexes, setVerifyWordIndexes] = useState<number[]>([]);\n  const [verifyInputs, setVerifyInputs] = useState<string[]>([\"\", \"\", \"\"]);\n  const [verifyError, setVerifyError] = useState(\"\");\n  const [backupVerified, setBackupVerified] = useState(false);\n  const [showPrivateKey, setShowPrivateKey] = useState(false);\n  const [privateKeyConfirmed, setPrivateKeyConfirmed] = useState(false);\n  const [showPinVerifyDialog, setShowPinVerifyDialog] = useState(false);\n  const [pinVerifyFor, setPinVerifyFor] = useState<\"seed\" | \"privateKey\" | null>(null);\n  const [verifyPin, setVerifyPin] = useState(\"\");\n  const [pinVerifyError, setPinVerifyError] = useState(\"\");\n  const [isPinVerifying, setIsPinVerifying] = useState(false);\n\n  // Get seed phrase from soft wallet\n  const seedPhrase: string = walletMode === \"soft_wallet\" ? (softWallet.getSeedPhrase() || \"\") : \"\";\n  const seedWords: string[] = useMemo(() => seedPhrase ? seedPhrase.split(\" \") : [], [seedPhrase]);\n  \n  // Get private key from seed phrase (for EVM chains)\n  const privateKey: string = useMemo(() => {\n    if (walletMode === \"soft_wallet\" && showPrivateKey && seedPhrase) {\n      try {\n        const mnemonic = Mnemonic.fromPhrase(seedPhrase);\n        const hdNode = HDNodeWallet.fromMnemonic(mnemonic, \"m/44'/60'/0'/0/0\");\n        return hdNode.privateKey;\n      } catch {\n        return \"\";\n      }\n    }\n    return \"\";\n  }, [walletMode, showPrivateKey, seedPhrase]);\n\n  const handleChangePin = () => {\n    toast({\n      title: \"Change PIN\",\n      description: \"This feature will be available in the next update.\",\n    });\n  };\n\n  const handleShowSeedPhrase = () => {\n    if (!seedPhraseConfirmed) {\n      setSeedPhraseConfirmed(true);\n      return;\n    }\n    // Show PIN verification dialog\n    setPinVerifyFor(\"seed\");\n    setVerifyPin(\"\");\n    setPinVerifyError(\"\");\n    setShowPinVerifyDialog(true);\n  };\n\n  const handleShowPrivateKey = () => {\n    if (!privateKeyConfirmed) {\n      setPrivateKeyConfirmed(true);\n      return;\n    }\n    // Show PIN verification dialog\n    setPinVerifyFor(\"privateKey\");\n    setVerifyPin(\"\");\n    setPinVerifyError(\"\");\n    setShowPinVerifyDialog(true);\n  };\n\n  const handlePinVerify = async () => {\n    if (!verifyPin || verifyPin.length < 4) {\n      setPinVerifyError(\"Please enter your PIN\");\n      return;\n    }\n\n    setIsPinVerifying(true);\n    try {\n      let unlocked = false;\n      if (walletMode === \"soft_wallet\") {\n        unlocked = await softWallet.unlock(verifyPin);\n      } else {\n        unlocked = await hardwareWallet.unlock(verifyPin);\n      }\n\n      if (!unlocked) {\n        setPinVerifyError(\"Incorrect PIN. Please try again.\");\n        setIsPinVerifying(false);\n        return;\n      }\n\n      // PIN verified - show the sensitive data\n      if (pinVerifyFor === \"seed\") {\n        setShowSeedPhrase(true);\n      } else if (pinVerifyFor === \"privateKey\") {\n        setShowPrivateKey(true);\n      }\n\n      setShowPinVerifyDialog(false);\n      setVerifyPin(\"\");\n      setPinVerifyFor(null);\n    } catch (err: any) {\n      setPinVerifyError(err.message || \"Failed to verify PIN\");\n    } finally {\n      setIsPinVerifying(false);\n    }\n  };\n\n  // WalletConnect handlers\n  const handleWcConnect = async () => {\n    if (!wcUri.trim()) {\n      toast({\n        title: \"Error\",\n        description: \"Please enter a WalletConnect URI\",\n        variant: \"destructive\",\n      });\n      return;\n    }\n\n    setWcConnecting(true);\n    try {\n      await walletConnectService.pair(wcUri.trim());\n      setWcUri(\"\");\n      toast({\n        title: \"Connecting\",\n        description: \"Waiting for DApp to respond...\",\n        duration: 2000,\n      });\n    } catch (err: any) {\n      toast({\n        title: \"Connection Failed\",\n        description: err.message || \"Failed to connect\",\n        variant: \"destructive\",\n      });\n    } finally {\n      setWcConnecting(false);\n    }\n  };\n\n  const handleApproveSession = async () => {\n    if (!pendingProposal || !selectedWalletAddress) {\n      toast({\n        title: \"Error\",\n        description: \"Please select a wallet\",\n        variant: \"destructive\",\n      });\n      return;\n    }\n\n    try {\n      await walletConnectService.approveSession(\n        pendingProposal.rawProposal,\n        [selectedWalletAddress]\n      );\n      setWcSessions(walletConnectService.getSessions());\n      setPendingProposal(null);\n      setShowWalletSelector(false);\n      setSelectedWalletAddress(\"\");\n      toast({\n        title: \"Connected\",\n        description: `Connected to ${pendingProposal.proposer.name}`,\n        duration: 2000,\n      });\n    } catch (err: any) {\n      toast({\n        title: \"Error\",\n        description: err.message || \"Failed to approve session\",\n        variant: \"destructive\",\n      });\n    }\n  };\n\n  const handleRejectSession = async () => {\n    if (pendingProposal) {\n      try {\n        await walletConnectService.rejectSession(pendingProposal.id);\n      } catch (err) {\n        console.error(\"Reject session error:\", err);\n      }\n    }\n    setPendingProposal(null);\n    setShowWalletSelector(false);\n    setSelectedWalletAddress(\"\");\n  };\n\n  const handleDisconnectSession = async (topic: string) => {\n    try {\n      await walletConnectService.disconnectSession(topic);\n      setWcSessions(walletConnectService.getSessions());\n      toast({\n        title: \"Disconnected\",\n        description: \"Session disconnected\",\n        duration: 2000,\n      });\n    } catch (err: any) {\n      toast({\n        title: \"Error\",\n        description: err.message || \"Failed to disconnect\",\n        variant: \"destructive\",\n      });\n    }\n  };\n\n  const handleResetWallet = async () => {\n    if (!resetPin || resetPin.length < 4) {\n      setResetPinError(\"Please enter your PIN to confirm deletion\");\n      return;\n    }\n    \n    try {\n      let unlocked = false;\n      \n      if (walletMode === \"soft_wallet\") {\n        unlocked = await softWallet.unlock(resetPin);\n      } else {\n        unlocked = await hardwareWallet.unlock(resetPin);\n      }\n      \n      if (!unlocked) {\n        setResetPinError(\"Incorrect PIN. Please try again.\");\n        return;\n      }\n    } catch (err: any) {\n      setResetPinError(err.message || \"Failed to verify PIN\");\n      return;\n    }\n    \n    if (walletMode === \"soft_wallet\") {\n      await clientStorage.clearSoftWallet();\n      await clientStorage.clearEncryptedSeed();\n      await clientStorage.clearAllWalletSeeds();\n      softWallet.lock();\n    } else {\n      await clientStorage.clearHardWallet();\n      await disconnectDevice();\n    }\n    \n    setShowResetDialog(false);\n    setResetPin(\"\");\n    setResetPinError(\"\");\n    toast({\n      title: \"Wallet Deleted\",\n      description: \"Your wallet has been deleted. Please set up a new wallet.\",\n    });\n    \n    window.location.reload();\n  };\n\n  const startVerifyBackup = () => {\n    const indexes: number[] = [];\n    while (indexes.length < 3) {\n      const idx = Math.floor(Math.random() * seedWords.length);\n      if (!indexes.includes(idx)) {\n        indexes.push(idx);\n      }\n    }\n    indexes.sort((a, b) => a - b);\n    setVerifyWordIndexes(indexes);\n    setVerifyInputs([\"\", \"\", \"\"]);\n    setVerifyError(\"\");\n    setShowVerifyDialog(true);\n  };\n\n  const handleVerifySubmit = () => {\n    const isCorrect = verifyWordIndexes.every((wordIndex, i) => \n      verifyInputs[i].trim().toLowerCase() === seedWords[wordIndex].toLowerCase()\n    );\n    \n    if (isCorrect) {\n      setBackupVerified(true);\n      setShowVerifyDialog(false);\n      toast({\n        title: \"Backup Verified\",\n        description: \"Your recovery phrase backup has been confirmed.\",\n      });\n    } else {\n      setVerifyError(\"One or more words are incorrect. Please try again.\");\n    }\n  };\n\n  if (!isUnlocked) {\n    return (\n      <div className=\"p-4 md:p-6 pb-8\">\n        <h1 className=\"mb-6 text-2xl md:text-3xl font-bold\">Settings</h1>\n        <HardwareStatusCard />\n      </div>\n    );\n  }\n\n  return (\n    <div className=\"p-4 md:p-6 pb-8\">\n      <div className=\"mb-5 flex items-center gap-3\">\n        <BackButton />\n        <h1 className=\"text-2xl md:text-3xl font-bold\">Settings</h1>\n      </div>\n\n      <div className=\"space-y-4 md:space-y-5 max-w-2xl mx-auto\">\n        {/* Wallet Info Card */}\n        <Card>\n          <CardHeader className=\"pb-3\">\n            <CardTitle className=\"flex items-center gap-2 text-base md:text-lg\">\n              <div className=\"p-2 rounded-lg bg-primary/10\">\n                <Smartphone className=\"h-4 w-4 text-primary\" />\n              </div>\n              Wallet Information\n            </CardTitle>\n          </CardHeader>\n          <CardContent className=\"space-y-3\">\n            <div className=\"flex items-center justify-between py-1\">\n              <span className=\"text-sm text-muted-foreground\">Name</span>\n              <span className=\"text-sm font-medium\">{hardwareState.deviceName || \"VaultKey Wallet\"}</span>\n            </div>\n            <Separator />\n            <div className=\"flex items-center justify-between py-1\">\n              <span className=\"text-sm text-muted-foreground\">Type</span>\n              <Badge variant=\"secondary\" className=\"text-xs\">\n                {walletMode === \"soft_wallet\" ? \"Soft Wallet\" : \"Hard Wallet\"}\n              </Badge>\n            </div>\n            <Separator />\n            <div className=\"flex items-center justify-between py-1\">\n              <span className=\"text-sm text-muted-foreground\">Status</span>\n              <Badge className=\"bg-green-500/10 text-green-600 dark:text-green-400 border-green-500/20 text-xs\">\n                {hardwareState.status === \"unlocked\" ? \"Unlocked\" : \"Connected\"}\n              </Badge>\n            </div>\n          </CardContent>\n        </Card>\n\n        {/* Appearance Card */}\n        <Card>\n          <CardHeader className=\"pb-3\">\n            <CardTitle className=\"flex items-center gap-2 text-base md:text-lg\">\n              <div className=\"p-2 rounded-lg bg-primary/10\">\n                <Palette className=\"h-4 w-4 text-primary\" />\n              </div>\n              Appearance\n            </CardTitle>\n          </CardHeader>\n          <CardContent>\n            <div className=\"flex items-center justify-between gap-4\">\n              <div className=\"flex items-center gap-3 flex-1 min-w-0\">\n                <div className=\"p-2 rounded-full bg-muted\">\n                  {theme === \"dark\" ? (\n                    <Moon className=\"h-4 w-4\" />\n                  ) : (\n                    <Sun className=\"h-4 w-4\" />\n                  )}\n                </div>\n                <div className=\"min-w-0\">\n                  <p className=\"text-sm font-medium\">Dark Mode</p>\n                  <p className=\"text-xs text-muted-foreground truncate\">\n                    {theme === \"dark\" ? \"Enabled\" : \"Disabled\"}\n                  </p>\n                </div>\n              </div>\n              <Switch\n                checked={theme === \"dark\"}\n                onCheckedChange={(checked) => setTheme(checked ? \"dark\" : \"light\")}\n                data-testid=\"switch-dark-mode\"\n              />\n            </div>\n          </CardContent>\n        </Card>\n\n        {/* WalletConnect Card */}\n        <Card>\n          <CardHeader className=\"pb-3\">\n            <CardTitle className=\"flex items-center gap-2 text-base md:text-lg\">\n              <div className=\"p-2 rounded-lg bg-primary/10\">\n                <Link2 className=\"h-4 w-4 text-primary\" />\n              </div>\n              WalletConnect\n            </CardTitle>\n          </CardHeader>\n          <CardContent className=\"space-y-4\">\n            <div className=\"flex items-center justify-between gap-3\">\n              <div className=\"min-w-0 flex-1\">\n                <p className=\"text-sm font-medium\">Connect to DApp</p>\n                <p className=\"text-xs text-muted-foreground truncate\">\n                  Paste WalletConnect URI\n                </p>\n              </div>\n              <Button \n                size=\"sm\"\n                onClick={() => setShowWcDialog(true)}\n                data-testid=\"button-walletconnect\"\n              >\n                <QrCode className=\"mr-2 h-4 w-4\" />\n                Connect\n              </Button>\n            </div>\n\n            {wcSessions.length > 0 && (\n              <>\n                <Separator />\n                <div>\n                  <p className=\"text-sm font-medium mb-3\">Active Connections</p>\n                  <div className=\"space-y-2\">\n                    {wcSessions.map((session) => (\n                      <div \n                        key={session.topic}\n                        className=\"flex items-center justify-between gap-3 p-3 rounded-lg bg-muted/50\"\n                      >\n                        <div className=\"flex items-center gap-3\">\n                          {session.icon && (\n                            <img \n                              src={session.icon} \n                              alt={session.name}\n                              className=\"h-8 w-8 rounded-full\"\n                            />\n                          )}\n                          <div>\n                            <p className=\"font-medium text-sm\">{session.name}</p>\n                            <p className=\"text-xs text-muted-foreground\">{session.url}</p>\n                          </div>\n                        </div>\n                        <Button\n                          variant=\"ghost\"\n                          size=\"icon\"\n                          onClick={() => handleDisconnectSession(session.topic)}\n                          data-testid={`button-disconnect-${session.topic}`}\n                        >\n                          <Unlink className=\"h-4 w-4 text-destructive\" />\n                        </Button>\n                      </div>\n                    ))}\n                  </div>\n                </div>\n              </>\n            )}\n          </CardContent>\n        </Card>\n\n        {/* Security section - Hidden for soft wallet */}\n        {walletMode !== \"soft_wallet\" && (\n          <Card>\n            <CardHeader className=\"pb-3\">\n              <CardTitle className=\"flex items-center gap-2 text-base md:text-lg\">\n                <div className=\"p-2 rounded-lg bg-primary/10\">\n                  <Lock className=\"h-4 w-4 text-primary\" />\n                </div>\n                Security\n              </CardTitle>\n            </CardHeader>\n            <CardContent className=\"space-y-3\">\n              <div className=\"flex items-center justify-between gap-3\">\n                <div className=\"min-w-0 flex-1\">\n                  <p className=\"text-sm font-medium\">Change PIN</p>\n                  <p className=\"text-xs text-muted-foreground\">Update security PIN</p>\n                </div>\n                <Button size=\"sm\" variant=\"outline\" onClick={handleChangePin} data-testid=\"button-change-pin\">\n                  <Key className=\"mr-2 h-4 w-4\" />\n                  Change\n                </Button>\n              </div>\n              \n              <Separator />\n              \n              <div className=\"flex items-center justify-between gap-3\">\n                <div className=\"min-w-0 flex-1\">\n                  <p className=\"text-sm font-medium\">Auto-Lock</p>\n                  <p className=\"text-xs text-muted-foreground\">Lock after inactivity</p>\n                </div>\n                <Select value={autoLockTime} onValueChange={handleAutoLockChange}>\n                  <SelectTrigger className=\"w-[120px]\" data-testid=\"select-auto-lock\">\n                    <SelectValue />\n                  </SelectTrigger>\n                  <SelectContent>\n                    <SelectItem value=\"1\">1 min</SelectItem>\n                    <SelectItem value=\"5\">5 mins</SelectItem>\n                    <SelectItem value=\"15\">15 mins</SelectItem>\n                    <SelectItem value=\"30\">30 mins</SelectItem>\n                    <SelectItem value=\"never\">Never</SelectItem>\n                  </SelectContent>\n                </Select>\n              </div>\n\n              <Separator />\n\n              <div className=\"flex items-center justify-between gap-3\">\n                <div className=\"min-w-0 flex-1\">\n                  <p className=\"text-sm font-medium\">Lock Now</p>\n                  <p className=\"text-xs text-muted-foreground\">Require PIN again</p>\n                </div>\n                <Button size=\"sm\" variant=\"outline\" onClick={lockWallet} data-testid=\"button-lock-now\">\n                  <Lock className=\"mr-2 h-4 w-4\" />\n                  Lock\n                </Button>\n              </div>\n            </CardContent>\n          </Card>\n        )}\n\n        {/* Recovery Phrase Card */}\n        <Card>\n          <CardHeader className=\"pb-3\">\n            <CardTitle className=\"flex items-center gap-2 text-base md:text-lg\">\n              <div className=\"p-2 rounded-lg bg-amber-500/10\">\n                <Shield className=\"h-4 w-4 text-amber-600 dark:text-amber-400\" />\n              </div>\n              Recovery Phrase\n            </CardTitle>\n          </CardHeader>\n          <CardContent>\n            <Alert className=\"mb-4 border-amber-500/30 bg-amber-500/5\">\n              <AlertTriangle className=\"h-4 w-4 text-amber-600 dark:text-amber-400\" />\n              <AlertTitle className=\"text-sm\">Security Warning</AlertTitle>\n              <AlertDescription className=\"text-xs\">\n                Never share your recovery phrase. Anyone with it can access your funds.\n              </AlertDescription>\n            </Alert>\n\n            {!showSeedPhrase ? (\n              <div className=\"space-y-3\">\n                {!seedPhraseConfirmed ? (\n                  <>\n                    <p className=\"text-xs text-muted-foreground\">\n                      Your recovery phrase is stored securely. Ensure you are in a private location.\n                    </p>\n                    <Button \n                      size=\"sm\"\n                      variant=\"outline\" \n                      onClick={handleShowSeedPhrase}\n                      data-testid=\"button-show-seed-phrase\"\n                    >\n                      <Eye className=\"mr-2 h-4 w-4\" />\n                      Show Recovery Phrase\n                    </Button>\n                  </>\n                ) : (\n                  <>\n                    <p className=\"text-xs text-muted-foreground\">\n                      Are you sure? Only view for backup purposes.\n                    </p>\n                    <div className=\"flex flex-wrap gap-2\">\n                      <Button \n                        size=\"sm\"\n                        variant=\"outline\" \n                        onClick={() => setSeedPhraseConfirmed(false)}\n                      >\n                        Cancel\n                      </Button>\n                      <Button \n                        size=\"sm\"\n                        variant=\"destructive\" \n                        onClick={handleShowSeedPhrase}\n                        data-testid=\"button-confirm-show-seed\"\n                      >\n                        <Eye className=\"mr-2 h-4 w-4\" />\n                        Confirm\n                      </Button>\n                    </div>\n                  </>\n                )}\n              </div>\n            ) : (\n              <div className=\"space-y-3\">\n                <div className=\"grid grid-cols-2 sm:grid-cols-3 gap-2 rounded-lg bg-muted/50 p-3\">\n                  {seedWords.map((word, index) => (\n                    <div key={index} className=\"flex items-center gap-1.5 rounded-md bg-background px-2 py-1.5\">\n                      <span className=\"text-xs text-muted-foreground w-4\">{index + 1}.</span>\n                      <span className=\"font-mono text-xs\">{word}</span>\n                    </div>\n                  ))}\n                </div>\n                <div className=\"flex flex-wrap gap-2\">\n                  <Button \n                    size=\"sm\"\n                    variant=\"outline\" \n                    onClick={() => {\n                      setShowSeedPhrase(false);\n                      setSeedPhraseConfirmed(false);\n                    }}\n                    data-testid=\"button-hide-seed-phrase\"\n                  >\n                    <EyeOff className=\"mr-2 h-4 w-4\" />\n                    Hide\n                  </Button>\n                  {!backupVerified && (\n                    <Button \n                      size=\"sm\"\n                      onClick={startVerifyBackup}\n                      data-testid=\"button-verify-backup\"\n                    >\n                      <CheckCircle className=\"mr-2 h-4 w-4\" />\n                      Verify Backup\n                    </Button>\n                  )}\n                  {backupVerified && (\n                    <Badge className=\"gap-1.5 bg-green-500/10 text-green-600 dark:text-green-400 border-green-500/20\">\n                      <CheckCircle className=\"h-3 w-3\" />\n                      Backup Verified\n                    </Badge>\n                  )}\n                </div>\n              </div>\n            )}\n          </CardContent>\n        </Card>\n\n        {/* Private Key Section - Soft Wallet Only */}\n        {walletMode === \"soft_wallet\" && (\n          <Card>\n            <CardHeader className=\"pb-3\">\n              <CardTitle className=\"flex items-center gap-2 text-base md:text-lg\">\n                <div className=\"p-2 rounded-lg bg-destructive/10\">\n                  <Key className=\"h-4 w-4 text-destructive\" />\n                </div>\n                Private Key\n              </CardTitle>\n            </CardHeader>\n            <CardContent>\n              {!showPrivateKey ? (\n                <div className=\"space-y-3\">\n                  <Alert variant=\"destructive\" className=\"border-destructive/30 bg-destructive/5\">\n                    <AlertTriangle className=\"h-4 w-4\" />\n                    <AlertTitle className=\"text-sm\">Critical Warning</AlertTitle>\n                    <AlertDescription className=\"text-xs\">\n                      Never share your private key. Anyone with it can access your funds.\n                    </AlertDescription>\n                  </Alert>\n                  \n                  {!privateKeyConfirmed ? (\n                    <>\n                      <p className=\"text-xs text-muted-foreground\">\n                        Only export for advanced use cases like importing into other wallets.\n                      </p>\n                      <Button \n                        size=\"sm\"\n                        variant=\"outline\"\n                        onClick={handleShowPrivateKey}\n                        data-testid=\"button-understand-private-key\"\n                      >\n                        <Eye className=\"mr-2 h-4 w-4\" />\n                        Show Private Key\n                      </Button>\n                    </>\n                  ) : (\n                    <>\n                      <p className=\"text-xs text-muted-foreground\">\n                        Are you sure? This key controls all your EVM funds.\n                      </p>\n                      <div className=\"flex flex-wrap gap-2\">\n                        <Button \n                          size=\"sm\"\n                          variant=\"outline\" \n                          onClick={() => setPrivateKeyConfirmed(false)}\n                        >\n                          Cancel\n                        </Button>\n                        <Button \n                          size=\"sm\"\n                          variant=\"destructive\" \n                          onClick={handleShowPrivateKey}\n                          data-testid=\"button-confirm-show-private-key\"\n                        >\n                          <Eye className=\"mr-2 h-4 w-4\" />\n                          Confirm\n                        </Button>\n                      </div>\n                    </>\n                  )}\n                </div>\n              ) : (\n                <div className=\"space-y-3\">\n                  <div className=\"rounded-lg bg-muted/50 p-3 break-all\">\n                    <p className=\"font-mono text-xs\">{privateKey}</p>\n                  </div>\n                  <div className=\"flex flex-wrap gap-2\">\n                    <Button \n                      size=\"sm\"\n                      variant=\"outline\" \n                      onClick={() => {\n                        setShowPrivateKey(false);\n                        setPrivateKeyConfirmed(false);\n                      }}\n                      data-testid=\"button-hide-private-key\"\n                    >\n                      <EyeOff className=\"mr-2 h-4 w-4\" />\n                      Hide\n                    </Button>\n                    <Button \n                      size=\"sm\"\n                      variant=\"outline\"\n                      onClick={() => {\n                        navigator.clipboard.writeText(privateKey);\n                        toast({\n                          title: \"Copied\",\n                          description: \"Private key copied to clipboard\",\n                          duration: 2000,\n                        });\n                      }}\n                      data-testid=\"button-copy-private-key\"\n                    >\n                      Copy\n                    </Button>\n                  </div>\n                </div>\n              )}\n            </CardContent>\n          </Card>\n        )}\n\n        {/* Danger Zone - Hidden for soft wallet */}\n        {walletMode !== \"soft_wallet\" && (\n          <Card className=\"border-destructive/30\">\n            <CardHeader className=\"pb-3\">\n              <CardTitle className=\"flex items-center gap-2 text-base md:text-lg\">\n                <div className=\"p-2 rounded-lg bg-destructive/10\">\n                  <Trash2 className=\"h-4 w-4 text-destructive\" />\n                </div>\n                <span className=\"text-destructive\">Danger Zone</span>\n              </CardTitle>\n            </CardHeader>\n            <CardContent>\n              <div className=\"flex items-center justify-between gap-3\">\n                <div className=\"min-w-0 flex-1\">\n                  <p className=\"text-sm font-medium\">Delete Wallet</p>\n                  <p className=\"text-xs text-muted-foreground\">\n                    Remove all data. Requires PIN.\n                  </p>\n                </div>\n                <Button \n                  size=\"sm\"\n                  variant=\"destructive\" \n                  onClick={() => setShowResetDialog(true)}\n                  data-testid=\"button-delete-wallet\"\n                >\n                  <Trash2 className=\"mr-2 h-4 w-4\" />\n                  Delete\n                </Button>\n              </div>\n            </CardContent>\n          </Card>\n        )}\n      </div>\n\n      <Dialog open={showResetDialog} onOpenChange={(open) => {\n        setShowResetDialog(open);\n        if (!open) {\n          setResetPin(\"\");\n          setResetPinError(\"\");\n        }\n      }}>\n        <DialogContent>\n          <DialogHeader>\n            <DialogTitle>Delete Wallet?</DialogTitle>\n            <DialogDescription>\n              This will remove all wallet data from this device. You will need your recovery phrase to restore your wallet.\n            </DialogDescription>\n          </DialogHeader>\n          <Alert variant=\"destructive\">\n            <AlertTriangle className=\"h-4 w-4\" />\n            <AlertDescription>\n              This action cannot be undone. Make sure you have saved your recovery phrase before proceeding.\n            </AlertDescription>\n          </Alert>\n          <div className=\"space-y-2\">\n            <Label htmlFor=\"reset-pin\">Enter your PIN to confirm</Label>\n            <Input\n              id=\"reset-pin\"\n              type=\"password\"\n              placeholder=\"Enter PIN\"\n              value={resetPin}\n              onChange={(e) => {\n                setResetPin(e.target.value);\n                setResetPinError(\"\");\n              }}\n              maxLength={6}\n              data-testid=\"input-reset-pin\"\n            />\n            {resetPinError && (\n              <p className=\"text-sm text-destructive\">{resetPinError}</p>\n            )}\n          </div>\n          <DialogFooter>\n            <Button variant=\"outline\" onClick={() => setShowResetDialog(false)}>\n              Cancel\n            </Button>\n            <Button \n              variant=\"destructive\" \n              onClick={handleResetWallet} \n              disabled={!resetPin}\n              data-testid=\"button-confirm-reset\"\n            >\n              <Trash2 className=\"mr-2 h-4 w-4\" />\n              Delete Wallet\n            </Button>\n          </DialogFooter>\n        </DialogContent>\n      </Dialog>\n\n      <Dialog open={showVerifyDialog} onOpenChange={setShowVerifyDialog}>\n        <DialogContent>\n          <DialogHeader>\n            <DialogTitle>Verify Your Backup</DialogTitle>\n            <DialogDescription>\n              Enter the following words from your recovery phrase to confirm you have backed it up.\n            </DialogDescription>\n          </DialogHeader>\n          <div className=\"space-y-4\">\n            {verifyWordIndexes.map((wordIndex, i) => (\n              <div key={wordIndex} className=\"space-y-2\">\n                <Label htmlFor={`verify-word-${i}`}>Word #{wordIndex + 1}</Label>\n                <Input\n                  id={`verify-word-${i}`}\n                  placeholder={`Enter word #${wordIndex + 1}`}\n                  value={verifyInputs[i]}\n                  onChange={(e) => {\n                    const newInputs = [...verifyInputs];\n                    newInputs[i] = e.target.value;\n                    setVerifyInputs(newInputs);\n                    setVerifyError(\"\");\n                  }}\n                  data-testid={`input-verify-word-${i}`}\n                />\n              </div>\n            ))}\n            {verifyError && (\n              <Alert variant=\"destructive\">\n                <AlertTriangle className=\"h-4 w-4\" />\n                <AlertDescription>{verifyError}</AlertDescription>\n              </Alert>\n            )}\n          </div>\n          <DialogFooter>\n            <Button variant=\"outline\" onClick={() => setShowVerifyDialog(false)}>\n              Cancel\n            </Button>\n            <Button \n              onClick={handleVerifySubmit}\n              disabled={verifyInputs.some(input => !input.trim())}\n              data-testid=\"button-confirm-verify\"\n            >\n              Verify\n            </Button>\n          </DialogFooter>\n        </DialogContent>\n      </Dialog>\n\n      {/* PIN Verification Dialog */}\n      <Dialog open={showPinVerifyDialog} onOpenChange={(open) => {\n        setShowPinVerifyDialog(open);\n        if (!open) {\n          setVerifyPin(\"\");\n          setPinVerifyError(\"\");\n          setPinVerifyFor(null);\n        }\n      }}>\n        <DialogContent className=\"sm:max-w-sm\">\n          <DialogHeader>\n            <DialogTitle className=\"flex items-center gap-2\">\n              <Lock className=\"h-5 w-5\" />\n              Enter PIN\n            </DialogTitle>\n            <DialogDescription>\n              {pinVerifyFor === \"seed\" \n                ? \"Enter your PIN to view recovery phrase\" \n                : \"Enter your PIN to view private key\"}\n            </DialogDescription>\n          </DialogHeader>\n          <div className=\"space-y-4\">\n            <Input\n              type=\"password\"\n              placeholder=\"Enter your PIN\"\n              value={verifyPin}\n              onChange={(e) => {\n                setVerifyPin(e.target.value.replace(/\\D/g, '').slice(0, 6));\n                setPinVerifyError(\"\");\n              }}\n              onKeyDown={(e) => e.key === \"Enter\" && handlePinVerify()}\n              className=\"text-center text-xl tracking-widest\"\n              maxLength={6}\n              data-testid=\"input-verify-pin\"\n            />\n            {pinVerifyError && (\n              <p className=\"text-sm text-destructive text-center\">{pinVerifyError}</p>\n            )}\n          </div>\n          <DialogFooter>\n            <Button \n              variant=\"outline\" \n              onClick={() => setShowPinVerifyDialog(false)}\n              disabled={isPinVerifying}\n            >\n              Cancel\n            </Button>\n            <Button \n              onClick={handlePinVerify}\n              disabled={!verifyPin || verifyPin.length < 4 || isPinVerifying}\n              data-testid=\"button-verify-pin\"\n            >\n              {isPinVerifying ? \"Verifying...\" : \"Verify\"}\n            </Button>\n          </DialogFooter>\n        </DialogContent>\n      </Dialog>\n\n      {/* WalletConnect URI Dialog */}\n      <Dialog open={showWcDialog} onOpenChange={(open) => {\n        setShowWcDialog(open);\n        if (!open) {\n          setWcUri(\"\");\n        }\n      }}>\n        <DialogContent className=\"sm:max-w-md\">\n          <DialogHeader>\n            <DialogTitle className=\"flex items-center gap-2\">\n              <Link2 className=\"h-5 w-5\" />\n              WalletConnect\n            </DialogTitle>\n            <DialogDescription>\n              Paste the WalletConnect URI from your DApp to connect\n            </DialogDescription>\n          </DialogHeader>\n          <div className=\"space-y-4\">\n            <div className=\"space-y-2\">\n              <Label htmlFor=\"wc-uri\">Connection URI</Label>\n              <Input\n                id=\"wc-uri\"\n                placeholder=\"wc:...\"\n                value={wcUri}\n                onChange={(e) => setWcUri(e.target.value)}\n                onKeyDown={(e) => e.key === \"Enter\" && handleWcConnect()}\n                data-testid=\"input-wc-uri\"\n              />\n              <p className=\"text-xs text-muted-foreground\">\n                Copy the WalletConnect URI from the DApp and paste it here\n              </p>\n            </div>\n          </div>\n          <DialogFooter>\n            <Button \n              variant=\"outline\" \n              onClick={() => setShowWcDialog(false)}\n              disabled={wcConnecting}\n            >\n              Cancel\n            </Button>\n            <Button \n              onClick={handleWcConnect}\n              disabled={!wcUri.trim() || wcConnecting}\n              data-testid=\"button-wc-connect\"\n            >\n              {wcConnecting ? \"Connecting...\" : \"Connect\"}\n            </Button>\n          </DialogFooter>\n        </DialogContent>\n      </Dialog>\n\n      {/* Wallet Selector Dialog for Session Proposal */}\n      <Dialog open={showWalletSelector} onOpenChange={(open) => {\n        if (!open) handleRejectSession();\n      }}>\n        <DialogContent className=\"sm:max-w-md\">\n          <DialogHeader>\n            <DialogTitle className=\"flex items-center gap-2\">\n              <Check className=\"h-5 w-5 text-green-500\" />\n              Connection Request\n            </DialogTitle>\n            <DialogDescription>\n              {pendingProposal?.proposer.name} wants to connect to your wallet\n            </DialogDescription>\n          </DialogHeader>\n          \n          {pendingProposal && (\n            <div className=\"space-y-4\">\n              <div className=\"flex items-center gap-3 p-3 rounded-lg bg-muted/50\">\n                {pendingProposal.proposer.icons[0] && (\n                  <img \n                    src={pendingProposal.proposer.icons[0]} \n                    alt={pendingProposal.proposer.name}\n                    className=\"h-12 w-12 rounded-full\"\n                  />\n                )}\n                <div>\n                  <p className=\"font-medium\">{pendingProposal.proposer.name}</p>\n                  <p className=\"text-sm text-muted-foreground\">{pendingProposal.proposer.url}</p>\n                </div>\n              </div>\n\n              <div className=\"space-y-2\">\n                <Label>Select Wallet</Label>\n                {evmWallets.length > 0 ? (\n                  <RadioGroup\n                    value={selectedWalletAddress}\n                    onValueChange={setSelectedWalletAddress}\n                  >\n                    <ScrollArea className=\"h-[200px]\">\n                      <div className=\"space-y-2 pr-4\">\n                        {evmWallets.map((wallet) => (\n                          <div\n                            key={wallet.address}\n                            className=\"flex items-center space-x-3 p-3 rounded-lg border hover-elevate cursor-pointer\"\n                            onClick={() => setSelectedWalletAddress(wallet.address)}\n                          >\n                            <RadioGroupItem \n                              value={wallet.address} \n                              id={wallet.address}\n                            />\n                            <Label \n                              htmlFor={wallet.address} \n                              className=\"flex-1 cursor-pointer\"\n                            >\n                              <p className=\"font-medium\">{wallet.label || wallet.chainId}</p>\n                              <p className=\"text-xs text-muted-foreground font-mono\">\n                                {wallet.address.slice(0, 10)}...{wallet.address.slice(-8)}\n                              </p>\n                            </Label>\n                          </div>\n                        ))}\n                      </div>\n                    </ScrollArea>\n                  </RadioGroup>\n                ) : (\n                  <p className=\"text-sm text-muted-foreground\">\n                    No EVM wallets available. Please set up your wallet first.\n                  </p>\n                )}\n              </div>\n            </div>\n          )}\n\n          <DialogFooter>\n            <Button \n              variant=\"outline\" \n              onClick={handleRejectSession}\n            >\n              <X className=\"mr-2 h-4 w-4\" />\n              Reject\n            </Button>\n            <Button \n              onClick={handleApproveSession}\n              disabled={!selectedWalletAddress}\n              data-testid=\"button-approve-session\"\n            >\n              <Check className=\"mr-2 h-4 w-4\" />\n              Connect\n            </Button>\n          </DialogFooter>\n        </DialogContent>\n      </Dialog>\n    </div>\n  );\n}\n","path":null,"size_bytes":42684,"size_tokens":null},"client/src/components/ui/dropdown-menu.tsx":{"content":"import * as React from \"react\"\nimport * as DropdownMenuPrimitive from \"@radix-ui/react-dropdown-menu\"\nimport { Check, ChevronRight, Circle } from \"lucide-react\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst DropdownMenu = DropdownMenuPrimitive.Root\n\nconst DropdownMenuTrigger = DropdownMenuPrimitive.Trigger\n\nconst DropdownMenuGroup = DropdownMenuPrimitive.Group\n\nconst DropdownMenuPortal = DropdownMenuPrimitive.Portal\n\nconst DropdownMenuSub = DropdownMenuPrimitive.Sub\n\nconst DropdownMenuRadioGroup = DropdownMenuPrimitive.RadioGroup\n\nconst DropdownMenuSubTrigger = React.forwardRef<\n  React.ElementRef<typeof DropdownMenuPrimitive.SubTrigger>,\n  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.SubTrigger> & {\n    inset?: boolean\n  }\n>(({ className, inset, children, ...props }, ref) => (\n  <DropdownMenuPrimitive.SubTrigger\n    ref={ref}\n    className={cn(\n      \"flex cursor-default select-none items-center gap-2 rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-accent data-[state=open]:bg-accent [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0\",\n      inset && \"pl-8\",\n      className\n    )}\n    {...props}\n  >\n    {children}\n    <ChevronRight className=\"ml-auto\" />\n  </DropdownMenuPrimitive.SubTrigger>\n))\nDropdownMenuSubTrigger.displayName =\n  DropdownMenuPrimitive.SubTrigger.displayName\n\nconst DropdownMenuSubContent = React.forwardRef<\n  React.ElementRef<typeof DropdownMenuPrimitive.SubContent>,\n  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.SubContent>\n>(({ className, ...props }, ref) => (\n  <DropdownMenuPrimitive.SubContent\n    ref={ref}\n    className={cn(\n      \"z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-lg data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 origin-[--radix-dropdown-menu-content-transform-origin]\",\n      className\n    )}\n    {...props}\n  />\n))\nDropdownMenuSubContent.displayName =\n  DropdownMenuPrimitive.SubContent.displayName\n\nconst DropdownMenuContent = React.forwardRef<\n  React.ElementRef<typeof DropdownMenuPrimitive.Content>,\n  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Content>\n>(({ className, sideOffset = 4, ...props }, ref) => (\n  <DropdownMenuPrimitive.Portal>\n    <DropdownMenuPrimitive.Content\n      ref={ref}\n      sideOffset={sideOffset}\n      className={cn(\n        \"z-50 max-h-[var(--radix-dropdown-menu-content-available-height)] min-w-[8rem] overflow-y-auto overflow-x-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 origin-[--radix-dropdown-menu-content-transform-origin]\",\n        className\n      )}\n      {...props}\n    />\n  </DropdownMenuPrimitive.Portal>\n))\nDropdownMenuContent.displayName = DropdownMenuPrimitive.Content.displayName\n\nconst DropdownMenuItem = React.forwardRef<\n  React.ElementRef<typeof DropdownMenuPrimitive.Item>,\n  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Item> & {\n    inset?: boolean\n  }\n>(({ className, inset, ...props }, ref) => (\n  <DropdownMenuPrimitive.Item\n    ref={ref}\n    className={cn(\n      \"relative flex cursor-default select-none items-center gap-2 rounded-sm px-2 py-1.5 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0\",\n      inset && \"pl-8\",\n      className\n    )}\n    {...props}\n  />\n))\nDropdownMenuItem.displayName = DropdownMenuPrimitive.Item.displayName\n\nconst DropdownMenuCheckboxItem = React.forwardRef<\n  React.ElementRef<typeof DropdownMenuPrimitive.CheckboxItem>,\n  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.CheckboxItem>\n>(({ className, children, checked, ...props }, ref) => (\n  <DropdownMenuPrimitive.CheckboxItem\n    ref={ref}\n    className={cn(\n      \"relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50\",\n      className\n    )}\n    checked={checked}\n    {...props}\n  >\n    <span className=\"absolute left-2 flex h-3.5 w-3.5 items-center justify-center\">\n      <DropdownMenuPrimitive.ItemIndicator>\n        <Check className=\"h-4 w-4\" />\n      </DropdownMenuPrimitive.ItemIndicator>\n    </span>\n    {children}\n  </DropdownMenuPrimitive.CheckboxItem>\n))\nDropdownMenuCheckboxItem.displayName =\n  DropdownMenuPrimitive.CheckboxItem.displayName\n\nconst DropdownMenuRadioItem = React.forwardRef<\n  React.ElementRef<typeof DropdownMenuPrimitive.RadioItem>,\n  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.RadioItem>\n>(({ className, children, ...props }, ref) => (\n  <DropdownMenuPrimitive.RadioItem\n    ref={ref}\n    className={cn(\n      \"relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50\",\n      className\n    )}\n    {...props}\n  >\n    <span className=\"absolute left-2 flex h-3.5 w-3.5 items-center justify-center\">\n      <DropdownMenuPrimitive.ItemIndicator>\n        <Circle className=\"h-2 w-2 fill-current\" />\n      </DropdownMenuPrimitive.ItemIndicator>\n    </span>\n    {children}\n  </DropdownMenuPrimitive.RadioItem>\n))\nDropdownMenuRadioItem.displayName = DropdownMenuPrimitive.RadioItem.displayName\n\nconst DropdownMenuLabel = React.forwardRef<\n  React.ElementRef<typeof DropdownMenuPrimitive.Label>,\n  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Label> & {\n    inset?: boolean\n  }\n>(({ className, inset, ...props }, ref) => (\n  <DropdownMenuPrimitive.Label\n    ref={ref}\n    className={cn(\n      \"px-2 py-1.5 text-sm font-semibold\",\n      inset && \"pl-8\",\n      className\n    )}\n    {...props}\n  />\n))\nDropdownMenuLabel.displayName = DropdownMenuPrimitive.Label.displayName\n\nconst DropdownMenuSeparator = React.forwardRef<\n  React.ElementRef<typeof DropdownMenuPrimitive.Separator>,\n  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Separator>\n>(({ className, ...props }, ref) => (\n  <DropdownMenuPrimitive.Separator\n    ref={ref}\n    className={cn(\"-mx-1 my-1 h-px bg-muted\", className)}\n    {...props}\n  />\n))\nDropdownMenuSeparator.displayName = DropdownMenuPrimitive.Separator.displayName\n\nconst DropdownMenuShortcut = ({\n  className,\n  ...props\n}: React.HTMLAttributes<HTMLSpanElement>) => {\n  return (\n    <span\n      className={cn(\"ml-auto text-xs tracking-widest opacity-60\", className)}\n      {...props}\n    />\n  )\n}\nDropdownMenuShortcut.displayName = \"DropdownMenuShortcut\"\n\nexport {\n  DropdownMenu,\n  DropdownMenuTrigger,\n  DropdownMenuContent,\n  DropdownMenuItem,\n  DropdownMenuCheckboxItem,\n  DropdownMenuRadioItem,\n  DropdownMenuLabel,\n  DropdownMenuSeparator,\n  DropdownMenuShortcut,\n  DropdownMenuGroup,\n  DropdownMenuPortal,\n  DropdownMenuSub,\n  DropdownMenuSubContent,\n  DropdownMenuSubTrigger,\n  DropdownMenuRadioGroup,\n}\n","path":null,"size_bytes":7609,"size_tokens":null},"client/src/components/ui/alert-dialog.tsx":{"content":"import * as React from \"react\"\nimport * as AlertDialogPrimitive from \"@radix-ui/react-alert-dialog\"\n\nimport { cn } from \"@/lib/utils\"\nimport { buttonVariants } from \"@/components/ui/button\"\n\nconst AlertDialog = AlertDialogPrimitive.Root\n\nconst AlertDialogTrigger = AlertDialogPrimitive.Trigger\n\nconst AlertDialogPortal = AlertDialogPrimitive.Portal\n\nconst AlertDialogOverlay = React.forwardRef<\n  React.ElementRef<typeof AlertDialogPrimitive.Overlay>,\n  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Overlay>\n>(({ className, ...props }, ref) => (\n  <AlertDialogPrimitive.Overlay\n    className={cn(\n      \"fixed inset-0 z-50 bg-black/80  data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0\",\n      className\n    )}\n    {...props}\n    ref={ref}\n  />\n))\nAlertDialogOverlay.displayName = AlertDialogPrimitive.Overlay.displayName\n\nconst AlertDialogContent = React.forwardRef<\n  React.ElementRef<typeof AlertDialogPrimitive.Content>,\n  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Content>\n>(({ className, ...props }, ref) => (\n  <AlertDialogPortal>\n    <AlertDialogOverlay />\n    <AlertDialogPrimitive.Content\n      ref={ref}\n      className={cn(\n        \"fixed left-[50%] top-[50%] z-50 grid w-full max-w-lg translate-x-[-50%] translate-y-[-50%] gap-4 border bg-background p-6 shadow-lg duration-200 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[state=closed]:slide-out-to-left-1/2 data-[state=closed]:slide-out-to-top-[48%] data-[state=open]:slide-in-from-left-1/2 data-[state=open]:slide-in-from-top-[48%] sm:rounded-lg\",\n        className\n      )}\n      {...props}\n    />\n  </AlertDialogPortal>\n))\nAlertDialogContent.displayName = AlertDialogPrimitive.Content.displayName\n\nconst AlertDialogHeader = ({\n  className,\n  ...props\n}: React.HTMLAttributes<HTMLDivElement>) => (\n  <div\n    className={cn(\n      \"flex flex-col space-y-2 text-center sm:text-left\",\n      className\n    )}\n    {...props}\n  />\n)\nAlertDialogHeader.displayName = \"AlertDialogHeader\"\n\nconst AlertDialogFooter = ({\n  className,\n  ...props\n}: React.HTMLAttributes<HTMLDivElement>) => (\n  <div\n    className={cn(\n      \"flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2\",\n      className\n    )}\n    {...props}\n  />\n)\nAlertDialogFooter.displayName = \"AlertDialogFooter\"\n\nconst AlertDialogTitle = React.forwardRef<\n  React.ElementRef<typeof AlertDialogPrimitive.Title>,\n  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Title>\n>(({ className, ...props }, ref) => (\n  <AlertDialogPrimitive.Title\n    ref={ref}\n    className={cn(\"text-lg font-semibold\", className)}\n    {...props}\n  />\n))\nAlertDialogTitle.displayName = AlertDialogPrimitive.Title.displayName\n\nconst AlertDialogDescription = React.forwardRef<\n  React.ElementRef<typeof AlertDialogPrimitive.Description>,\n  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Description>\n>(({ className, ...props }, ref) => (\n  <AlertDialogPrimitive.Description\n    ref={ref}\n    className={cn(\"text-sm text-muted-foreground\", className)}\n    {...props}\n  />\n))\nAlertDialogDescription.displayName =\n  AlertDialogPrimitive.Description.displayName\n\nconst AlertDialogAction = React.forwardRef<\n  React.ElementRef<typeof AlertDialogPrimitive.Action>,\n  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Action>\n>(({ className, ...props }, ref) => (\n  <AlertDialogPrimitive.Action\n    ref={ref}\n    className={cn(buttonVariants(), className)}\n    {...props}\n  />\n))\nAlertDialogAction.displayName = AlertDialogPrimitive.Action.displayName\n\nconst AlertDialogCancel = React.forwardRef<\n  React.ElementRef<typeof AlertDialogPrimitive.Cancel>,\n  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Cancel>\n>(({ className, ...props }, ref) => (\n  <AlertDialogPrimitive.Cancel\n    ref={ref}\n    className={cn(\n      buttonVariants({ variant: \"outline\" }),\n      \"mt-2 sm:mt-0\",\n      className\n    )}\n    {...props}\n  />\n))\nAlertDialogCancel.displayName = AlertDialogPrimitive.Cancel.displayName\n\nexport {\n  AlertDialog,\n  AlertDialogPortal,\n  AlertDialogOverlay,\n  AlertDialogTrigger,\n  AlertDialogContent,\n  AlertDialogHeader,\n  AlertDialogFooter,\n  AlertDialogTitle,\n  AlertDialogDescription,\n  AlertDialogAction,\n  AlertDialogCancel,\n}\n","path":null,"size_bytes":4420,"size_tokens":null},"client/src/lib/utils.ts":{"content":"import { clsx, type ClassValue } from \"clsx\"\nimport { twMerge } from \"tailwind-merge\"\n\nexport function cn(...inputs: ClassValue[]) {\n  return twMerge(clsx(inputs))\n}\n","path":null,"size_bytes":166,"size_tokens":null},"client/src/lib/blockchain.ts":{"content":"import { ethers } from \"ethers\";\n\nconst DEFAULT_RPC_ENDPOINTS: Record<number, string> = {\n  1: \"https://eth.llamarpc.com\",\n  56: \"https://bsc-dataseed.binance.org\",\n  137: \"https://polygon-rpc.com\",\n  43114: \"https://api.avax.network/ext/bc/C/rpc\",\n  42161: \"https://arb1.arbitrum.io/rpc\",\n  10: \"https://mainnet.optimism.io\",\n};\n\nconst NON_EVM_DECIMALS: Record<string, number> = {\n  BTC: 8,\n  SOL: 9,\n  XRP: 6,\n  DOGE: 8,\n  ADA: 6,\n  TRX: 6,\n  DOT: 10,\n  LTC: 8,\n  BCH: 8,\n  ATOM: 6,\n  OSMO: 6,\n};\n\nconst ERC20_ABI = [\n  \"function balanceOf(address owner) view returns (uint256)\",\n  \"function decimals() view returns (uint8)\",\n  \"function symbol() view returns (string)\",\n  \"function name() view returns (string)\",\n  \"function transfer(address to, uint256 amount) returns (bool)\",\n];\n\nexport interface BroadcastResult {\n  success: boolean;\n  txHash?: string;\n  error?: string;\n}\n\nexport interface TokenBalance {\n  balance: string;\n  balanceFormatted: string;\n  symbol: string;\n  decimals: number;\n}\n\nexport async function getProvider(chainId: number, customRpcUrl?: string): Promise<ethers.JsonRpcProvider | null> {\n  const rpcUrl = customRpcUrl || DEFAULT_RPC_ENDPOINTS[chainId];\n  if (!rpcUrl) {\n    return null;\n  }\n  return new ethers.JsonRpcProvider(rpcUrl, chainId);\n}\n\nexport async function getProviderByRpcUrl(rpcUrl: string, chainId: number): Promise<ethers.JsonRpcProvider | null> {\n  if (!rpcUrl) {\n    return null;\n  }\n  return new ethers.JsonRpcProvider(rpcUrl, chainId);\n}\n\nexport async function broadcastTransaction(\n  signedTx: string,\n  chainId: number\n): Promise<BroadcastResult> {\n  try {\n    const provider = await getProvider(chainId);\n    if (!provider) {\n      return { success: false, error: `No RPC endpoint for chain ${chainId}` };\n    }\n\n    const txResponse = await provider.broadcastTransaction(signedTx);\n    return { success: true, txHash: txResponse.hash };\n  } catch (error: any) {\n    return { success: false, error: error.message || \"Failed to broadcast transaction\" };\n  }\n}\n\nexport async function getBalance(address: string, chainId: number, customRpcUrl?: string): Promise<string> {\n  try {\n    const provider = await getProvider(chainId, customRpcUrl);\n    if (!provider) return \"0\";\n    const balance = await provider.getBalance(address);\n    return ethers.formatEther(balance);\n  } catch {\n    return \"0\";\n  }\n}\n\nexport async function getGasPrice(chainId: number): Promise<bigint | null> {\n  try {\n    const provider = await getProvider(chainId);\n    if (!provider) return null;\n    const feeData = await provider.getFeeData();\n    return feeData.gasPrice;\n  } catch {\n    return null;\n  }\n}\n\nexport async function getNonce(address: string, chainId: number): Promise<number | null> {\n  try {\n    const provider = await getProvider(chainId);\n    if (!provider) return null;\n    return await provider.getTransactionCount(address);\n  } catch {\n    return null;\n  }\n}\n\nexport async function estimateGas(\n  tx: ethers.TransactionRequest,\n  chainId: number\n): Promise<bigint | null> {\n  try {\n    const provider = await getProvider(chainId);\n    if (!provider) return null;\n    return await provider.estimateGas(tx);\n  } catch {\n    return null;\n  }\n}\n\nexport async function getTokenBalance(\n  address: string,\n  contractAddress: string,\n  rpcUrl: string,\n  chainId: number\n): Promise<TokenBalance | null> {\n  try {\n    const provider = await getProviderByRpcUrl(rpcUrl, chainId);\n    if (!provider) return null;\n\n    const contract = new ethers.Contract(contractAddress, ERC20_ABI, provider);\n\n    const [balance, decimals, symbol] = await Promise.all([\n      contract.balanceOf(address),\n      contract.decimals(),\n      contract.symbol(),\n    ]);\n\n    const balanceFormatted = ethers.formatUnits(balance, decimals);\n\n    return {\n      balance: balance.toString(),\n      balanceFormatted,\n      symbol,\n      decimals: Number(decimals),\n    };\n  } catch (error) {\n    return null;\n  }\n}\n\nexport async function getTokenInfo(\n  contractAddress: string,\n  rpcUrl: string,\n  chainId: number\n): Promise<{ name: string; symbol: string; decimals: number } | null> {\n  try {\n    const provider = await getProviderByRpcUrl(rpcUrl, chainId);\n    if (!provider) return null;\n\n    const contract = new ethers.Contract(contractAddress, ERC20_ABI, provider);\n\n    const [name, symbol, decimals] = await Promise.all([\n      contract.name(),\n      contract.symbol(),\n      contract.decimals(),\n    ]);\n\n    return {\n      name,\n      symbol,\n      decimals: Number(decimals),\n    };\n  } catch (error) {\n    return null;\n  }\n}\n\nexport async function broadcastTransactionWithRpc(\n  signedTx: string,\n  rpcUrl: string,\n  chainId: number\n): Promise<BroadcastResult> {\n  try {\n    const provider = await getProviderByRpcUrl(rpcUrl, chainId);\n    if (!provider) {\n      return { success: false, error: \"No RPC endpoint available\" };\n    }\n\n    const txResponse = await provider.broadcastTransaction(signedTx);\n    return { success: true, txHash: txResponse.hash };\n  } catch (error: any) {\n    return { success: false, error: error.message || \"Failed to broadcast transaction\" };\n  }\n}\n\nasync function getBitcoinBalance(address: string): Promise<string> {\n  try {\n    const response = await fetch(\n      `https://blockstream.info/api/address/${address}`,\n      { signal: AbortSignal.timeout(8000) }\n    );\n    if (!response.ok) return \"0\";\n    const data = await response.json();\n    const funded = data.chain_stats?.funded_txo_sum || 0;\n    const spent = data.chain_stats?.spent_txo_sum || 0;\n    const balance = (funded - spent) / 100000000;\n    return balance.toString();\n  } catch {\n    return \"0\";\n  }\n}\n\nasync function getTronBalance(address: string): Promise<string> {\n  try {\n    const response = await fetch(\n      `https://api.trongrid.io/v1/accounts/${address}`,\n      { signal: AbortSignal.timeout(8000) }\n    );\n    if (!response.ok) return \"0\";\n    const data = await response.json();\n    if (data.data?.[0]?.balance) {\n      const trx = data.data[0].balance / 1000000;\n      return trx.toString();\n    }\n    return \"0\";\n  } catch {\n    return \"0\";\n  }\n}\n\nasync function getSolanaBalance(address: string): Promise<string> {\n  try {\n    const response = await fetch('https://api.mainnet-beta.solana.com', {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify({\n        jsonrpc: '2.0',\n        id: 1,\n        method: 'getBalance',\n        params: [address]\n      }),\n      signal: AbortSignal.timeout(10000)\n    });\n    if (!response.ok) return \"0\";\n    const data = await response.json();\n    if (data.result?.value !== undefined) {\n      const sol = data.result.value / 1000000000; // 9 decimals\n      return sol.toString();\n    }\n    return \"0\";\n  } catch {\n    return \"0\";\n  }\n}\n\nasync function getPolkadotBalance(address: string): Promise<string> {\n  // Try Subscan open API first (most reliable free option)\n  try {\n    const response = await fetch(\n      `https://polkadot.webapi.subscan.io/api/v2/scan/account`,\n      {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify({ address }),\n        signal: AbortSignal.timeout(10000)\n      }\n    );\n    if (response.ok) {\n      const data = await response.json();\n      // Subscan returns balance as a string in DOT\n      if (data.data?.account?.balance) {\n        return data.data.account.balance;\n      }\n      // Alternative field location\n      if (data.data?.balance) {\n        return data.data.balance;\n      }\n    }\n  } catch {\n    // Continue to fallback\n  }\n  \n  // Fallback: Statescan API\n  try {\n    const response = await fetch(\n      `https://polkadot.statescan.io/api/accounts/${address}`,\n      { signal: AbortSignal.timeout(10000) }\n    );\n    if (response.ok) {\n      const data = await response.json();\n      // Statescan returns accountDetail.data.free in planck\n      if (data.accountDetail?.data?.free) {\n        const free = BigInt(data.accountDetail.data.free);\n        const dot = Number(free) / Math.pow(10, 10);\n        return dot.toString();\n      }\n      // Alternative: direct data.free\n      if (data.data?.free) {\n        const free = BigInt(data.data.free);\n        const dot = Number(free) / Math.pow(10, 10);\n        return dot.toString();\n      }\n    }\n  } catch {\n    // Continue to next fallback\n  }\n  \n  // Final fallback: Polkaholic API\n  try {\n    const response = await fetch(\n      `https://api.polkaholic.io/account/${address}?chainID=polkadot`,\n      { signal: AbortSignal.timeout(10000) }\n    );\n    if (response.ok) {\n      const data = await response.json();\n      // Polkaholic returns balances.free in planck\n      if (data.balances?.free) {\n        const free = BigInt(data.balances.free);\n        const dot = Number(free) / Math.pow(10, 10);\n        return dot.toString();\n      }\n      // Alternative field\n      if (data.free) {\n        const free = BigInt(data.free);\n        const dot = Number(free) / Math.pow(10, 10);\n        return dot.toString();\n      }\n    }\n  } catch {\n    // All attempts failed\n  }\n  \n  return \"0\";\n}\n\nasync function getXrpBalance(address: string): Promise<string> {\n  try {\n    const response = await fetch('https://s1.ripple.com:51234/', {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify({\n        method: 'account_info',\n        params: [{\n          account: address,\n          ledger_index: 'validated'\n        }]\n      }),\n      signal: AbortSignal.timeout(10000)\n    });\n    if (!response.ok) return \"0\";\n    const data = await response.json();\n    if (data.result?.account_data?.Balance) {\n      const drops = parseInt(data.result.account_data.Balance);\n      const xrp = drops / 1000000; // 6 decimals\n      return xrp.toString();\n    }\n    return \"0\";\n  } catch {\n    return \"0\";\n  }\n}\n\nasync function getDogeBalance(address: string): Promise<string> {\n  try {\n    // Using Blockcypher API for Dogecoin\n    const response = await fetch(\n      `https://api.blockcypher.com/v1/doge/main/addrs/${address}/balance`,\n      { signal: AbortSignal.timeout(10000) }\n    );\n    if (!response.ok) return \"0\";\n    const data = await response.json();\n    if (data.balance !== undefined) {\n      const doge = data.balance / 100000000; // 8 decimals\n      return doge.toString();\n    }\n    return \"0\";\n  } catch {\n    return \"0\";\n  }\n}\n\nasync function getLitecoinBalance(address: string): Promise<string> {\n  try {\n    // Using Blockcypher API for Litecoin\n    const response = await fetch(\n      `https://api.blockcypher.com/v1/ltc/main/addrs/${address}/balance`,\n      { signal: AbortSignal.timeout(10000) }\n    );\n    if (!response.ok) return \"0\";\n    const data = await response.json();\n    if (data.balance !== undefined) {\n      const ltc = data.balance / 100000000; // 8 decimals\n      return ltc.toString();\n    }\n    return \"0\";\n  } catch {\n    return \"0\";\n  }\n}\n\nasync function getBitcoinCashBalance(address: string): Promise<string> {\n  try {\n    // Using Bitcoin.com API for BCH\n    const response = await fetch(\n      `https://rest.bitcoin.com/v2/address/details/${address}`,\n      { signal: AbortSignal.timeout(10000) }\n    );\n    if (!response.ok) {\n      // Fallback to Blockchair API\n      const blockchairResponse = await fetch(\n        `https://api.blockchair.com/bitcoin-cash/dashboards/address/${address}`,\n        { signal: AbortSignal.timeout(10000) }\n      );\n      if (!blockchairResponse.ok) return \"0\";\n      const blockchairData = await blockchairResponse.json();\n      if (blockchairData.data?.[address]?.address?.balance) {\n        const bch = blockchairData.data[address].address.balance / 100000000;\n        return bch.toString();\n      }\n      return \"0\";\n    }\n    const data = await response.json();\n    if (data.balance !== undefined) {\n      return data.balance.toString();\n    }\n    return \"0\";\n  } catch {\n    return \"0\";\n  }\n}\n\nasync function getCardanoBalance(address: string): Promise<string> {\n  try {\n    // Using Koios API for Cardano (free, no API key required)\n    const response = await fetch('https://api.koios.rest/api/v1/address_info', {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify({ _addresses: [address] }),\n      signal: AbortSignal.timeout(10000)\n    });\n    if (!response.ok) return \"0\";\n    const data = await response.json();\n    // Koios returns balance as a string in lovelace\n    if (data[0]?.utxo_set) {\n      // Sum up all UTXOs for total balance\n      let totalLovelace = 0;\n      for (const utxo of data[0].utxo_set) {\n        totalLovelace += parseInt(utxo.value || \"0\");\n      }\n      const ada = totalLovelace / 1000000;\n      return ada.toString();\n    }\n    return \"0\";\n  } catch {\n    // Fallback: Blockfrost public explorer\n    try {\n      const response = await fetch(\n        `https://cardano-mainnet.blockfrost.io/api/v0/addresses/${address}`,\n        { \n          headers: { 'project_id': 'mainnetpublic' },\n          signal: AbortSignal.timeout(10000) \n        }\n      );\n      if (response.ok) {\n        const data = await response.json();\n        // Find ADA (lovelace) amount\n        const lovelaceAsset = data.amount?.find((a: any) => a.unit === 'lovelace');\n        if (lovelaceAsset) {\n          const ada = parseInt(lovelaceAsset.quantity) / 1000000;\n          return ada.toString();\n        }\n      }\n    } catch {\n      // All attempts failed\n    }\n    return \"0\";\n  }\n}\n\nasync function getCosmosBalance(address: string): Promise<string> {\n  try {\n    const response = await fetch(\n      `https://rest.cosmos.directory/cosmoshub/cosmos/bank/v1beta1/balances/${address}`,\n      { signal: AbortSignal.timeout(8000) }\n    );\n    if (!response.ok) return \"0\";\n    const data = await response.json();\n    const uatom = data.balances?.find((b: any) => b.denom === 'uatom');\n    if (uatom) {\n      const atom = parseInt(uatom.amount) / 1000000;\n      return atom.toString();\n    }\n    return \"0\";\n  } catch {\n    return \"0\";\n  }\n}\n\nasync function getOsmosisBalance(address: string): Promise<string> {\n  try {\n    const response = await fetch(\n      `https://rest.cosmos.directory/osmosis/cosmos/bank/v1beta1/balances/${address}`,\n      { signal: AbortSignal.timeout(8000) }\n    );\n    if (!response.ok) return \"0\";\n    const data = await response.json();\n    const uosmo = data.balances?.find((b: any) => b.denom === 'uosmo');\n    if (uosmo) {\n      const osmo = parseInt(uosmo.amount) / 1000000;\n      return osmo.toString();\n    }\n    return \"0\";\n  } catch {\n    return \"0\";\n  }\n}\n\nexport async function getNonEvmBalance(address: string, chainSymbol: string): Promise<string> {\n  switch (chainSymbol.toUpperCase()) {\n    case 'BTC':\n      return await getBitcoinBalance(address);\n    case 'TRX':\n      return await getTronBalance(address);\n    case 'ATOM':\n      return await getCosmosBalance(address);\n    case 'OSMO':\n      return await getOsmosisBalance(address);\n    case 'SOL':\n      return await getSolanaBalance(address);\n    case 'XRP':\n      return await getXrpBalance(address);\n    case 'DOGE':\n      return await getDogeBalance(address);\n    case 'ADA':\n      return await getCardanoBalance(address);\n    case 'DOT':\n      return await getPolkadotBalance(address);\n    case 'LTC':\n      return await getLitecoinBalance(address);\n    case 'BCH':\n      return await getBitcoinCashBalance(address);\n    default:\n      return \"0\";\n  }\n}\n\nexport async function getUniversalBalance(address: string, chainId: number, chainSymbol: string, customRpcUrl?: string): Promise<string> {\n  if (chainId > 0) {\n    return await getBalance(address, chainId, customRpcUrl);\n  } else {\n    return await getNonEvmBalance(address, chainSymbol);\n  }\n}\n\n// Token contract addresses for popular tokens\nconst TOKEN_CONTRACTS: Record<string, { address: string; chainId: number; decimals: number; rpcUrl: string }> = {\n  // USDT on different chains\n  'usdt-eth': { address: '0xdAC17F958D2ee523a2206206994597C13D831ec7', chainId: 1, decimals: 6, rpcUrl: 'https://eth.llamarpc.com' },\n  'usdt-bsc': { address: '0x55d398326f99059fF775485246999027B3197955', chainId: 56, decimals: 18, rpcUrl: 'https://bsc-dataseed.binance.org' },\n  'usdt-polygon': { address: '0xc2132D05D31c914a87C6611C10748AEb04B58e8F', chainId: 137, decimals: 6, rpcUrl: 'https://polygon-rpc.com' },\n  'usdt-arb': { address: '0xFd086bC7CD5C481DCC9C85ebE478A1C0b69FCbb9', chainId: 42161, decimals: 6, rpcUrl: 'https://arb1.arbitrum.io/rpc' },\n  // USDC on different chains\n  'usdc-eth': { address: '0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48', chainId: 1, decimals: 6, rpcUrl: 'https://eth.llamarpc.com' },\n  'usdc-bsc': { address: '0x8AC76a51cc950d9822D68b83fE1Ad97B32Cd580d', chainId: 56, decimals: 18, rpcUrl: 'https://bsc-dataseed.binance.org' },\n  'usdc-polygon': { address: '0x3c499c542cef5e3811e1192ce70d8cc03d5c3359', chainId: 137, decimals: 6, rpcUrl: 'https://polygon-rpc.com' },\n  'usdc-arb': { address: '0xaf88d065e77c8cC2239327C5EDb3A432268e5831', chainId: 42161, decimals: 6, rpcUrl: 'https://arb1.arbitrum.io/rpc' },\n  // Wrapped Bitcoin\n  'wbtc-eth': { address: '0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599', chainId: 1, decimals: 8, rpcUrl: 'https://eth.llamarpc.com' },\n  // Chainlink\n  'link-eth': { address: '0x514910771AF9Ca656af840dff83E8264EcF986CA', chainId: 1, decimals: 18, rpcUrl: 'https://eth.llamarpc.com' },\n  // Uniswap\n  'uni-eth': { address: '0x1f9840a85d5aF5bf1D1762F925BDADdC4201F984', chainId: 1, decimals: 18, rpcUrl: 'https://eth.llamarpc.com' },\n  // Shiba Inu\n  'shib-eth': { address: '0x95aD61b0a150d79219dCF64E1E6Cc01f0B64C4cE', chainId: 1, decimals: 18, rpcUrl: 'https://eth.llamarpc.com' },\n  // Lido Staked Ether\n  'steth-eth': { address: '0xae7ab96520DE3A18E5e111B5EaAb095312D7fE84', chainId: 1, decimals: 18, rpcUrl: 'https://eth.llamarpc.com' },\n  // Aave\n  'aave-eth': { address: '0x7Fc66500c84A76Ad7e9c93437bFc5Ac33E2DDaE9', chainId: 1, decimals: 18, rpcUrl: 'https://eth.llamarpc.com' },\n  // Maker\n  'mkr-eth': { address: '0x9f8F72aA9304c8B593d555F12eF6589cC3A579A2', chainId: 1, decimals: 18, rpcUrl: 'https://eth.llamarpc.com' },\n  // The Graph\n  'grt-eth': { address: '0xc944E90C64B2c07662A292be6244BDf05Cda44a7', chainId: 1, decimals: 18, rpcUrl: 'https://eth.llamarpc.com' },\n  // DAI\n  'dai-eth': { address: '0x6B175474E89094C44Da98b954EedeAC495271d0F', chainId: 1, decimals: 18, rpcUrl: 'https://eth.llamarpc.com' },\n};\n\n// TRC-20 token addresses on TRON\nconst TRON_TOKEN_CONTRACTS: Record<string, { address: string; decimals: number }> = {\n  'usdt-tron': { address: 'TR7NHqjeKQxGTCi8q8ZY4pL8otSzgjLj6t', decimals: 6 },\n  'usdc-tron': { address: 'TEkxiTehnzSmSe2XqrBj4w32RUN966rdz8', decimals: 6 },\n};\n\n// Fetch TRC-20 token balance from TRON\nasync function getTrc20TokenBalance(walletAddress: string, tokenAddress: string, decimals: number): Promise<string> {\n  try {\n    const response = await fetch(\n      `https://api.trongrid.io/v1/accounts/${walletAddress}/tokens?only_trc20=true`,\n      { signal: AbortSignal.timeout(10000) }\n    );\n    if (!response.ok) return \"0\";\n    const data = await response.json();\n    \n    if (data.data?.[0]?.trc20) {\n      const tokens = data.data[0].trc20;\n      for (const token of tokens) {\n        const contractAddr = Object.keys(token)[0];\n        if (contractAddr === tokenAddress) {\n          const rawBalance = token[contractAddr];\n          const balance = parseFloat(rawBalance) / Math.pow(10, decimals);\n          return balance.toString();\n        }\n      }\n    }\n    return \"0\";\n  } catch {\n    return \"0\";\n  }\n}\n\n// Fetch ERC-20/BEP-20 token balance\nasync function getEvmTokenBalance(walletAddress: string, contractAddress: string, chainId: number, decimals: number, rpcUrl: string): Promise<string> {\n  try {\n    const provider = new ethers.JsonRpcProvider(rpcUrl, chainId);\n    const contract = new ethers.Contract(contractAddress, ERC20_ABI, provider);\n    const balance = await contract.balanceOf(walletAddress);\n    return ethers.formatUnits(balance, decimals);\n  } catch {\n    return \"0\";\n  }\n}\n\n// CoinGecko ID to token key mapping\nconst COINGECKO_TO_TOKEN_KEY: Record<string, { evmKey?: string; tronKey?: string; parentChainSymbol: string }> = {\n  'tether': { evmKey: 'usdt-eth', parentChainSymbol: 'ETH' },\n  'tether-bsc': { evmKey: 'usdt-bsc', parentChainSymbol: 'BNB' },\n  'tether-tron': { tronKey: 'usdt-tron', parentChainSymbol: 'TRX' },\n  'usd-coin': { evmKey: 'usdc-eth', parentChainSymbol: 'ETH' },\n  'usd-coin-bsc': { evmKey: 'usdc-bsc', parentChainSymbol: 'BNB' },\n  'usd-coin-tron': { tronKey: 'usdc-tron', parentChainSymbol: 'TRX' },\n  'wrapped-bitcoin': { evmKey: 'wbtc-eth', parentChainSymbol: 'ETH' },\n  'chainlink': { evmKey: 'link-eth', parentChainSymbol: 'ETH' },\n  'uniswap': { evmKey: 'uni-eth', parentChainSymbol: 'ETH' },\n  'shiba-inu': { evmKey: 'shib-eth', parentChainSymbol: 'ETH' },\n  'staked-ether': { evmKey: 'steth-eth', parentChainSymbol: 'ETH' },\n  'aave': { evmKey: 'aave-eth', parentChainSymbol: 'ETH' },\n  'maker': { evmKey: 'mkr-eth', parentChainSymbol: 'ETH' },\n  'the-graph': { evmKey: 'grt-eth', parentChainSymbol: 'ETH' },\n  'dai': { evmKey: 'dai-eth', parentChainSymbol: 'ETH' },\n};\n\n// Get token balance for a specific CoinGecko asset\nexport async function getTokenBalanceForAsset(\n  coingeckoId: string,\n  walletAddresses: Record<string, string> // chainSymbol -> address mapping\n): Promise<string> {\n  const tokenInfo = COINGECKO_TO_TOKEN_KEY[coingeckoId];\n  if (!tokenInfo) {\n    return \"0\";\n  }\n\n  // Try EVM chains first\n  if (tokenInfo.evmKey && TOKEN_CONTRACTS[tokenInfo.evmKey]) {\n    const contract = TOKEN_CONTRACTS[tokenInfo.evmKey];\n    const walletAddress = walletAddresses[tokenInfo.parentChainSymbol];\n    if (walletAddress) {\n      const balance = await getEvmTokenBalance(\n        walletAddress,\n        contract.address,\n        contract.chainId,\n        contract.decimals,\n        contract.rpcUrl\n      );\n      if (parseFloat(balance) > 0) {\n        return balance;\n      }\n    }\n  }\n\n  // Try TRON if available\n  if (tokenInfo.tronKey && TRON_TOKEN_CONTRACTS[tokenInfo.tronKey]) {\n    const contract = TRON_TOKEN_CONTRACTS[tokenInfo.tronKey];\n    const walletAddress = walletAddresses['TRX'];\n    if (walletAddress) {\n      const balance = await getTrc20TokenBalance(\n        walletAddress,\n        contract.address,\n        contract.decimals\n      );\n      if (parseFloat(balance) > 0) {\n        return balance;\n      }\n    }\n  }\n\n  return \"0\";\n}\n\n// Check if an asset is a token (vs native coin)\nexport function isTokenAsset(coingeckoId: string): boolean {\n  return coingeckoId in COINGECKO_TO_TOKEN_KEY;\n}\n\n// Get the parent chain symbol for a token asset\nexport function getTokenParentChain(coingeckoId: string): string | null {\n  const tokenInfo = COINGECKO_TO_TOKEN_KEY[coingeckoId];\n  return tokenInfo?.parentChainSymbol || null;\n}\n\n// Get balance for a custom token\nexport async function getCustomTokenBalance(\n  walletAddress: string,\n  contractAddress: string,\n  chainType: 'evm' | 'tron',\n  evmChainId: number,\n  rpcUrl: string,\n  decimals: number\n): Promise<string> {\n  if (chainType === 'tron') {\n    return await getTrc20TokenBalance(walletAddress, contractAddress, decimals);\n  } else {\n    return await getEvmTokenBalance(walletAddress, contractAddress, evmChainId, decimals, rpcUrl);\n  }\n}\n","path":null,"size_bytes":23297,"size_tokens":null},"client/src/components/ui/collapsible.tsx":{"content":"\"use client\"\n\nimport * as CollapsiblePrimitive from \"@radix-ui/react-collapsible\"\n\nconst Collapsible = CollapsiblePrimitive.Root\n\nconst CollapsibleTrigger = CollapsiblePrimitive.CollapsibleTrigger\n\nconst CollapsibleContent = CollapsiblePrimitive.CollapsibleContent\n\nexport { Collapsible, CollapsibleTrigger, CollapsibleContent }\n","path":null,"size_bytes":329,"size_tokens":null},"client/src/components/ui/breadcrumb.tsx":{"content":"import * as React from \"react\"\nimport { Slot } from \"@radix-ui/react-slot\"\nimport { ChevronRight, MoreHorizontal } from \"lucide-react\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst Breadcrumb = React.forwardRef<\n  HTMLElement,\n  React.ComponentPropsWithoutRef<\"nav\"> & {\n    separator?: React.ReactNode\n  }\n>(({ ...props }, ref) => <nav ref={ref} aria-label=\"breadcrumb\" {...props} />)\nBreadcrumb.displayName = \"Breadcrumb\"\n\nconst BreadcrumbList = React.forwardRef<\n  HTMLOListElement,\n  React.ComponentPropsWithoutRef<\"ol\">\n>(({ className, ...props }, ref) => (\n  <ol\n    ref={ref}\n    className={cn(\n      \"flex flex-wrap items-center gap-1.5 break-words text-sm text-muted-foreground sm:gap-2.5\",\n      className\n    )}\n    {...props}\n  />\n))\nBreadcrumbList.displayName = \"BreadcrumbList\"\n\nconst BreadcrumbItem = React.forwardRef<\n  HTMLLIElement,\n  React.ComponentPropsWithoutRef<\"li\">\n>(({ className, ...props }, ref) => (\n  <li\n    ref={ref}\n    className={cn(\"inline-flex items-center gap-1.5\", className)}\n    {...props}\n  />\n))\nBreadcrumbItem.displayName = \"BreadcrumbItem\"\n\nconst BreadcrumbLink = React.forwardRef<\n  HTMLAnchorElement,\n  React.ComponentPropsWithoutRef<\"a\"> & {\n    asChild?: boolean\n  }\n>(({ asChild, className, ...props }, ref) => {\n  const Comp = asChild ? Slot : \"a\"\n\n  return (\n    <Comp\n      ref={ref}\n      className={cn(\"transition-colors hover:text-foreground\", className)}\n      {...props}\n    />\n  )\n})\nBreadcrumbLink.displayName = \"BreadcrumbLink\"\n\nconst BreadcrumbPage = React.forwardRef<\n  HTMLSpanElement,\n  React.ComponentPropsWithoutRef<\"span\">\n>(({ className, ...props }, ref) => (\n  <span\n    ref={ref}\n    role=\"link\"\n    aria-disabled=\"true\"\n    aria-current=\"page\"\n    className={cn(\"font-normal text-foreground\", className)}\n    {...props}\n  />\n))\nBreadcrumbPage.displayName = \"BreadcrumbPage\"\n\nconst BreadcrumbSeparator = ({\n  children,\n  className,\n  ...props\n}: React.ComponentProps<\"li\">) => (\n  <li\n    role=\"presentation\"\n    aria-hidden=\"true\"\n    className={cn(\"[&>svg]:w-3.5 [&>svg]:h-3.5\", className)}\n    {...props}\n  >\n    {children ?? <ChevronRight />}\n  </li>\n)\nBreadcrumbSeparator.displayName = \"BreadcrumbSeparator\"\n\nconst BreadcrumbEllipsis = ({\n  className,\n  ...props\n}: React.ComponentProps<\"span\">) => (\n  <span\n    role=\"presentation\"\n    aria-hidden=\"true\"\n    className={cn(\"flex h-9 w-9 items-center justify-center\", className)}\n    {...props}\n  >\n    <MoreHorizontal className=\"h-4 w-4\" />\n    <span className=\"sr-only\">More</span>\n  </span>\n)\nBreadcrumbEllipsis.displayName = \"BreadcrumbElipssis\"\n\nexport {\n  Breadcrumb,\n  BreadcrumbList,\n  BreadcrumbItem,\n  BreadcrumbLink,\n  BreadcrumbPage,\n  BreadcrumbSeparator,\n  BreadcrumbEllipsis,\n}\n","path":null,"size_bytes":2712,"size_tokens":null},"client/src/lib/multi-chain-address.ts":{"content":"import { ethers } from 'ethers';\nimport { Buffer } from 'buffer';\nimport * as nacl from 'tweetnacl';\nimport bs58 from 'bs58';\nimport { blake2b } from 'blakejs';\n\n// Coin types for BIP44 derivation\nconst COIN_TYPES: Record<string, number> = {\n  BTC: 0,\n  LTC: 2,\n  DOGE: 3,\n  BCH: 145,\n  ETH: 60,\n  BNB: 60,\n  MATIC: 60,\n  AVAX: 60,\n  ARB: 60,\n  XRP: 144,\n  TRX: 195,\n  SOL: 501,\n  ADA: 1815,\n  ATOM: 118,\n  OSMO: 118,\n  DOT: 354,\n};\n\n// Generate BIP44 derivation path with account index\nfunction getDerivationPath(chainSymbol: string, accountIndex: number = 0): string {\n  const coinType = COIN_TYPES[chainSymbol] ?? 60;\n  \n  // Special handling for different chain types\n  switch (chainSymbol) {\n    case 'BTC':\n    case 'LTC':\n      // Native SegWit uses purpose 84'\n      return `m/84'/${coinType}'/${accountIndex}'/0/0`;\n    case 'SOL':\n      // Solana uses all hardened path\n      return `m/44'/${coinType}'/${accountIndex}'/0'`;\n    case 'ADA':\n      // Cardano uses CIP-1852 with all hardened for SLIP-0010\n      return `m/1852'/${coinType}'/${accountIndex}'/0'/0'`;\n    case 'DOT':\n      // Polkadot uses all hardened path for SLIP-0010 ed25519\n      return `m/44'/${coinType}'/${accountIndex}'/0'/0'`;\n    default:\n      // Standard BIP44 for EVM and most other chains\n      return `m/44'/${coinType}'/${accountIndex}'/0/0`;\n  }\n}\n\n// Legacy static paths for backward compatibility (account index 0)\nconst DERIVATION_PATHS: Record<string, string> = {\n  BTC: \"m/84'/0'/0'/0/0\",      // Native SegWit (bc1...)\n  LTC: \"m/84'/2'/0'/0/0\",      // Litecoin SegWit\n  DOGE: \"m/44'/3'/0'/0/0\",     // Dogecoin\n  BCH: \"m/44'/145'/0'/0/0\",    // Bitcoin Cash\n  ETH: \"m/44'/60'/0'/0/0\",     // Ethereum (and EVM chains)\n  BNB: \"m/44'/60'/0'/0/0\",     // BSC uses same as ETH\n  MATIC: \"m/44'/60'/0'/0/0\",   // Polygon\n  AVAX: \"m/44'/60'/0'/0/0\",    // Avalanche\n  ARB: \"m/44'/60'/0'/0/0\",     // Arbitrum\n  XRP: \"m/44'/144'/0'/0/0\",    // XRP\n  TRX: \"m/44'/195'/0'/0/0\",    // TRON\n  SOL: \"m/44'/501'/0'/0'\",     // Solana (ed25519)\n  ADA: \"m/1852'/1815'/0'/0'/0'\", // Cardano (SLIP-0010 ed25519 - all hardened)\n  ATOM: \"m/44'/118'/0'/0/0\",   // Cosmos (secp256k1)\n  OSMO: \"m/44'/118'/0'/0/0\",   // Osmosis (same as Cosmos)\n  DOT: \"m/44'/354'/0'/0'/0'\",  // Polkadot (SLIP-0010 ed25519 - all hardened)\n};\n\n// Base58 alphabets\nconst BITCOIN_ALPHABET = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';\nconst XRP_ALPHABET = 'rpshnaf39wBUDNEGHJKLM4PQRST7VWXYZ2bcdeCg65jkm8oFqi1tuvAxyz';\n\nfunction base58Encode(bytes: Uint8Array, alphabet: string = BITCOIN_ALPHABET): string {\n  if (bytes.length === 0) return '';\n  let result = '';\n  let num = BigInt('0x' + Buffer.from(bytes).toString('hex'));\n  while (num > BigInt(0)) {\n    const remainder = Number(num % BigInt(58));\n    result = alphabet[remainder] + result;\n    num = num / BigInt(58);\n  }\n  for (let i = 0; i < bytes.length && bytes[i] === 0; i++) {\n    result = alphabet[0] + result;\n  }\n  return result || alphabet[0];\n}\n\nexport interface DerivedAddress {\n  chainSymbol: string;\n  address: string;\n  path: string;\n}\n\nfunction deriveEVMAddress(mnemonic: string, chainSymbol: string, accountIndex: number = 0): string {\n  try {\n    const path = getDerivationPath(chainSymbol, accountIndex);\n    const mnemonicObj = ethers.Mnemonic.fromPhrase(mnemonic);\n    const hdNode = ethers.HDNodeWallet.fromMnemonic(mnemonicObj, path);\n    return hdNode.address;\n  } catch (error) {\n    console.error('EVM derivation error:', error);\n    return '';\n  }\n}\n\nfunction deriveBitcoinAddress(mnemonic: string, chainSymbol: string, accountIndex: number = 0): string {\n  try {\n    // For Bitcoin-like chains, derive from seed and create address format\n    const path = getDerivationPath(chainSymbol, accountIndex);\n    const mnemonicObj = ethers.Mnemonic.fromPhrase(mnemonic);\n    const hdNode = ethers.HDNodeWallet.fromMnemonic(mnemonicObj, path);\n    \n    // Get the compressed public key\n    const pubKeyHex = hdNode.publicKey;\n    const pubKeyBytes = ethers.getBytes(pubKeyHex);\n    \n    // SHA256 then RIPEMD160 (Hash160)\n    const sha256Hash = ethers.sha256(pubKeyBytes);\n    const hash160 = ethers.ripemd160(sha256Hash);\n    const hash160Bytes = ethers.getBytes(hash160);\n    \n    if (chainSymbol === 'BTC' || chainSymbol === 'LTC') {\n      // Bech32 encoding for SegWit\n      const hrp = chainSymbol === 'LTC' ? 'ltc' : 'bc';\n      return bech32Encode(hrp, hash160Bytes);\n    } else {\n      // Legacy P2PKH for DOGE, BCH\n      let version: number;\n      if (chainSymbol === 'DOGE') {\n        version = 0x1e;\n      } else {\n        version = 0x00;\n      }\n      \n      const versionedPayload = new Uint8Array(21);\n      versionedPayload[0] = version;\n      versionedPayload.set(hash160Bytes, 1);\n      \n      const checksum1 = ethers.getBytes(ethers.sha256(versionedPayload));\n      const checksum2 = ethers.getBytes(ethers.sha256(checksum1));\n      const checksum = checksum2.slice(0, 4);\n      \n      const addressBytes = new Uint8Array(25);\n      addressBytes.set(versionedPayload);\n      addressBytes.set(checksum, 21);\n      \n      return base58Encode(addressBytes);\n    }\n  } catch (error) {\n    console.error(`${chainSymbol} derivation error:`, error);\n    return '';\n  }\n}\n\nfunction bech32Encode(hrp: string, data: Uint8Array): string {\n  const CHARSET = 'qpzry9x8gf2tvdw0s3jn54khce6mua7l';\n  const GENERATOR = [0x3b6a57b2, 0x26508e6d, 0x1ea119fa, 0x3d4233dd, 0x2a1462b3];\n  \n  function polymod(values: number[]): number {\n    let chk = 1;\n    for (const v of values) {\n      const b = chk >> 25;\n      chk = ((chk & 0x1ffffff) << 5) ^ v;\n      for (let i = 0; i < 5; i++) {\n        chk ^= ((b >> i) & 1) ? GENERATOR[i] : 0;\n      }\n    }\n    return chk;\n  }\n  \n  function hrpExpand(hrp: string): number[] {\n    const ret: number[] = [];\n    for (const c of hrp) ret.push(c.charCodeAt(0) >> 5);\n    ret.push(0);\n    for (const c of hrp) ret.push(c.charCodeAt(0) & 31);\n    return ret;\n  }\n  \n  function convertBits(data: Uint8Array, fromBits: number, toBits: number, pad: boolean): number[] {\n    let acc = 0;\n    let bits = 0;\n    const ret: number[] = [];\n    const maxv = (1 << toBits) - 1;\n    \n    for (const value of data) {\n      acc = (acc << fromBits) | value;\n      bits += fromBits;\n      while (bits >= toBits) {\n        bits -= toBits;\n        ret.push((acc >> bits) & maxv);\n      }\n    }\n    \n    if (pad && bits > 0) {\n      ret.push((acc << (toBits - bits)) & maxv);\n    }\n    return ret;\n  }\n  \n  const values = [0, ...convertBits(data, 8, 5, true)]; // witness version 0 + data\n  const checksum = polymod([...hrpExpand(hrp), ...values, 0, 0, 0, 0, 0, 0]) ^ 1;\n  const checksumChars: number[] = [];\n  for (let i = 0; i < 6; i++) {\n    checksumChars.push((checksum >> (5 * (5 - i))) & 31);\n  }\n  \n  let encoded = hrp + '1';\n  for (const v of values) encoded += CHARSET[v];\n  for (const v of checksumChars) encoded += CHARSET[v];\n  \n  return encoded;\n}\n\n\nfunction deriveXRPAddress(mnemonic: string, accountIndex: number = 0): string {\n  try {\n    const path = getDerivationPath('XRP', accountIndex);\n    const mnemonicObj = ethers.Mnemonic.fromPhrase(mnemonic);\n    const hdNode = ethers.HDNodeWallet.fromMnemonic(mnemonicObj, path);\n    \n    const pubKeyBytes = ethers.getBytes(hdNode.publicKey);\n    const sha256Hash = ethers.sha256(pubKeyBytes);\n    const hash160 = ethers.ripemd160(sha256Hash);\n    const hash160Bytes = ethers.getBytes(hash160);\n    \n    // Version byte 0x00 for XRP mainnet\n    const versionedPayload = new Uint8Array(21);\n    versionedPayload[0] = 0x00;\n    versionedPayload.set(hash160Bytes, 1);\n    \n    // Double SHA256 for checksum\n    const checksum1 = ethers.getBytes(ethers.sha256(versionedPayload));\n    const checksum2 = ethers.getBytes(ethers.sha256(checksum1));\n    const checksum = checksum2.slice(0, 4);\n    \n    const addressBytes = new Uint8Array(25);\n    addressBytes.set(versionedPayload);\n    addressBytes.set(checksum, 21);\n    \n    return base58Encode(addressBytes, XRP_ALPHABET);\n  } catch (error) {\n    console.error('XRP derivation error:', error);\n    return '';\n  }\n}\n\nfunction deriveTRONAddress(mnemonic: string, accountIndex: number = 0): string {\n  try {\n    const ethAddress = deriveEVMAddress(mnemonic, 'TRX', accountIndex);\n    \n    if (!ethAddress) return '';\n    \n    // Convert Ethereum address to TRON address\n    const addressHex = '41' + ethAddress.slice(2);\n    const addressBytes = ethers.getBytes('0x' + addressHex);\n    \n    // Double SHA256 for checksum\n    const checksum1 = ethers.getBytes(ethers.sha256(addressBytes));\n    const checksum2 = ethers.getBytes(ethers.sha256(checksum1));\n    const checksum = checksum2.slice(0, 4);\n    \n    const fullAddress = new Uint8Array(25);\n    fullAddress.set(addressBytes);\n    fullAddress.set(checksum, 21);\n    \n    return base58Encode(fullAddress);\n  } catch (error) {\n    console.error('TRON derivation error:', error);\n    return '';\n  }\n}\n\nasync function hmacSha512(key: Uint8Array, data: Uint8Array): Promise<Uint8Array> {\n  const cryptoKey = await crypto.subtle.importKey(\n    'raw',\n    key,\n    { name: 'HMAC', hash: 'SHA-512' },\n    false,\n    ['sign']\n  );\n  const sig = await crypto.subtle.sign('HMAC', cryptoKey, data);\n  return new Uint8Array(sig);\n}\n\nasync function deriveSolanaAddress(mnemonic: string, accountIndex: number = 0): Promise<string> {\n  try {\n    const mnemonicObj = ethers.Mnemonic.fromPhrase(mnemonic);\n    const seed = mnemonicObj.computeSeed();\n    const seedBytes = ethers.getBytes(seed);\n    \n    // SLIP-0010 ed25519 key derivation\n    // Master key derivation\n    const masterKey = await hmacSha512(\n      new TextEncoder().encode('ed25519 seed'),\n      seedBytes\n    );\n    \n    let key = masterKey.slice(0, 32);\n    let chainCode = masterKey.slice(32, 64);\n    \n    // Derive path: m/44'/501'/accountIndex'/0'\n    const indices = [\n      0x8000002C, // 44' (purpose)\n      0x800001F5, // 501' (Solana coin type)\n      0x80000000 + accountIndex, // accountIndex' (account)\n      0x80000000, // 0' (change - hardened for Solana)\n    ];\n    \n    for (const index of indices) {\n      const data = new Uint8Array(37);\n      data[0] = 0x00;\n      data.set(key, 1);\n      data[33] = (index >> 24) & 0xff;\n      data[34] = (index >> 16) & 0xff;\n      data[35] = (index >> 8) & 0xff;\n      data[36] = index & 0xff;\n      \n      const derived = await hmacSha512(chainCode, data);\n      key = derived.slice(0, 32);\n      chainCode = derived.slice(32, 64);\n    }\n    \n    // Generate keypair from derived seed\n    const keypair = nacl.sign.keyPair.fromSeed(key);\n    \n    return bs58.encode(keypair.publicKey);\n  } catch (error) {\n    console.error('Solana derivation error:', error);\n    return '';\n  }\n}\n\nfunction bech32EncodeCardano(hrp: string, data: Uint8Array): string {\n  const CHARSET = 'qpzry9x8gf2tvdw0s3jn54khce6mua7l';\n  const GENERATOR = [0x3b6a57b2, 0x26508e6d, 0x1ea119fa, 0x3d4233dd, 0x2a1462b3];\n  \n  function polymod(values: number[]): number {\n    let chk = 1;\n    for (const v of values) {\n      const b = chk >> 25;\n      chk = ((chk & 0x1ffffff) << 5) ^ v;\n      for (let i = 0; i < 5; i++) {\n        chk ^= ((b >> i) & 1) ? GENERATOR[i] : 0;\n      }\n    }\n    return chk;\n  }\n  \n  function hrpExpand(hrp: string): number[] {\n    const ret: number[] = [];\n    for (const c of hrp) ret.push(c.charCodeAt(0) >> 5);\n    ret.push(0);\n    for (const c of hrp) ret.push(c.charCodeAt(0) & 31);\n    return ret;\n  }\n  \n  function convertBits(data: Uint8Array, fromBits: number, toBits: number, pad: boolean): number[] {\n    let acc = 0;\n    let bits = 0;\n    const ret: number[] = [];\n    const maxv = (1 << toBits) - 1;\n    \n    for (const value of data) {\n      acc = (acc << fromBits) | value;\n      bits += fromBits;\n      while (bits >= toBits) {\n        bits -= toBits;\n        ret.push((acc >> bits) & maxv);\n      }\n    }\n    \n    if (pad && bits > 0) {\n      ret.push((acc << (toBits - bits)) & maxv);\n    }\n    return ret;\n  }\n  \n  const values = convertBits(data, 8, 5, true);\n  const checksum = polymod([...hrpExpand(hrp), ...values, 0, 0, 0, 0, 0, 0]) ^ 1;\n  const checksumChars: number[] = [];\n  for (let i = 0; i < 6; i++) {\n    checksumChars.push((checksum >> (5 * (5 - i))) & 31);\n  }\n  \n  let encoded = hrp + '1';\n  for (const v of values) encoded += CHARSET[v];\n  for (const v of checksumChars) encoded += CHARSET[v];\n  \n  return encoded;\n}\n\n// BLAKE2b-224 hash using blakejs library\nfunction blake2b224(data: Uint8Array): Uint8Array {\n  return blake2b(data, undefined, 28);\n}\n\n// SS58 encoding for Polkadot addresses\nfunction ss58Encode(publicKey: Uint8Array, prefix: number = 0): string {\n  // SS58 uses Base58 with a specific checksum using Blake2b-512\n  const SS58_PREFIX = new TextEncoder().encode('SS58PRE');\n  \n  // Build the data to hash: SS58PRE || prefix || publicKey\n  let prefixBytes: Uint8Array;\n  if (prefix < 64) {\n    prefixBytes = new Uint8Array([prefix]);\n  } else if (prefix < 16384) {\n    // Two-byte encoding for prefix >= 64\n    prefixBytes = new Uint8Array([\n      ((prefix & 0xFC) >> 2) | 0x40,\n      (prefix >> 8) | ((prefix & 0x03) << 6)\n    ]);\n  } else {\n    throw new Error('SS58 prefix too large');\n  }\n  \n  // Concatenate for checksum calculation\n  const checksumInput = new Uint8Array(SS58_PREFIX.length + prefixBytes.length + publicKey.length);\n  checksumInput.set(SS58_PREFIX, 0);\n  checksumInput.set(prefixBytes, SS58_PREFIX.length);\n  checksumInput.set(publicKey, SS58_PREFIX.length + prefixBytes.length);\n  \n  // Blake2b-512 hash, take first 2 bytes as checksum\n  const hash = blake2b(checksumInput, undefined, 64);\n  const checksum = hash.slice(0, 2);\n  \n  // Build final address bytes: prefix || publicKey || checksum\n  const addressBytes = new Uint8Array(prefixBytes.length + publicKey.length + 2);\n  addressBytes.set(prefixBytes, 0);\n  addressBytes.set(publicKey, prefixBytes.length);\n  addressBytes.set(checksum, prefixBytes.length + publicKey.length);\n  \n  return base58Encode(addressBytes);\n}\n\nasync function derivePolkadotAddress(mnemonic: string, accountIndex: number = 0): Promise<string> {\n  try {\n    const mnemonicObj = ethers.Mnemonic.fromPhrase(mnemonic);\n    const seed = mnemonicObj.computeSeed();\n    const seedBytes = ethers.getBytes(seed);\n    \n    // SLIP-0010 ed25519 key derivation (same pattern as Solana/Cardano)\n    const masterKey = await hmacSha512(\n      new TextEncoder().encode('ed25519 seed'),\n      seedBytes\n    );\n    \n    let key = masterKey.slice(0, 32);\n    let chainCode = masterKey.slice(32, 64);\n    \n    // Path: m/44'/354'/accountIndex'/0'/0' (all hardened for SLIP-0010 ed25519)\n    const indices = [\n      0x8000002C, // 44' (purpose)\n      0x80000162, // 354' (Polkadot coin type)\n      0x80000000 + accountIndex, // accountIndex' (account)\n      0x80000000, // 0' (change - hardened)\n      0x80000000, // 0' (address index - hardened)\n    ];\n    \n    for (const index of indices) {\n      const data = new Uint8Array(37);\n      data[0] = 0x00;\n      data.set(key, 1);\n      data[33] = (index >> 24) & 0xff;\n      data[34] = (index >> 16) & 0xff;\n      data[35] = (index >> 8) & 0xff;\n      data[36] = index & 0xff;\n      \n      const derived = await hmacSha512(chainCode, data);\n      key = derived.slice(0, 32);\n      chainCode = derived.slice(32, 64);\n    }\n    \n    // Generate keypair from derived seed\n    const keypair = nacl.sign.keyPair.fromSeed(key);\n    \n    // SS58 encode with prefix 0 for Polkadot mainnet\n    return ss58Encode(keypair.publicKey, 0);\n  } catch (error) {\n    console.error('Polkadot derivation error:', error);\n    return '';\n  }\n}\n\nasync function deriveCardanoAddress(mnemonic: string, accountIndex: number = 0): Promise<string> {\n  try {\n    const mnemonicObj = ethers.Mnemonic.fromPhrase(mnemonic);\n    const seed = mnemonicObj.computeSeed();\n    const seedBytes = ethers.getBytes(seed);\n    \n    // SLIP-0010 ed25519 key derivation (only supports hardened paths)\n    // Using path: m/1852'/1815'/accountIndex'/0'/0' (all hardened for SLIP-0010 compatibility)\n    const masterKey = await hmacSha512(\n      new TextEncoder().encode('ed25519 seed'),\n      seedBytes\n    );\n    \n    let key = masterKey.slice(0, 32);\n    let chainCode = masterKey.slice(32, 64);\n    \n    // Path: m/1852'/1815'/accountIndex'/0'/0' (all hardened for SLIP-0010 ed25519)\n    const indices = [\n      0x8000073C, // 1852' (purpose - CIP-1852)\n      0x80000717, // 1815' (Cardano coin type)\n      0x80000000 + accountIndex, // accountIndex' (account)\n      0x80000000, // 0' (role/chain - hardened)\n      0x80000000, // 0' (address index - hardened)\n    ];\n    \n    for (const index of indices) {\n      // SLIP-0010 hardened derivation: 0x00 || private key || index\n      const data = new Uint8Array(37);\n      data[0] = 0x00;\n      data.set(key, 1);\n      data[33] = (index >> 24) & 0xff;\n      data[34] = (index >> 16) & 0xff;\n      data[35] = (index >> 8) & 0xff;\n      data[36] = index & 0xff;\n      \n      const derived = await hmacSha512(chainCode, data);\n      key = derived.slice(0, 32);\n      chainCode = derived.slice(32, 64);\n    }\n    \n    // Generate payment public key from derived private key\n    const keypair = nacl.sign.keyPair.fromSeed(key);\n    const paymentPubKey = keypair.publicKey;\n    \n    // Hash payment public key with Blake2b-224\n    const paymentKeyHash = blake2b224(paymentPubKey);\n    \n    // Create Enterprise address (type 6 for mainnet enterprise)\n    // Header byte: 0x61 = Enterprise address, mainnet (network id 1)\n    const addressBytes = new Uint8Array(29);\n    addressBytes[0] = 0x61; // Enterprise address header for mainnet\n    addressBytes.set(paymentKeyHash, 1);\n    \n    return bech32EncodeCardano('addr', addressBytes);\n  } catch (error) {\n    console.error('Cardano derivation error:', error);\n    return '';\n  }\n}\n\nfunction deriveCosmosAddress(mnemonic: string, chainSymbol: string, accountIndex: number = 0): string {\n  try {\n    // Cosmos uses secp256k1 with bech32 encoding\n    const path = getDerivationPath(chainSymbol, accountIndex);\n    const mnemonicObj = ethers.Mnemonic.fromPhrase(mnemonic);\n    const hdNode = ethers.HDNodeWallet.fromMnemonic(mnemonicObj, path);\n    \n    // Get compressed public key (33 bytes)\n    const pubKeyHex = hdNode.publicKey;\n    const pubKeyBytes = ethers.getBytes(pubKeyHex);\n    \n    // SHA256 then RIPEMD160 (same as Bitcoin Hash160)\n    const sha256Hash = ethers.sha256(pubKeyBytes);\n    const hash160 = ethers.ripemd160(sha256Hash);\n    const hash160Bytes = ethers.getBytes(hash160);\n    \n    // Bech32 encode with chain-specific prefix\n    const prefix = chainSymbol === 'OSMO' ? 'osmo' : 'cosmos';\n    return bech32EncodeCosmos(prefix, hash160Bytes);\n  } catch (error) {\n    console.error(`${chainSymbol} derivation error:`, error);\n    return '';\n  }\n}\n\nfunction bech32EncodeCosmos(hrp: string, data: Uint8Array): string {\n  const CHARSET = 'qpzry9x8gf2tvdw0s3jn54khce6mua7l';\n  const GENERATOR = [0x3b6a57b2, 0x26508e6d, 0x1ea119fa, 0x3d4233dd, 0x2a1462b3];\n  \n  function polymod(values: number[]): number {\n    let chk = 1;\n    for (const v of values) {\n      const b = chk >> 25;\n      chk = ((chk & 0x1ffffff) << 5) ^ v;\n      for (let i = 0; i < 5; i++) {\n        chk ^= ((b >> i) & 1) ? GENERATOR[i] : 0;\n      }\n    }\n    return chk;\n  }\n  \n  function hrpExpand(hrp: string): number[] {\n    const ret: number[] = [];\n    for (const c of hrp) ret.push(c.charCodeAt(0) >> 5);\n    ret.push(0);\n    for (const c of hrp) ret.push(c.charCodeAt(0) & 31);\n    return ret;\n  }\n  \n  function convertBits(data: Uint8Array, fromBits: number, toBits: number, pad: boolean): number[] {\n    let acc = 0;\n    let bits = 0;\n    const ret: number[] = [];\n    const maxv = (1 << toBits) - 1;\n    \n    for (const value of data) {\n      acc = (acc << fromBits) | value;\n      bits += fromBits;\n      while (bits >= toBits) {\n        bits -= toBits;\n        ret.push((acc >> bits) & maxv);\n      }\n    }\n    \n    if (pad && bits > 0) {\n      ret.push((acc << (toBits - bits)) & maxv);\n    }\n    return ret;\n  }\n  \n  const values = convertBits(data, 8, 5, true);\n  const checksum = polymod([...hrpExpand(hrp), ...values, 0, 0, 0, 0, 0, 0]) ^ 1;\n  const checksumChars: number[] = [];\n  for (let i = 0; i < 6; i++) {\n    checksumChars.push((checksum >> (5 * (5 - i))) & 31);\n  }\n  \n  let encoded = hrp + '1';\n  for (const v of values) encoded += CHARSET[v];\n  for (const v of checksumChars) encoded += CHARSET[v];\n  \n  return encoded;\n}\n\nexport async function deriveAddressForChain(mnemonic: string, chainSymbol: string, accountIndex: number = 0): Promise<DerivedAddress | null> {\n  try {\n    // Validate mnemonic using ethers\n    try {\n      ethers.Mnemonic.fromPhrase(mnemonic);\n    } catch {\n      console.error('Invalid mnemonic');\n      return null;\n    }\n    \n    const path = getDerivationPath(chainSymbol, accountIndex);\n    let address = '';\n    \n    switch (chainSymbol) {\n      case 'BTC':\n      case 'LTC':\n      case 'DOGE':\n      case 'BCH':\n        address = deriveBitcoinAddress(mnemonic, chainSymbol, accountIndex);\n        break;\n        \n      case 'ETH':\n      case 'BNB':\n      case 'MATIC':\n      case 'AVAX':\n      case 'ARB':\n        address = deriveEVMAddress(mnemonic, chainSymbol, accountIndex);\n        break;\n        \n      case 'XRP':\n        address = deriveXRPAddress(mnemonic, accountIndex);\n        break;\n        \n      case 'TRX':\n        address = deriveTRONAddress(mnemonic, accountIndex);\n        break;\n        \n      case 'SOL':\n        address = await deriveSolanaAddress(mnemonic, accountIndex);\n        break;\n        \n      case 'ADA':\n        address = await deriveCardanoAddress(mnemonic, accountIndex);\n        break;\n        \n      case 'DOT':\n        address = await derivePolkadotAddress(mnemonic, accountIndex);\n        break;\n        \n      case 'ATOM':\n      case 'OSMO':\n        address = deriveCosmosAddress(mnemonic, chainSymbol, accountIndex);\n        break;\n        \n      default:\n        // Default to EVM derivation\n        address = deriveEVMAddress(mnemonic, chainSymbol, accountIndex);\n    }\n    \n    return {\n      chainSymbol,\n      address,\n      path,\n    };\n  } catch (error) {\n    console.error(`Error deriving address for ${chainSymbol}:`, error);\n    return null;\n  }\n}\n\nexport async function deriveAllAddresses(mnemonic: string, chainSymbols: string[], accountIndex: number = 0): Promise<DerivedAddress[]> {\n  const results: DerivedAddress[] = [];\n  \n  for (const symbol of chainSymbols) {\n    const derived = await deriveAddressForChain(mnemonic, symbol, accountIndex);\n    if (derived && derived.address) {\n      results.push(derived);\n    }\n  }\n  \n  return results;\n}\n","path":null,"size_bytes":22651,"size_tokens":null},"client/src/components/ui/input.tsx":{"content":"import * as React from \"react\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst Input = React.forwardRef<HTMLInputElement, React.ComponentProps<\"input\">>(\n  ({ className, type, ...props }, ref) => {\n    // h-9 to match icon buttons and default buttons.\n    return (\n      <input\n        type={type}\n        className={cn(\n          \"flex h-9 w-full rounded-md border border-input bg-background px-3 py-2 text-base ring-offset-background file:border-0 file:bg-transparent file:text-sm file:font-medium file:text-foreground placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 md:text-sm\",\n          className\n        )}\n        ref={ref}\n        {...props}\n      />\n    )\n  }\n)\nInput.displayName = \"Input\"\n\nexport { Input }\n","path":null,"size_bytes":844,"size_tokens":null},"client/src/components/ui/sheet.tsx":{"content":"\"use client\"\n\nimport * as React from \"react\"\nimport * as SheetPrimitive from \"@radix-ui/react-dialog\"\nimport { cva, type VariantProps } from \"class-variance-authority\"\nimport { X } from \"lucide-react\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst Sheet = SheetPrimitive.Root\n\nconst SheetTrigger = SheetPrimitive.Trigger\n\nconst SheetClose = SheetPrimitive.Close\n\nconst SheetPortal = SheetPrimitive.Portal\n\nconst SheetOverlay = React.forwardRef<\n  React.ElementRef<typeof SheetPrimitive.Overlay>,\n  React.ComponentPropsWithoutRef<typeof SheetPrimitive.Overlay>\n>(({ className, ...props }, ref) => (\n  <SheetPrimitive.Overlay\n    className={cn(\n      \"fixed inset-0 z-50 bg-black/80  data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0\",\n      className\n    )}\n    {...props}\n    ref={ref}\n  />\n))\nSheetOverlay.displayName = SheetPrimitive.Overlay.displayName\n\nconst sheetVariants = cva(\n  \"fixed z-50 gap-4 bg-background p-6 shadow-lg transition ease-in-out data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:duration-300 data-[state=open]:duration-500\",\n  {\n    variants: {\n      side: {\n        top: \"inset-x-0 top-0 border-b data-[state=closed]:slide-out-to-top data-[state=open]:slide-in-from-top\",\n        bottom:\n          \"inset-x-0 bottom-0 border-t data-[state=closed]:slide-out-to-bottom data-[state=open]:slide-in-from-bottom\",\n        left: \"inset-y-0 left-0 h-full w-3/4 border-r data-[state=closed]:slide-out-to-left data-[state=open]:slide-in-from-left sm:max-w-sm\",\n        right:\n          \"inset-y-0 right-0 h-full w-3/4  border-l data-[state=closed]:slide-out-to-right data-[state=open]:slide-in-from-right sm:max-w-sm\",\n      },\n    },\n    defaultVariants: {\n      side: \"right\",\n    },\n  }\n)\n\ninterface SheetContentProps\n  extends React.ComponentPropsWithoutRef<typeof SheetPrimitive.Content>,\n    VariantProps<typeof sheetVariants> {}\n\nconst SheetContent = React.forwardRef<\n  React.ElementRef<typeof SheetPrimitive.Content>,\n  SheetContentProps\n>(({ side = \"right\", className, children, ...props }, ref) => (\n  <SheetPortal>\n    <SheetOverlay />\n    <SheetPrimitive.Content\n      ref={ref}\n      className={cn(sheetVariants({ side }), className)}\n      {...props}\n    >\n      {children}\n      <SheetPrimitive.Close className=\"absolute right-4 top-4 rounded-sm opacity-70 ring-offset-background transition-opacity hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none data-[state=open]:bg-secondary\">\n        <X className=\"h-4 w-4\" />\n        <span className=\"sr-only\">Close</span>\n      </SheetPrimitive.Close>\n    </SheetPrimitive.Content>\n  </SheetPortal>\n))\nSheetContent.displayName = SheetPrimitive.Content.displayName\n\nconst SheetHeader = ({\n  className,\n  ...props\n}: React.HTMLAttributes<HTMLDivElement>) => (\n  <div\n    className={cn(\n      \"flex flex-col space-y-2 text-center sm:text-left\",\n      className\n    )}\n    {...props}\n  />\n)\nSheetHeader.displayName = \"SheetHeader\"\n\nconst SheetFooter = ({\n  className,\n  ...props\n}: React.HTMLAttributes<HTMLDivElement>) => (\n  <div\n    className={cn(\n      \"flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2\",\n      className\n    )}\n    {...props}\n  />\n)\nSheetFooter.displayName = \"SheetFooter\"\n\nconst SheetTitle = React.forwardRef<\n  React.ElementRef<typeof SheetPrimitive.Title>,\n  React.ComponentPropsWithoutRef<typeof SheetPrimitive.Title>\n>(({ className, ...props }, ref) => (\n  <SheetPrimitive.Title\n    ref={ref}\n    className={cn(\"text-lg font-semibold text-foreground\", className)}\n    {...props}\n  />\n))\nSheetTitle.displayName = SheetPrimitive.Title.displayName\n\nconst SheetDescription = React.forwardRef<\n  React.ElementRef<typeof SheetPrimitive.Description>,\n  React.ComponentPropsWithoutRef<typeof SheetPrimitive.Description>\n>(({ className, ...props }, ref) => (\n  <SheetPrimitive.Description\n    ref={ref}\n    className={cn(\"text-sm text-muted-foreground\", className)}\n    {...props}\n  />\n))\nSheetDescription.displayName = SheetPrimitive.Description.displayName\n\nexport {\n  Sheet,\n  SheetPortal,\n  SheetOverlay,\n  SheetTrigger,\n  SheetClose,\n  SheetContent,\n  SheetHeader,\n  SheetFooter,\n  SheetTitle,\n  SheetDescription,\n}\n","path":null,"size_bytes":4281,"size_tokens":null},"client/src/components/ui/drawer.tsx":{"content":"\"use client\"\n\nimport * as React from \"react\"\nimport { Drawer as DrawerPrimitive } from \"vaul\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst Drawer = ({\n  shouldScaleBackground = true,\n  ...props\n}: React.ComponentProps<typeof DrawerPrimitive.Root>) => (\n  <DrawerPrimitive.Root\n    shouldScaleBackground={shouldScaleBackground}\n    {...props}\n  />\n)\nDrawer.displayName = \"Drawer\"\n\nconst DrawerTrigger = DrawerPrimitive.Trigger\n\nconst DrawerPortal = DrawerPrimitive.Portal\n\nconst DrawerClose = DrawerPrimitive.Close\n\nconst DrawerOverlay = React.forwardRef<\n  React.ElementRef<typeof DrawerPrimitive.Overlay>,\n  React.ComponentPropsWithoutRef<typeof DrawerPrimitive.Overlay>\n>(({ className, ...props }, ref) => (\n  <DrawerPrimitive.Overlay\n    ref={ref}\n    className={cn(\"fixed inset-0 z-50 bg-black/80\", className)}\n    {...props}\n  />\n))\nDrawerOverlay.displayName = DrawerPrimitive.Overlay.displayName\n\nconst DrawerContent = React.forwardRef<\n  React.ElementRef<typeof DrawerPrimitive.Content>,\n  React.ComponentPropsWithoutRef<typeof DrawerPrimitive.Content>\n>(({ className, children, ...props }, ref) => (\n  <DrawerPortal>\n    <DrawerOverlay />\n    <DrawerPrimitive.Content\n      ref={ref}\n      className={cn(\n        \"fixed inset-x-0 bottom-0 z-50 mt-24 flex h-auto flex-col rounded-t-[10px] border bg-background\",\n        className\n      )}\n      {...props}\n    >\n      <div className=\"mx-auto mt-4 h-2 w-[100px] rounded-full bg-muted\" />\n      {children}\n    </DrawerPrimitive.Content>\n  </DrawerPortal>\n))\nDrawerContent.displayName = \"DrawerContent\"\n\nconst DrawerHeader = ({\n  className,\n  ...props\n}: React.HTMLAttributes<HTMLDivElement>) => (\n  <div\n    className={cn(\"grid gap-1.5 p-4 text-center sm:text-left\", className)}\n    {...props}\n  />\n)\nDrawerHeader.displayName = \"DrawerHeader\"\n\nconst DrawerFooter = ({\n  className,\n  ...props\n}: React.HTMLAttributes<HTMLDivElement>) => (\n  <div\n    className={cn(\"mt-auto flex flex-col gap-2 p-4\", className)}\n    {...props}\n  />\n)\nDrawerFooter.displayName = \"DrawerFooter\"\n\nconst DrawerTitle = React.forwardRef<\n  React.ElementRef<typeof DrawerPrimitive.Title>,\n  React.ComponentPropsWithoutRef<typeof DrawerPrimitive.Title>\n>(({ className, ...props }, ref) => (\n  <DrawerPrimitive.Title\n    ref={ref}\n    className={cn(\n      \"text-lg font-semibold leading-none tracking-tight\",\n      className\n    )}\n    {...props}\n  />\n))\nDrawerTitle.displayName = DrawerPrimitive.Title.displayName\n\nconst DrawerDescription = React.forwardRef<\n  React.ElementRef<typeof DrawerPrimitive.Description>,\n  React.ComponentPropsWithoutRef<typeof DrawerPrimitive.Description>\n>(({ className, ...props }, ref) => (\n  <DrawerPrimitive.Description\n    ref={ref}\n    className={cn(\"text-sm text-muted-foreground\", className)}\n    {...props}\n  />\n))\nDrawerDescription.displayName = DrawerPrimitive.Description.displayName\n\nexport {\n  Drawer,\n  DrawerPortal,\n  DrawerOverlay,\n  DrawerTrigger,\n  DrawerClose,\n  DrawerContent,\n  DrawerHeader,\n  DrawerFooter,\n  DrawerTitle,\n  DrawerDescription,\n}\n","path":null,"size_bytes":3021,"size_tokens":null},"client/src/components/ui/input-otp.tsx":{"content":"import * as React from \"react\"\nimport { OTPInput, OTPInputContext } from \"input-otp\"\nimport { Dot } from \"lucide-react\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst InputOTP = React.forwardRef<\n  React.ElementRef<typeof OTPInput>,\n  React.ComponentPropsWithoutRef<typeof OTPInput>\n>(({ className, containerClassName, ...props }, ref) => (\n  <OTPInput\n    ref={ref}\n    containerClassName={cn(\n      \"flex items-center gap-2 has-[:disabled]:opacity-50\",\n      containerClassName\n    )}\n    className={cn(\"disabled:cursor-not-allowed\", className)}\n    {...props}\n  />\n))\nInputOTP.displayName = \"InputOTP\"\n\nconst InputOTPGroup = React.forwardRef<\n  React.ElementRef<\"div\">,\n  React.ComponentPropsWithoutRef<\"div\">\n>(({ className, ...props }, ref) => (\n  <div ref={ref} className={cn(\"flex items-center\", className)} {...props} />\n))\nInputOTPGroup.displayName = \"InputOTPGroup\"\n\nconst InputOTPSlot = React.forwardRef<\n  React.ElementRef<\"div\">,\n  React.ComponentPropsWithoutRef<\"div\"> & { index: number }\n>(({ index, className, ...props }, ref) => {\n  const inputOTPContext = React.useContext(OTPInputContext)\n  const { char, hasFakeCaret, isActive } = inputOTPContext.slots[index]\n\n  return (\n    <div\n      ref={ref}\n      className={cn(\n        \"relative flex h-10 w-10 items-center justify-center border-y border-r border-input text-sm transition-all first:rounded-l-md first:border-l last:rounded-r-md\",\n        isActive && \"z-10 ring-2 ring-ring ring-offset-background\",\n        className\n      )}\n      {...props}\n    >\n      {char}\n      {hasFakeCaret && (\n        <div className=\"pointer-events-none absolute inset-0 flex items-center justify-center\">\n          <div className=\"h-4 w-px animate-caret-blink bg-foreground duration-1000\" />\n        </div>\n      )}\n    </div>\n  )\n})\nInputOTPSlot.displayName = \"InputOTPSlot\"\n\nconst InputOTPSeparator = React.forwardRef<\n  React.ElementRef<\"div\">,\n  React.ComponentPropsWithoutRef<\"div\">\n>(({ ...props }, ref) => (\n  <div ref={ref} role=\"separator\" {...props}>\n    <Dot />\n  </div>\n))\nInputOTPSeparator.displayName = \"InputOTPSeparator\"\n\nexport { InputOTP, InputOTPGroup, InputOTPSlot, InputOTPSeparator }\n","path":null,"size_bytes":2154,"size_tokens":null},"client/src/index.css":{"content":"@tailwind base;\n@tailwind components;\n@tailwind utilities;\n\n/* LIGHT MODE */\n:root {\n  --button-outline: rgba(0,0,0, .10);\n  --badge-outline: rgba(0,0,0, .05);\n  --opaque-button-border-intensity: -8;\n  --elevate-1: rgba(0,0,0, .03);\n  --elevate-2: rgba(0,0,0, .08);\n  --background: 0 0% 100%;\n  --foreground: 240 5% 12%;\n  --border: 240 4% 92%;\n  --card: 0 0% 98%;\n  --card-foreground: 240 5% 12%;\n  --card-border: 240 4% 94%;\n  --sidebar: 240 3% 96%;\n  --sidebar-foreground: 240 5% 12%;\n  --sidebar-border: 240 4% 92%;\n  --sidebar-primary: 217 91% 35%;\n  --sidebar-primary-foreground: 0 0% 98%;\n  --sidebar-accent: 240 5% 88%;\n  --sidebar-accent-foreground: 240 5% 12%;\n  --sidebar-ring: 217 91% 35%;\n  --popover: 0 0% 96%;\n  --popover-foreground: 240 5% 12%;\n  --popover-border: 240 4% 92%;\n  --primary: 217 91% 35%;\n  --primary-foreground: 0 0% 98%;\n  --secondary: 240 5% 90%;\n  --secondary-foreground: 240 5% 12%;\n  --muted: 240 5% 92%;\n  --muted-foreground: 240 4% 40%;\n  --accent: 220 15% 94%;\n  --accent-foreground: 240 5% 12%;\n  --destructive: 0 72% 40%;\n  --destructive-foreground: 0 0% 98%;\n  --input: 240 6% 75%;\n  --ring: 217 91% 35%;\n  --chart-1: 217 91% 35%;\n  --chart-2: 173 58% 35%;\n  --chart-3: 280 65% 40%;\n  --chart-4: 32 95% 45%;\n  --chart-5: 340 75% 42%;\n  --font-sans: Inter, sans-serif;\n  --font-serif: Georgia, serif;\n  --font-mono: Menlo, monospace;\n  --radius: .5rem;\n  --shadow-2xs: 0px 2px 0px 0px hsl(240 4% 20% / 0.00);\n  --shadow-xs: 0px 2px 0px 0px hsl(240 4% 20% / 0.00);\n  --shadow-sm: 0px 2px 0px 0px hsl(240 4% 20% / 0.00), 0px 1px 2px -1px hsl(240 4% 20% / 0.00);\n  --shadow: 0px 2px 0px 0px hsl(240 4% 20% / 0.00), 0px 1px 2px -1px hsl(240 4% 20% / 0.00);\n  --shadow-md: 0px 2px 0px 0px hsl(240 4% 20% / 0.00), 0px 2px 4px -1px hsl(240 4% 20% / 0.00);\n  --shadow-lg: 0px 2px 0px 0px hsl(240 4% 20% / 0.00), 0px 4px 6px -1px hsl(240 4% 20% / 0.00);\n  --shadow-xl: 0px 2px 0px 0px hsl(240 4% 20% / 0.00), 0px 8px 10px -1px hsl(240 4% 20% / 0.00);\n  --shadow-2xl: 0px 2px 0px 0px hsl(240 4% 20% / 0.00);\n  --tracking-normal: 0em;\n  --spacing: 0.25rem;\n\n/* Fallback for older browsers */\n  --sidebar-primary-border: hsl(var(--sidebar-primary));\n  --sidebar-primary-border: hsl(from hsl(var(--sidebar-primary)) h s calc(l + var(--opaque-button-border-intensity)) / alpha);\n\n  /* Fallback for older browsers */\n  --sidebar-accent-border: hsl(var(--sidebar-accent));\n  --sidebar-accent-border: hsl(from hsl(var(--sidebar-accent)) h s calc(l + var(--opaque-button-border-intensity)) / alpha);\n\n  /* Fallback for older browsers */\n  --primary-border: hsl(var(--primary));\n  --primary-border: hsl(from hsl(var(--primary)) h s calc(l + var(--opaque-button-border-intensity)) / alpha);\n\n  /* Fallback for older browsers */\n  --secondary-border: hsl(var(--secondary));\n  --secondary-border: hsl(from hsl(var(--secondary)) h s calc(l + var(--opaque-button-border-intensity)) / alpha);\n\n  /* Fallback for older browsers */\n  --muted-border: hsl(var(--muted));\n  --muted-border: hsl(from hsl(var(--muted)) h s calc(l + var(--opaque-button-border-intensity)) / alpha);\n\n  /* Fallback for older browsers */\n  --accent-border: hsl(var(--accent));\n  --accent-border: hsl(from hsl(var(--accent)) h s calc(l + var(--opaque-button-border-intensity)) / alpha);\n\n  /* Fallback for older browsers */\n  --destructive-border: hsl(var(--destructive));\n  --destructive-border: hsl(from hsl(var(--destructive)) h s calc(l + var(--opaque-button-border-intensity)) / alpha);\n}\n\n.dark {\n  --button-outline: rgba(255,255,255, .10);\n  --badge-outline: rgba(255,255,255, .05);\n  --opaque-button-border-intensity: 9;\n  --elevate-1: rgba(255,255,255, .04);\n  --elevate-2: rgba(255,255,255, .09);\n  --background: 240 6% 8%;\n  --foreground: 0 0% 98%;\n  --border: 240 5% 16%;\n  --card: 240 5% 10%;\n  --card-foreground: 0 0% 98%;\n  --card-border: 240 5% 13%;\n  --sidebar: 240 4% 12%;\n  --sidebar-foreground: 0 0% 98%;\n  --sidebar-border: 240 5% 16%;\n  --sidebar-primary: 217 91% 45%;\n  --sidebar-primary-foreground: 0 0% 98%;\n  --sidebar-accent: 240 4% 16%;\n  --sidebar-accent-foreground: 0 0% 98%;\n  --sidebar-ring: 217 91% 45%;\n  --popover: 240 5% 14%;\n  --popover-foreground: 0 0% 98%;\n  --popover-border: 240 5% 18%;\n  --primary: 217 91% 35%;\n  --primary-foreground: 0 0% 98%;\n  --secondary: 240 4% 18%;\n  --secondary-foreground: 0 0% 98%;\n  --muted: 240 4% 16%;\n  --muted-foreground: 240 3% 65%;\n  --accent: 220 12% 18%;\n  --accent-foreground: 0 0% 98%;\n  --destructive: 0 72% 35%;\n  --destructive-foreground: 0 0% 98%;\n  --input: 240 5% 30%;\n  --ring: 217 91% 45%;\n  --chart-1: 217 91% 65%;\n  --chart-2: 173 58% 60%;\n  --chart-3: 280 65% 65%;\n  --chart-4: 32 95% 60%;\n  --chart-5: 340 75% 62%;\n  --shadow-2xs: 0px 2px 0px 0px hsl(240 5% 5% / 0.00);\n  --shadow-xs: 0px 2px 0px 0px hsl(240 5% 5% / 0.00);\n  --shadow-sm: 0px 2px 0px 0px hsl(240 5% 5% / 0.00), 0px 1px 2px -1px hsl(240 5% 5% / 0.00);\n  --shadow: 0px 2px 0px 0px hsl(240 5% 5% / 0.00), 0px 1px 2px -1px hsl(240 5% 5% / 0.00);\n  --shadow-md: 0px 2px 0px 0px hsl(240 5% 5% / 0.00), 0px 2px 4px -1px hsl(240 5% 5% / 0.00);\n  --shadow-lg: 0px 2px 0px 0px hsl(240 5% 5% / 0.00), 0px 4px 6px -1px hsl(240 5% 5% / 0.00);\n  --shadow-xl: 0px 2px 0px 0px hsl(240 5% 5% / 0.00), 0px 8px 10px -1px hsl(240 5% 5% / 0.00);\n  --shadow-2xl: 0px 2px 0px 0px hsl(240 5% 5% / 0.00);\n\n/* Fallback for older browsers */\n  --sidebar-primary-border: hsl(var(--sidebar-primary));\n  --sidebar-primary-border: hsl(from hsl(var(--sidebar-primary)) h s calc(l + var(--opaque-button-border-intensity)) / alpha);\n\n  /* Fallback for older browsers */\n  --sidebar-accent-border: hsl(var(--sidebar-accent));\n  --sidebar-accent-border: hsl(from hsl(var(--sidebar-accent)) h s calc(l + var(--opaque-button-border-intensity)) / alpha);\n\n  /* Fallback for older browsers */\n  --primary-border: hsl(var(--primary));\n  --primary-border: hsl(from hsl(var(--primary)) h s calc(l + var(--opaque-button-border-intensity)) / alpha);\n\n  /* Fallback for older browsers */\n  --secondary-border: hsl(var(--secondary));\n  --secondary-border: hsl(from hsl(var(--secondary)) h s calc(l + var(--opaque-button-border-intensity)) / alpha);\n\n  /* Fallback for older browsers */\n  --muted-border: hsl(var(--muted));\n  --muted-border: hsl(from hsl(var(--muted)) h s calc(l + var(--opaque-button-border-intensity)) / alpha);\n\n  /* Fallback for older browsers */\n  --accent-border: hsl(var(--accent));\n  --accent-border: hsl(from hsl(var(--accent)) h s calc(l + var(--opaque-button-border-intensity)) / alpha);\n\n  /* Fallback for older browsers */\n  --destructive-border: hsl(var(--destructive));\n  --destructive-border: hsl(from hsl(var(--destructive)) h s calc(l + var(--opaque-button-border-intensity)) / alpha);\n}\n\n@layer base {\n  * {\n    @apply border-border;\n  }\n\n  html {\n    --safe-area-inset-top: env(safe-area-inset-top, 0px);\n    --safe-area-inset-bottom: env(safe-area-inset-bottom, 0px);\n    --safe-area-inset-left: env(safe-area-inset-left, 0px);\n    --safe-area-inset-right: env(safe-area-inset-right, 0px);\n  }\n\n  body {\n    @apply font-sans antialiased bg-background text-foreground;\n    padding-top: var(--safe-area-inset-top);\n    padding-bottom: var(--safe-area-inset-bottom);\n    padding-left: var(--safe-area-inset-left);\n    padding-right: var(--safe-area-inset-right);\n  }\n}\n\n@keyframes fade-in {\n  from {\n    opacity: 0;\n    transform: translateY(10px);\n  }\n  to {\n    opacity: 1;\n    transform: translateY(0);\n  }\n}\n\n.animate-fade-in {\n  animation: fade-in 0.6s ease-out forwards;\n}\n\n/**\n * Using the elevate system.\n * Automatic contrast adjustment.\n *\n * <element className=\"hover-elevate\" />\n * <element className=\"active-elevate-2\" />\n *\n * // Using the tailwind utility when a data attribute is \"on\"\n * <element className=\"toggle-elevate data-[state=on]:toggle-elevated\" />\n * // Or manually controlling the toggle state\n * <element className=\"toggle-elevate toggle-elevated\" />\n *\n * Elevation systems have to handle many states.\n * - not-hovered, vs. hovered vs. active  (three mutually exclusive states)\n * - toggled or not\n * - focused or not (this is not handled with these utilities)\n *\n * Even without handling focused or not, this is six possible combinations that\n * need to be distinguished from eachother visually.\n */\n@layer utilities {\n\n  /* Hide ugly search cancel button in Chrome until we can style it properly */\n  input[type=\"search\"]::-webkit-search-cancel-button {\n    @apply hidden;\n  }\n\n  /* Placeholder styling for contentEditable div */\n  [contenteditable][data-placeholder]:empty::before {\n    content: attr(data-placeholder);\n    color: hsl(var(--muted-foreground));\n    pointer-events: none;\n  }\n\n  /* .no-default-hover-elevate/no-default-active-elevate is an escape hatch so consumers of\n   * buttons/badges can remove the automatic brightness adjustment on interactions\n   * and program their own. */\n  .no-default-hover-elevate {}\n\n  .no-default-active-elevate {}\n\n\n  /**\n   * Toggleable backgrounds go behind the content. Hoverable/active goes on top.\n   * This way they can stack/compound. Both will overlap the parent's borders!\n   * So borders will be automatically adjusted both on toggle, and hover/active,\n   * and they will be compounded.\n   */\n  .toggle-elevate::before,\n  .toggle-elevate-2::before {\n    content: \"\";\n    pointer-events: none;\n    position: absolute;\n    inset: 0px;\n    /*border-radius: inherit;   match rounded corners */\n    border-radius: inherit;\n    z-index: -1;\n    /* sits behind content but above backdrop */\n  }\n\n  .toggle-elevate.toggle-elevated::before {\n    background-color: var(--elevate-2);\n  }\n\n  /* If there's a 1px border, adjust the inset so that it covers that parent's border */\n  .border.toggle-elevate::before {\n    inset: -1px;\n  }\n\n  /* Does not work on elements with overflow:hidden! */\n  .hover-elevate:not(.no-default-hover-elevate),\n  .active-elevate:not(.no-default-active-elevate),\n  .hover-elevate-2:not(.no-default-hover-elevate),\n  .active-elevate-2:not(.no-default-active-elevate) {\n    position: relative;\n    z-index: 0;\n  }\n\n  .hover-elevate:not(.no-default-hover-elevate)::after,\n  .active-elevate:not(.no-default-active-elevate)::after,\n  .hover-elevate-2:not(.no-default-hover-elevate)::after,\n  .active-elevate-2:not(.no-default-active-elevate)::after {\n    content: \"\";\n    pointer-events: none;\n    position: absolute;\n    inset: 0px;\n    /*border-radius: inherit;   match rounded corners */\n    border-radius: inherit;\n    z-index: 999;\n    /* sits in front of content */\n  }\n\n  .hover-elevate:hover:not(.no-default-hover-elevate)::after,\n  .active-elevate:active:not(.no-default-active-elevate)::after {\n    background-color: var(--elevate-1);\n  }\n\n  .hover-elevate-2:hover:not(.no-default-hover-elevate)::after,\n  .active-elevate-2:active:not(.no-default-active-elevate)::after {\n    background-color: var(--elevate-2);\n  }\n\n  /* If there's a 1px border, adjust the inset so that it covers that parent's border */\n  .border.hover-elevate:not(.no-hover-interaction-elevate)::after,\n  .border.active-elevate:not(.no-active-interaction-elevate)::after,\n  .border.hover-elevate-2:not(.no-hover-interaction-elevate)::after,\n  .border.active-elevate-2:not(.no-active-interaction-elevate)::after,\n  .border.hover-elevate:not(.no-hover-interaction-elevate)::after {\n    inset: -1px;\n  }\n}\n\n/* ============================================\n   UNIQUE GLASSMORPHIC DESIGN SYSTEM\n   Animated mesh gradients, holographic effects\n   ============================================ */\n\n/* Animated Mesh Gradient Background */\n@keyframes mesh-gradient {\n  0%, 100% {\n    background-position: 0% 50%;\n  }\n  50% {\n    background-position: 100% 50%;\n  }\n}\n\n@keyframes aurora-shift {\n  0% {\n    transform: rotate(0deg) scale(1);\n    opacity: 0.3;\n  }\n  33% {\n    transform: rotate(120deg) scale(1.1);\n    opacity: 0.5;\n  }\n  66% {\n    transform: rotate(240deg) scale(0.9);\n    opacity: 0.4;\n  }\n  100% {\n    transform: rotate(360deg) scale(1);\n    opacity: 0.3;\n  }\n}\n\n@keyframes pulse-glow {\n  0%, 100% {\n    box-shadow: 0 0 20px rgba(99, 102, 241, 0.3), 0 0 40px rgba(168, 85, 247, 0.2);\n  }\n  50% {\n    box-shadow: 0 0 30px rgba(99, 102, 241, 0.5), 0 0 60px rgba(168, 85, 247, 0.3);\n  }\n}\n\n@keyframes shimmer {\n  0% {\n    background-position: -200% 0;\n  }\n  100% {\n    background-position: 200% 0;\n  }\n}\n\n@keyframes holographic {\n  0% {\n    background-position: 0% 50%;\n    filter: hue-rotate(0deg);\n  }\n  50% {\n    background-position: 100% 50%;\n    filter: hue-rotate(15deg);\n  }\n  100% {\n    background-position: 0% 50%;\n    filter: hue-rotate(0deg);\n  }\n}\n\n@keyframes float {\n  0%, 100% {\n    transform: translateY(0px);\n  }\n  50% {\n    transform: translateY(-6px);\n  }\n}\n\n@keyframes border-dance {\n  0%, 100% {\n    border-color: rgba(99, 102, 241, 0.5);\n  }\n  33% {\n    border-color: rgba(168, 85, 247, 0.5);\n  }\n  66% {\n    border-color: rgba(236, 72, 153, 0.5);\n  }\n}\n\n@keyframes glow-pulse {\n  0%, 100% {\n    opacity: 0.6;\n    transform: scale(1);\n  }\n  50% {\n    opacity: 0.9;\n    transform: scale(1.02);\n  }\n}\n\n/* Mesh Gradient Background Container */\n.mesh-bg {\n  position: fixed;\n  inset: 0;\n  z-index: -1;\n  overflow: hidden;\n}\n\n.mesh-bg::before {\n  content: '';\n  position: absolute;\n  inset: -50%;\n  background: \n    radial-gradient(ellipse at 20% 30%, rgba(99, 102, 241, 0.15) 0%, transparent 50%),\n    radial-gradient(ellipse at 80% 20%, rgba(168, 85, 247, 0.12) 0%, transparent 50%),\n    radial-gradient(ellipse at 40% 80%, rgba(236, 72, 153, 0.1) 0%, transparent 50%),\n    radial-gradient(ellipse at 90% 70%, rgba(59, 130, 246, 0.12) 0%, transparent 50%);\n  animation: aurora-shift 20s ease-in-out infinite;\n}\n\n.mesh-bg::after {\n  content: '';\n  position: absolute;\n  inset: -50%;\n  background: \n    radial-gradient(ellipse at 70% 60%, rgba(139, 92, 246, 0.1) 0%, transparent 50%),\n    radial-gradient(ellipse at 30% 50%, rgba(6, 182, 212, 0.08) 0%, transparent 50%);\n  animation: aurora-shift 25s ease-in-out infinite reverse;\n}\n\n.dark .mesh-bg::before {\n  background: \n    radial-gradient(ellipse at 20% 30%, rgba(99, 102, 241, 0.2) 0%, transparent 50%),\n    radial-gradient(ellipse at 80% 20%, rgba(168, 85, 247, 0.15) 0%, transparent 50%),\n    radial-gradient(ellipse at 40% 80%, rgba(236, 72, 153, 0.12) 0%, transparent 50%),\n    radial-gradient(ellipse at 90% 70%, rgba(59, 130, 246, 0.15) 0%, transparent 50%);\n}\n\n.dark .mesh-bg::after {\n  background: \n    radial-gradient(ellipse at 70% 60%, rgba(139, 92, 246, 0.12) 0%, transparent 50%),\n    radial-gradient(ellipse at 30% 50%, rgba(6, 182, 212, 0.1) 0%, transparent 50%);\n}\n\n/* Glassmorphic Card */\n.glass-card {\n  background: rgba(255, 255, 255, 0.7);\n  backdrop-filter: blur(20px);\n  -webkit-backdrop-filter: blur(20px);\n  border: 1px solid rgba(255, 255, 255, 0.3);\n  box-shadow: \n    0 8px 32px rgba(0, 0, 0, 0.08),\n    inset 0 1px 0 rgba(255, 255, 255, 0.5);\n  transition: all 0.3s ease;\n}\n\n.glass-card:hover {\n  box-shadow: \n    0 12px 40px rgba(0, 0, 0, 0.12),\n    inset 0 1px 0 rgba(255, 255, 255, 0.6);\n  transform: translateY(-2px);\n}\n\n.dark .glass-card {\n  background: rgba(30, 30, 40, 0.6);\n  border: 1px solid rgba(255, 255, 255, 0.1);\n  box-shadow: \n    0 8px 32px rgba(0, 0, 0, 0.3),\n    inset 0 1px 0 rgba(255, 255, 255, 0.05);\n}\n\n.dark .glass-card:hover {\n  box-shadow: \n    0 12px 40px rgba(0, 0, 0, 0.4),\n    inset 0 1px 0 rgba(255, 255, 255, 0.08);\n}\n\n/* Holographic Shimmer Effect */\n.holo-shimmer {\n  position: relative;\n  overflow: visible;\n}\n\n.holo-shimmer::before {\n  content: '';\n  position: absolute;\n  inset: 0;\n  background: linear-gradient(\n    110deg,\n    transparent 25%,\n    rgba(255, 255, 255, 0.2) 50%,\n    transparent 75%\n  );\n  background-size: 200% 100%;\n  animation: shimmer 3s ease-in-out infinite;\n  pointer-events: none;\n  border-radius: inherit;\n}\n\n.dark .holo-shimmer::before {\n  background: linear-gradient(\n    110deg,\n    transparent 25%,\n    rgba(255, 255, 255, 0.08) 50%,\n    transparent 75%\n  );\n  background-size: 200% 100%;\n}\n\n/* Glowing Border Effect */\n.glow-border {\n  position: relative;\n  border: 1px solid transparent;\n  background-clip: padding-box;\n}\n\n.glow-border::before {\n  content: '';\n  position: absolute;\n  inset: -2px;\n  background: linear-gradient(\n    135deg,\n    rgba(99, 102, 241, 0.4),\n    rgba(168, 85, 247, 0.4),\n    rgba(236, 72, 153, 0.4),\n    rgba(99, 102, 241, 0.4)\n  );\n  background-size: 300% 300%;\n  border-radius: inherit;\n  z-index: -1;\n  animation: holographic 8s ease infinite;\n  filter: blur(3px);\n  opacity: 0.6;\n}\n\n.glow-border:hover::before {\n  opacity: 0.9;\n  filter: blur(4px);\n}\n\n/* Holographic Button */\n.holo-button {\n  position: relative;\n  background: linear-gradient(\n    135deg,\n    rgba(99, 102, 241, 0.9),\n    rgba(139, 92, 246, 0.9),\n    rgba(168, 85, 247, 0.9)\n  );\n  background-size: 200% 200%;\n  animation: holographic 6s ease infinite;\n  border: none;\n  color: white;\n  text-shadow: 0 1px 2px rgba(0, 0, 0, 0.2);\n  box-shadow: \n    0 4px 20px rgba(99, 102, 241, 0.3),\n    0 2px 10px rgba(168, 85, 247, 0.2);\n  transition: all 0.3s ease;\n}\n\n.holo-button:hover {\n  box-shadow: \n    0 6px 30px rgba(99, 102, 241, 0.4),\n    0 4px 15px rgba(168, 85, 247, 0.3);\n  transform: translateY(-1px);\n}\n\n/* Balance Display with Glow */\n.balance-glow {\n  text-shadow: \n    0 0 20px rgba(99, 102, 241, 0.5),\n    0 0 40px rgba(168, 85, 247, 0.3);\n  animation: glow-pulse 3s ease-in-out infinite;\n}\n\n.dark .balance-glow {\n  text-shadow: \n    0 0 30px rgba(99, 102, 241, 0.6),\n    0 0 60px rgba(168, 85, 247, 0.4);\n}\n\n/* Gradient Text */\n.gradient-text {\n  background: linear-gradient(\n    135deg,\n    hsl(var(--primary)) 0%,\n    rgba(139, 92, 246, 1) 50%,\n    rgba(236, 72, 153, 1) 100%\n  );\n  -webkit-background-clip: text;\n  background-clip: text;\n  -webkit-text-fill-color: transparent;\n  animation: holographic 8s ease infinite;\n  background-size: 200% 200%;\n}\n\n/* Floating Animation */\n.float-animation {\n  animation: float 4s ease-in-out infinite;\n}\n\n/* Orbital Chain Selector Styles */\n.orbital-chain {\n  transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);\n}\n\n.orbital-chain:hover {\n  transform: scale(1.15);\n}\n\n.orbital-chain.selected {\n  animation: pulse-glow 2s ease-in-out infinite;\n}\n\n/* Ambient Particles */\n@keyframes particle-float {\n  0%, 100% {\n    transform: translateY(0) translateX(0) rotate(0deg);\n    opacity: 0.3;\n  }\n  25% {\n    transform: translateY(-20px) translateX(10px) rotate(90deg);\n    opacity: 0.6;\n  }\n  50% {\n    transform: translateY(-10px) translateX(-5px) rotate(180deg);\n    opacity: 0.4;\n  }\n  75% {\n    transform: translateY(-25px) translateX(15px) rotate(270deg);\n    opacity: 0.5;\n  }\n}\n\n.particle {\n  position: absolute;\n  width: 4px;\n  height: 4px;\n  background: linear-gradient(135deg, rgba(99, 102, 241, 0.6), rgba(168, 85, 247, 0.6));\n  border-radius: 50%;\n  animation: particle-float 8s ease-in-out infinite;\n}\n\n/* Asset Card Hover Glow */\n.asset-card-glow {\n  transition: all 0.3s ease;\n}\n\n.asset-card-glow:hover {\n  box-shadow: \n    0 0 0 1px rgba(99, 102, 241, 0.2),\n    0 8px 25px rgba(99, 102, 241, 0.15),\n    0 4px 10px rgba(168, 85, 247, 0.1);\n}\n\n.dark .asset-card-glow:hover {\n  box-shadow: \n    0 0 0 1px rgba(99, 102, 241, 0.3),\n    0 8px 30px rgba(99, 102, 241, 0.2),\n    0 4px 15px rgba(168, 85, 247, 0.15);\n}\n\n/* Neon Accent Line */\n.neon-accent {\n  position: relative;\n}\n\n.neon-accent::after {\n  content: '';\n  position: absolute;\n  bottom: 0;\n  left: 0;\n  right: 0;\n  height: 2px;\n  background: linear-gradient(\n    90deg,\n    transparent,\n    rgba(99, 102, 241, 0.8),\n    rgba(168, 85, 247, 0.8),\n    transparent\n  );\n  animation: shimmer 2s ease-in-out infinite;\n  background-size: 200% 100%;\n}\n\n/* Dashboard Hero Balance Section */\n.hero-balance {\n  position: relative;\n  padding: 2rem;\n  background: linear-gradient(\n    135deg,\n    rgba(99, 102, 241, 0.05) 0%,\n    rgba(168, 85, 247, 0.05) 50%,\n    rgba(236, 72, 153, 0.05) 100%\n  );\n  border-radius: 1rem;\n  overflow: hidden;\n}\n\n.hero-balance::before {\n  content: '';\n  position: absolute;\n  inset: 0;\n  background: linear-gradient(\n    135deg,\n    rgba(255, 255, 255, 0.1) 0%,\n    transparent 50%\n  );\n  pointer-events: none;\n}\n\n.dark .hero-balance {\n  background: linear-gradient(\n    135deg,\n    rgba(99, 102, 241, 0.1) 0%,\n    rgba(168, 85, 247, 0.08) 50%,\n    rgba(236, 72, 153, 0.06) 100%\n  );\n}\n\n/* Chain Icon Ring */\n.chain-ring {\n  position: relative;\n}\n\n.chain-ring::before {\n  content: '';\n  position: absolute;\n  inset: -3px;\n  border-radius: 50%;\n  background: conic-gradient(\n    from 0deg,\n    rgba(99, 102, 241, 0.6),\n    rgba(168, 85, 247, 0.6),\n    rgba(236, 72, 153, 0.6),\n    rgba(99, 102, 241, 0.6)\n  );\n  animation: border-dance 4s linear infinite;\n  z-index: -1;\n}\n\n/* Subtle Grain Texture Overlay */\n.grain-overlay {\n  position: fixed;\n  inset: 0;\n  pointer-events: none;\n  z-index: 100;\n  opacity: 0.03;\n  background-image: url(\"data:image/svg+xml,%3Csvg viewBox='0 0 200 200' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noise'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.9' numOctaves='4' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noise)'/%3E%3C/svg%3E\");\n}\n\n.dark .grain-overlay {\n  opacity: 0.04;\n}\n\n/* Hide scrollbar utility */\n.scrollbar-hide {\n  -ms-overflow-style: none;\n  scrollbar-width: none;\n}\n\n.scrollbar-hide::-webkit-scrollbar {\n  display: none;\n}\n","path":null,"size_bytes":21358,"size_tokens":null},"client/src/components/ui/toast.tsx":{"content":"import * as React from \"react\"\nimport * as ToastPrimitives from \"@radix-ui/react-toast\"\nimport { cva, type VariantProps } from \"class-variance-authority\"\nimport { X } from \"lucide-react\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst ToastProvider = ToastPrimitives.Provider\n\nconst ToastViewport = React.forwardRef<\n  React.ElementRef<typeof ToastPrimitives.Viewport>,\n  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Viewport>\n>(({ className, ...props }, ref) => (\n  <ToastPrimitives.Viewport\n    ref={ref}\n    className={cn(\n      \"fixed top-0 z-[100] flex max-h-screen w-full flex-col-reverse p-4 sm:bottom-0 sm:right-0 sm:top-auto sm:flex-col md:max-w-[420px]\",\n      className\n    )}\n    {...props}\n  />\n))\nToastViewport.displayName = ToastPrimitives.Viewport.displayName\n\nconst toastVariants = cva(\n  \"group pointer-events-auto relative flex w-full items-center justify-between space-x-4 overflow-hidden rounded-md border p-6 pr-8 shadow-lg transition-all data-[swipe=cancel]:translate-x-0 data-[swipe=end]:translate-x-[var(--radix-toast-swipe-end-x)] data-[swipe=move]:translate-x-[var(--radix-toast-swipe-move-x)] data-[swipe=move]:transition-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[swipe=end]:animate-out data-[state=closed]:fade-out-80 data-[state=closed]:slide-out-to-right-full data-[state=open]:slide-in-from-top-full data-[state=open]:sm:slide-in-from-bottom-full\",\n  {\n    variants: {\n      variant: {\n        default: \"border bg-background text-foreground\",\n        destructive:\n          \"destructive group border-destructive bg-destructive text-destructive-foreground\",\n      },\n    },\n    defaultVariants: {\n      variant: \"default\",\n    },\n  }\n)\n\nconst Toast = React.forwardRef<\n  React.ElementRef<typeof ToastPrimitives.Root>,\n  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Root> &\n    VariantProps<typeof toastVariants>\n>(({ className, variant, ...props }, ref) => {\n  return (\n    <ToastPrimitives.Root\n      ref={ref}\n      className={cn(toastVariants({ variant }), className)}\n      {...props}\n    />\n  )\n})\nToast.displayName = ToastPrimitives.Root.displayName\n\nconst ToastAction = React.forwardRef<\n  React.ElementRef<typeof ToastPrimitives.Action>,\n  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Action>\n>(({ className, ...props }, ref) => (\n  <ToastPrimitives.Action\n    ref={ref}\n    className={cn(\n      \"inline-flex h-8 shrink-0 items-center justify-center rounded-md border bg-transparent px-3 text-sm font-medium ring-offset-background transition-colors hover:bg-secondary focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 group-[.destructive]:border-muted/40 group-[.destructive]:hover:border-destructive/30 group-[.destructive]:hover:bg-destructive group-[.destructive]:hover:text-destructive-foreground group-[.destructive]:focus:ring-destructive\",\n      className\n    )}\n    {...props}\n  />\n))\nToastAction.displayName = ToastPrimitives.Action.displayName\n\nconst ToastClose = React.forwardRef<\n  React.ElementRef<typeof ToastPrimitives.Close>,\n  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Close>\n>(({ className, ...props }, ref) => (\n  <ToastPrimitives.Close\n    ref={ref}\n    className={cn(\n      \"absolute right-2 top-2 rounded-md p-1 text-foreground/50 opacity-0 transition-opacity hover:text-foreground focus:opacity-100 focus:outline-none focus:ring-2 group-hover:opacity-100 group-[.destructive]:text-red-300 group-[.destructive]:hover:text-red-50 group-[.destructive]:focus:ring-red-400 group-[.destructive]:focus:ring-offset-red-600\",\n      className\n    )}\n    toast-close=\"\"\n    {...props}\n  >\n    <X className=\"h-4 w-4\" />\n  </ToastPrimitives.Close>\n))\nToastClose.displayName = ToastPrimitives.Close.displayName\n\nconst ToastTitle = React.forwardRef<\n  React.ElementRef<typeof ToastPrimitives.Title>,\n  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Title>\n>(({ className, ...props }, ref) => (\n  <ToastPrimitives.Title\n    ref={ref}\n    className={cn(\"text-sm font-semibold\", className)}\n    {...props}\n  />\n))\nToastTitle.displayName = ToastPrimitives.Title.displayName\n\nconst ToastDescription = React.forwardRef<\n  React.ElementRef<typeof ToastPrimitives.Description>,\n  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Description>\n>(({ className, ...props }, ref) => (\n  <ToastPrimitives.Description\n    ref={ref}\n    className={cn(\"text-sm opacity-90\", className)}\n    {...props}\n  />\n))\nToastDescription.displayName = ToastPrimitives.Description.displayName\n\ntype ToastProps = React.ComponentPropsWithoutRef<typeof Toast>\n\ntype ToastActionElement = React.ReactElement<typeof ToastAction>\n\nexport {\n  type ToastProps,\n  type ToastActionElement,\n  ToastProvider,\n  ToastViewport,\n  Toast,\n  ToastTitle,\n  ToastDescription,\n  ToastClose,\n  ToastAction,\n}\n","path":null,"size_bytes":4845,"size_tokens":null},"client/src/components/ui/aspect-ratio.tsx":{"content":"import * as AspectRatioPrimitive from \"@radix-ui/react-aspect-ratio\"\n\nconst AspectRatio = AspectRatioPrimitive.Root\n\nexport { AspectRatio }\n","path":null,"size_bytes":140,"size_tokens":null},"replit.md":{"content":"# Pico Hardware Wallet\n\n## Overview\n\nA multi-chain cryptocurrency hardware wallet application that supports both hardware wallet connections (Ledger, Raspberry Pi Pico) and software wallet functionality. The app enables users to manage crypto assets across multiple blockchains including Ethereum, Bitcoin, Solana, and various EVM-compatible chains. Key features include secure PIN-based authentication, BIP44 key derivation, transaction signing, WalletConnect integration for DApp connectivity, and real-time balance tracking via blockchain APIs.\n\n## User Preferences\n\nPreferred communication style: Simple, everyday language.\n\n## System Architecture\n\n### Frontend Architecture\n- **Framework**: React 18 with TypeScript, using Vite as the build tool\n- **Routing**: Wouter for lightweight client-side routing\n- **State Management**: React Context (WalletContext, ThemeContext) combined with TanStack Query for server state\n- **UI Components**: Radix UI primitives wrapped with shadcn/ui styling conventions\n- **Styling**: Tailwind CSS with CSS variables for theming (light/dark mode support)\n- **Animations**: Framer Motion for subtle UI transitions\n\n### Backend Architecture\n- **Runtime**: Node.js with Express.js\n- **API Pattern**: RESTful endpoints with WebSocket support for real-time bridge functionality\n- **Build**: esbuild for server bundling, Vite for client\n- **Structure**: Shared code between client/server in `/shared` directory for type safety\n\n### Data Storage\n- **Database**: PostgreSQL with Drizzle ORM for schema management and queries\n- **Client Storage**: IndexedDB (via custom clientStorage abstraction) for wallet data, transactions, and preferences\n- **Encryption**: PBKDF2 key derivation with AES-GCM encryption for seed phrase storage on client\n\n### Hardware Wallet Integration\n- **Ledger**: WebHID API via @ledgerhq/hw-transport-webhid\n- **Raspberry Pi Pico**: Web Serial API for USB communication with custom firmware\n- **Mobile USB**: Capacitor plugin for Android USB serial support\n- **Simulated Mode**: In-memory wallet for development/testing\n\n### Blockchain Integration\n- **EVM Chains**: ethers.js v6 for transaction building, signing, and RPC calls\n- **Non-EVM Chains**: Custom implementations for Bitcoin, Solana, Tron using native crypto libraries\n- **Key Derivation**: BIP39/BIP44 standard paths with support for ed25519 (Solana, Polkadot) and secp256k1 (Bitcoin, Ethereum)\n- **Price Data**: DefiLlama and CoinGecko APIs with local caching\n\n### Security Model\n- PIN-based device unlock with configurable length (4-6 digits)\n- Session timeout with automatic lock (5 minutes default)\n- Seed phrases encrypted at rest, decrypted only during active session\n- Hardware signing ensures private keys never leave the device\n\n## External Dependencies\n\n### Blockchain Services\n- **RPC Endpoints**: LlamaRPC (Ethereum), Binance (BSC), official nodes for other chains\n- **Price APIs**: DefiLlama, CoinGecko for asset pricing\n- **Block Explorers**: Etherscan-compatible APIs for transaction history\n\n### Third-Party Libraries\n- **Crypto**: @noble/ed25519, @noble/hashes, tweetnacl for cryptographic operations\n- **Wallet Integration**: @walletconnect/web3wallet for DApp connections\n- **Hardware**: @ledgerhq packages for Ledger device communication\n\n### Mobile Platform\n- **Capacitor**: Cross-platform native functionality (Android USB serial, clipboard)\n- **Target**: Android app with USB OTG support for Pico connection\n\n### Development Tools\n- **Replit Plugins**: Runtime error overlay, dev banner, cartographer for development experience\n- **TypeScript**: Strict mode with path aliases (@/, @shared/)","path":null,"size_bytes":3628,"size_tokens":null},"client/src/lib/pending-tx-tracker.ts":{"content":"import { ethers } from \"ethers\";\n\nexport interface PendingTransaction {\n  id: string;\n  txHash: string;\n  chainId: string;\n  evmChainId?: number;\n  tokenSymbol: string;\n  amount: string;\n  toAddress: string;\n  fromAddress: string;\n  timestamp: string;\n  status: \"pending\" | \"confirming\" | \"confirmed\" | \"failed\";\n  currentConfirmations: number;\n  requiredConfirmations: number;\n}\n\nconst RPC_ENDPOINTS: Record<number, string> = {\n  1: \"https://eth.llamarpc.com\",\n  56: \"https://bsc-dataseed.binance.org\",\n  137: \"https://polygon-rpc.com\",\n  43114: \"https://api.avax.network/ext/bc/C/rpc\",\n  42161: \"https://arb1.arbitrum.io/rpc\",\n};\n\nconst REQUIRED_CONFIRMATIONS: Record<number, number> = {\n  1: 12,\n  56: 15,\n  137: 128,\n  43114: 12,\n  42161: 12,\n};\n\ntype Listener = (transactions: PendingTransaction[]) => void;\n\nclass PendingTransactionTracker {\n  private transactions: Map<string, PendingTransaction> = new Map();\n  private listeners: Set<Listener> = new Set();\n  private pollingIntervals: Map<string, NodeJS.Timeout> = new Map();\n\n  addTransaction(tx: Omit<PendingTransaction, \"status\" | \"currentConfirmations\" | \"requiredConfirmations\">): void {\n    const pendingTx: PendingTransaction = {\n      ...tx,\n      status: \"pending\",\n      currentConfirmations: 0,\n      requiredConfirmations: tx.evmChainId ? (REQUIRED_CONFIRMATIONS[tx.evmChainId] || 12) : 12,\n    };\n\n    this.transactions.set(tx.id, pendingTx);\n    this.notifyListeners();\n    this.startPolling(tx.id);\n  }\n\n  private async startPolling(txId: string): Promise<void> {\n    const tx = this.transactions.get(txId);\n    if (!tx || !tx.evmChainId) return;\n\n    const rpcUrl = RPC_ENDPOINTS[tx.evmChainId];\n    if (!rpcUrl) {\n      this.updateTransaction(txId, { status: \"confirmed\" });\n      return;\n    }\n\n    const provider = new ethers.JsonRpcProvider(rpcUrl);\n    let failedAttempts = 0;\n    const maxAttempts = 60;\n\n    const poll = async () => {\n      try {\n        const receipt = await provider.getTransactionReceipt(tx.txHash);\n        \n        if (receipt) {\n          if (receipt.status === 0) {\n            this.updateTransaction(txId, { status: \"failed\" });\n            this.stopPolling(txId);\n            setTimeout(() => {\n              this.removeTransaction(txId);\n            }, 10000);\n            return;\n          }\n          \n          const currentBlock = await provider.getBlockNumber();\n          const confirmations = currentBlock - receipt.blockNumber + 1;\n          \n          const updatedTx = this.transactions.get(txId);\n          if (!updatedTx) return;\n\n          if (confirmations >= updatedTx.requiredConfirmations) {\n            this.updateTransaction(txId, {\n              status: \"confirmed\",\n              currentConfirmations: confirmations,\n            });\n            this.stopPolling(txId);\n            \n            setTimeout(() => {\n              this.removeTransaction(txId);\n            }, 5000);\n            return;\n          } else {\n            this.updateTransaction(txId, {\n              status: \"confirming\",\n              currentConfirmations: confirmations,\n            });\n          }\n        } else {\n          failedAttempts++;\n          if (failedAttempts >= maxAttempts) {\n            this.updateTransaction(txId, { status: \"failed\" });\n            this.stopPolling(txId);\n            return;\n          }\n        }\n      } catch (error) {\n        console.error(\"Error polling transaction:\", error);\n        failedAttempts++;\n        if (failedAttempts >= maxAttempts) {\n          this.updateTransaction(txId, { status: \"failed\" });\n          this.stopPolling(txId);\n        }\n      }\n    };\n\n    poll();\n    const interval = setInterval(poll, 3000);\n    this.pollingIntervals.set(txId, interval);\n  }\n\n  private stopPolling(txId: string): void {\n    const interval = this.pollingIntervals.get(txId);\n    if (interval) {\n      clearInterval(interval);\n      this.pollingIntervals.delete(txId);\n    }\n  }\n\n  private updateTransaction(txId: string, updates: Partial<PendingTransaction>): void {\n    const tx = this.transactions.get(txId);\n    if (tx) {\n      this.transactions.set(txId, { ...tx, ...updates });\n      this.notifyListeners();\n    }\n  }\n\n  removeTransaction(txId: string): void {\n    this.stopPolling(txId);\n    this.transactions.delete(txId);\n    this.notifyListeners();\n  }\n\n  getTransactions(): PendingTransaction[] {\n    return Array.from(this.transactions.values());\n  }\n\n  getTransactionsForChain(chainId: string): PendingTransaction[] {\n    return this.getTransactions().filter(tx => tx.chainId === chainId);\n  }\n\n  subscribe(listener: Listener): () => void {\n    this.listeners.add(listener);\n    listener(this.getTransactions());\n    return () => this.listeners.delete(listener);\n  }\n\n  private notifyListeners(): void {\n    const txs = this.getTransactions();\n    this.listeners.forEach(listener => listener(txs));\n  }\n\n  clear(): void {\n    this.pollingIntervals.forEach((_, txId) => this.stopPolling(txId));\n    this.transactions.clear();\n    this.notifyListeners();\n  }\n}\n\nexport const pendingTxTracker = new PendingTransactionTracker();\n","path":null,"size_bytes":5086,"size_tokens":null},"client/src/pages/transaction-detail.tsx":{"content":"import { ArrowLeft, ArrowUpRight, ArrowDownLeft, Copy, ExternalLink, Clock, CheckCircle, XCircle, Loader2 } from \"lucide-react\";\nimport { Button } from \"@/components/ui/button\";\nimport { Card, CardContent } from \"@/components/ui/card\";\nimport { Badge } from \"@/components/ui/badge\";\nimport { useToast } from \"@/hooks/use-toast\";\nimport { DEFAULT_CHAINS } from \"@shared/schema\";\n\nexport default function TransactionDetail() {\n  const { toast } = useToast();\n\n  const params = new URLSearchParams(window.location.search);\n  const txHash = params.get(\"hash\");\n  const chainId = params.get(\"chain\");\n  const type = params.get(\"type\") as \"send\" | \"receive\";\n  const amount = params.get(\"amount\");\n  const tokenSymbol = params.get(\"token\");\n  const fromAddress = params.get(\"from\");\n  const toAddress = params.get(\"to\");\n  const timestamp = params.get(\"time\");\n  const status = params.get(\"status\") as \"confirmed\" | \"pending\" | \"failed\";\n\n  const chainIndex = chainId ? parseInt(chainId.replace(\"chain-\", \"\")) : 0;\n  const chain = DEFAULT_CHAINS[chainIndex];\n  const blockExplorer = chain?.blockExplorer || \"https://etherscan.io\";\n\n  const copyToClipboard = (text: string, label: string) => {\n    navigator.clipboard.writeText(text);\n    toast({ title: \"Copied\", description: `${label} copied to clipboard` });\n  };\n\n  const formatAddress = (addr: string | null) => {\n    if (!addr) return \"Unknown\";\n    return `${addr.slice(0, 10)}...${addr.slice(-8)}`;\n  };\n\n  const formatDate = (ts: string | null) => {\n    if (!ts) return \"Unknown\";\n    const date = new Date(ts);\n    return date.toLocaleString(\"en-US\", {\n      weekday: \"short\",\n      year: \"numeric\",\n      month: \"short\",\n      day: \"numeric\",\n      hour: \"2-digit\",\n      minute: \"2-digit\",\n      second: \"2-digit\",\n    });\n  };\n\n  const getStatusIcon = () => {\n    switch (status) {\n      case \"confirmed\":\n        return <CheckCircle className=\"w-5 h-5 text-green-500\" />;\n      case \"pending\":\n        return <Loader2 className=\"w-5 h-5 text-yellow-500 animate-spin\" />;\n      case \"failed\":\n        return <XCircle className=\"w-5 h-5 text-red-500\" />;\n      default:\n        return <Clock className=\"w-5 h-5 text-muted-foreground\" />;\n    }\n  };\n\n  const getStatusColor = () => {\n    switch (status) {\n      case \"confirmed\":\n        return \"bg-green-500/10 text-green-600 border-green-500/20\";\n      case \"pending\":\n        return \"bg-yellow-500/10 text-yellow-600 border-yellow-500/20\";\n      case \"failed\":\n        return \"bg-red-500/10 text-red-600 border-red-500/20\";\n      default:\n        return \"bg-muted text-muted-foreground\";\n    }\n  };\n\n  return (\n    <div className=\"min-h-screen bg-background\">\n      <div className=\"p-4 border-b flex items-center gap-3\">\n        <Button\n          variant=\"ghost\"\n          size=\"icon\"\n          onClick={() => window.history.back()}\n          data-testid=\"button-back\"\n        >\n          <ArrowLeft className=\"w-5 h-5\" />\n        </Button>\n        <h1 className=\"text-lg font-semibold\">Transaction Details</h1>\n      </div>\n\n      <div className=\"p-4 space-y-4\">\n        <div className=\"flex flex-col items-center py-6\">\n          <div className={`w-16 h-16 rounded-full flex items-center justify-center mb-4 ${\n            type === \"receive\" ? \"bg-green-500/10\" : \"bg-red-500/10\"\n          }`}>\n            {type === \"receive\" ? (\n              <ArrowDownLeft className=\"w-8 h-8 text-green-500\" />\n            ) : (\n              <ArrowUpRight className=\"w-8 h-8 text-red-500\" />\n            )}\n          </div>\n          \n          <h2 className={`text-2xl font-bold ${\n            type === \"receive\" ? \"text-green-500\" : \"text-red-500\"\n          }`} data-testid=\"text-amount\">\n            {type === \"receive\" ? \"+\" : \"-\"}{amount} {tokenSymbol}\n          </h2>\n          \n          <p className=\"text-muted-foreground capitalize mt-1\" data-testid=\"text-type\">\n            {type === \"receive\" ? \"Received\" : \"Sent\"}\n          </p>\n        </div>\n\n        <Card>\n          <CardContent className=\"p-4 space-y-4\">\n            <div className=\"flex items-center justify-between\">\n              <span className=\"text-muted-foreground\">Status</span>\n              <Badge variant=\"outline\" className={getStatusColor()}>\n                <span className=\"flex items-center gap-1.5\">\n                  {getStatusIcon()}\n                  <span className=\"capitalize\">{status || \"Unknown\"}</span>\n                </span>\n              </Badge>\n            </div>\n\n            <div className=\"flex items-center justify-between\">\n              <span className=\"text-muted-foreground\">Date</span>\n              <span className=\"text-sm\" data-testid=\"text-date\">{formatDate(timestamp)}</span>\n            </div>\n\n            <div className=\"flex items-center justify-between\">\n              <span className=\"text-muted-foreground\">Network</span>\n              <span data-testid=\"text-network\">{chain?.name || \"Unknown\"}</span>\n            </div>\n          </CardContent>\n        </Card>\n\n        <Card>\n          <CardContent className=\"p-4 space-y-4\">\n            <div>\n              <span className=\"text-muted-foreground text-sm\">From</span>\n              <div className=\"flex items-center justify-between mt-1\">\n                <span className=\"font-mono text-sm\" data-testid=\"text-from\">{formatAddress(fromAddress)}</span>\n                {fromAddress && (\n                  <Button\n                    variant=\"ghost\"\n                    size=\"icon\"\n                    onClick={() => copyToClipboard(fromAddress, \"Address\")}\n                    data-testid=\"button-copy-from\"\n                  >\n                    <Copy className=\"w-4 h-4\" />\n                  </Button>\n                )}\n              </div>\n            </div>\n\n            <div>\n              <span className=\"text-muted-foreground text-sm\">To</span>\n              <div className=\"flex items-center justify-between mt-1\">\n                <span className=\"font-mono text-sm\" data-testid=\"text-to\">{formatAddress(toAddress)}</span>\n                {toAddress && (\n                  <Button\n                    variant=\"ghost\"\n                    size=\"icon\"\n                    onClick={() => copyToClipboard(toAddress, \"Address\")}\n                    data-testid=\"button-copy-to\"\n                  >\n                    <Copy className=\"w-4 h-4\" />\n                  </Button>\n                )}\n              </div>\n            </div>\n          </CardContent>\n        </Card>\n\n        <Card>\n          <CardContent className=\"p-4\">\n            <div>\n              <span className=\"text-muted-foreground text-sm\">Transaction Hash</span>\n              <div className=\"flex items-center justify-between mt-1\">\n                <span className=\"font-mono text-sm truncate flex-1 mr-2\" data-testid=\"text-hash\">\n                  {txHash ? `${txHash.slice(0, 16)}...${txHash.slice(-12)}` : \"Unknown\"}\n                </span>\n                <div className=\"flex gap-1\">\n                  {txHash && (\n                    <>\n                      <Button\n                        variant=\"ghost\"\n                        size=\"icon\"\n                        onClick={() => copyToClipboard(txHash, \"Transaction hash\")}\n                        data-testid=\"button-copy-hash\"\n                      >\n                        <Copy className=\"w-4 h-4\" />\n                      </Button>\n                      <Button\n                        variant=\"ghost\"\n                        size=\"icon\"\n                        onClick={() => window.open(`${blockExplorer}/tx/${txHash}`, \"_blank\")}\n                        data-testid=\"button-explorer\"\n                      >\n                        <ExternalLink className=\"w-4 h-4\" />\n                      </Button>\n                    </>\n                  )}\n                </div>\n              </div>\n            </div>\n          </CardContent>\n        </Card>\n\n        <Button\n          variant=\"outline\"\n          className=\"w-full\"\n          onClick={() => window.open(`${blockExplorer}/tx/${txHash}`, \"_blank\")}\n          data-testid=\"button-view-explorer\"\n        >\n          <ExternalLink className=\"w-4 h-4 mr-2\" />\n          View on Block Explorer\n        </Button>\n      </div>\n    </div>\n  );\n}\n","path":null,"size_bytes":8209,"size_tokens":null}},"version":2}